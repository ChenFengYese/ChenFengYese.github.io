<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>120个Java面试题和答案</title><meta name="author" content="YCanPDF"><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
.s1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12.5pt; }
.p, p { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12.5pt; margin:0pt; }
.s2 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 18.5pt; }
.s3 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 24pt; }
.s4 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 24pt; }
li {display: block; }
#l1 {padding-left: 0pt;counter-reset: c1 43; }
#l1> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
#l1> li:first-child>*:first-child:before {counter-increment: c1 0;  }
li {display: block; }
#l2 {padding-left: 0pt;counter-reset: d1 45; }
#l2> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
#l2> li:first-child>*:first-child:before {counter-increment: d1 0;  }
#l3 {padding-left: 0pt;counter-reset: d2 1; }
#l3> li>*:first-child:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12.5pt; }
#l3> li:first-child>*:first-child:before {counter-increment: d2 0;  }
li {display: block; }
#l4 {padding-left: 0pt;counter-reset: e1 53; }
#l4> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
#l4> li:first-child>*:first-child:before {counter-increment: e1 0;  }
li {display: block; }
#l5 {padding-left: 0pt;counter-reset: f1 68; }
#l5> li>*:first-child:before {counter-increment: f1; content: counter(f1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
#l5> li:first-child>*:first-child:before {counter-increment: f1 0;  }
li {display: block; }
#l6 {padding-left: 0pt;counter-reset: g1 79; }
#l6> li>*:first-child:before {counter-increment: g1; content: counter(g1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
#l6> li:first-child>*:first-child:before {counter-increment: g1 0;  }
li {display: block; }
#l7 {padding-left: 0pt;counter-reset: h1 85; }
#l7> li>*:first-child:before {counter-increment: h1; content: counter(h1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
#l7> li:first-child>*:first-child:before {counter-increment: h1 0;  }
li {display: block; }
#l8 {padding-left: 0pt;counter-reset: i1 94; }
#l8> li>*:first-child:before {counter-increment: i1; content: counter(i1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
#l8> li:first-child>*:first-child:before {counter-increment: i1 0;  }
</style></head><body><p style="text-indent: 0pt;text-align: left;"><br></p>
<div id="node-list" style="padding-left: 3vw;margin-top:1vw;"></div>
<p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s3" style="padding-top: 17pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">题目：<span class="s4">115</span>个<span class="s4">Java</span>面试题和答案<span class="s4">——</span>终极（下）</p><p style="padding-top: 16pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">第一篇讨论了面向对象编程和它的特点，关于<span class="s1">Java</span>和它的功能的常见问题，<span class="s1">Java</span>的集合类，</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">垃圾收集器，本章主要讨论异常处理，<span class="s1">Java</span>小应用程序，<span class="s1">Swing</span>，<span class="s1">JDBC</span>，远程方法调用<span class="s1">(RMI)</span>， <span class="s1">Servlet</span>和<span class="s1">JSP</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">异常处理</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Java<span class="p">小应用程序</span>(Applet) Swing</p><p class="s1" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">JDBC</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-top: 12pt;padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">远程方法调用（<span class="s1">RMI</span>） <span class="s1">Servlet</span></p><p class="s1" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">JSP</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-top: 12pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">异常处理</p><p style="text-indent: 0pt;text-align: left;"><br></p><ol id="l1"><li data-list-text="43."><p class="s1" style="padding-top: 8pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="p">中的两种异常类型是什么？他们有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 130%;text-align: left;">Java<span class="p">中有两种异常：受检查的</span>(checked)<span class="p">异常和不受检查的</span>(unchecked)<span class="p">异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用</span>throws<span class="p">语句在方法或者是构造函数上声明。这里有</span>Java<span class="p">异常处理的一些小建议。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="44."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="p">中</span>Exception<span class="p">和</span>Error<span class="p">有什么区别？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Exception<span class="p">和</span>Error<span class="p">都是</span>Throwable<span class="p">的子类。</span>Exception<span class="p">用于用户程序可以捕获的异常情况。</span>Error</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">定义了不期望被用户程序捕获的异常。</p><p style="text-indent: 0pt;text-align: left;"><br></p><ol id="l2"><ol id="l3"><li data-list-text="45.1"><p class="s1" style="padding-top: 9pt;padding-left: 32pt;text-indent: -26pt;text-align: left;">throw<span class="p">和</span>throws<span class="p">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">throw<span class="p">关键字用来在程序中明确的抛出异常，相反，</span>throws<span class="p">语句用来表明方法不能处理的异  常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="45.2"><p style="padding-left: 35pt;text-indent: -29pt;text-align: left;">异常处理的时候，<span class="s1">finally</span>代码块的重要性是什么？</p></li></ol></ol><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">无论是否抛出异常，<span class="s1">finally</span>代码块总是会被执行。就算是没有<span class="s1">catch</span>语句同时又抛出异常的</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">情况下，<span class="s1">finally</span>代码块仍然会被执行。最后要说的是，<span class="s1">finally</span>代码块主要用来释放资源，比如：<span class="s1">I/O</span>缓冲区，数据库连接。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">46.<span class="p">异常处理完成以后，</span>Exception<span class="p">对象会发生什么变化？ </span>Exception<span class="p">对象会在下一个垃圾回收过程中被回收掉。 </span>47.finally<span class="p">代码块和</span>finalize()<span class="p">方法有什么区别？</span></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">无论是否抛出异常，<span class="s1">finally</span>代码块都会执行，它主要是用来释放应用占用的资源。<span class="s1">finalize()</span>方法是<span class="s1">Object</span>类的一个<span class="s1">protected</span>方法，它是在对象被垃圾回收之前由<span class="s1">Java</span>虚拟机来调用的。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Java<span class="p">小应用程序</span>(Applet) 48.<span class="p">什么是</span>Applet<span class="p">？</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">java applet<span class="p">是能够被包含在</span>HTML<span class="p">页面中并且能被启用了</span>java<span class="p">的客户端浏览器执行的程序。 </span>Applet<span class="p">主要用来创建动态交互的</span>web<span class="p">应用程序。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">49.<span class="p">解释一下</span>Applet<span class="p">的生命周期 </span>applet<span class="p">可以经历下面的状态：</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Init<span class="p">：每次被载入的时候都会被初始化。 </span>Start<span class="p">：开始执行</span>applet<span class="p">。</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Stop<span class="p">：结束执行</span>applet<span class="p">。</span></p><p class="s1" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Destroy<span class="p">：卸载</span>applet<span class="p">之前，做最后的清理工作。 </span>50.<span class="p">当</span>applet<span class="p">被载入的时候会发生什么？</span></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">首先，创建<span class="s1">applet</span>控制类的实例，然后初始化<span class="s1">applet</span>，最后开始运行。 <span class="s1">51.Applet</span>和普通的<span class="s1">Java</span>应用程序有什么区别？</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">applet<span class="p">是运行在启用了</span>java<span class="p">的浏览器中，</span>Java<span class="p">应用程序是可以在浏览器之外运行的独立的</span></p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="p">程序。但是，它们都需要有</span>Java<span class="p">虚拟机。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">进一步来说，<span class="s1">Java</span>应用程序需要一个有特定方法签名的<span class="s1">main</span>函数来开始执行。<span class="s1">Java applet</span></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">不需要这样的函数来开始执行。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">最后，<span class="s1">Java applet</span>一般会使用很严格的安全策略，<span class="s1">Java</span>应用一般使用比较宽松的安全策略。 <span class="s1">52.Java applet</span>有哪些限制条件？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">主要是由于安全的原因，给<span class="s1">applet</span>施加了以下的限制：</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">applet<span class="p">不能够载入类库或者定义本地方法。 </span>applet<span class="p">不能在宿主机上读写文件。</span></p><p class="s1" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">applet<span class="p">不能读取特定的系统属性。</span></p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">applet<span class="p">不能发起网络连接，除非是跟宿主机。 </span>applet<span class="p">不能够开启宿主机上其他任何的程序。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><ol id="l4"><li data-list-text="53."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是不受信任的<span class="s1">applet</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">不受信任的<span class="s1">applet</span>是不能访问或是执行本地系统文件的<span class="s1">Java applet</span>，默认情况下，所有下载的<span class="s1">applet</span>都是不受信任的。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="54."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">从网络上加载的<span class="s1">applet</span>和从本地文件系统加载的<span class="s1">applet</span>有什么区别？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">当<span class="s1">applet</span>是从网络上加载的时候，<span class="s1">applet</span>是由<span class="s1">applet</span>类加载器载入的，它受<span class="s1">applet</span>安全管理器的限制。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">当<span class="s1">applet</span>是从客户端的本地磁盘载入的时候，<span class="s1">applet</span>是由文件系统加载器载入的。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">从文件系统载入的<span class="s1">applet</span>允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="55."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">applet<span class="p">类加载器是什么？它会做哪些工作？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">当<span class="s1">applet</span>是从网络上加载的时候，它是由<span class="s1">applet</span>类加载器载入的。类加载器有自己的<span class="s1">java</span></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">当浏览器通过网络载入<span class="s1">applet</span>的时候，<span class="s1">applet</span>的类被放置于和<span class="s1">applet</span>的源相关联的私有的名</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守<span class="s1">Java</span>语言规范，确保不会出现堆栈溢出<span class="s1">(stack overflow)</span>或者下溢  <span class="s1">(underflow)</span>，传递给字节码指令的参数是正确的。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="56."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">applet<span class="p">安全管理器是什么？它会做哪些工作？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">applet<span class="p">安全管理器是给</span>applet<span class="p">施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Swing</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="57."><p style="padding-top: 12pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">弹出式选择菜单<span class="s1">(Choice)</span>和列表<span class="s1">(List)</span>有什么区别</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Choice<span class="p">是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。</span>Choice<span class="p">中一次只能选中</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">一个选项。<span class="s1">List</span>同时可以有多个元素可见，支持选中一个或者多个元素。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="58."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是布局管理器？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">布局管理器用来在容器中组织组件。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="59."><p style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">滚动条<span class="s1">(Scrollbar)</span>和滚动面板<span class="s1">(JScrollPane)</span>有什么区别？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 263%;text-align: left;">Scrollbar<span class="p">是一个组件，不是容器。而</span>ScrollPane<span class="p">是容器。</span>ScrollPane<span class="p">自己处理滚动事件。 </span>60.<span class="p">哪些</span>Swing<span class="p">的方法是线程安全的？</span></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">只有<span class="s1">3</span>个线程安全的方法： <span class="s1">repaint(), revalidate(), and invalidate()</span>。 <span class="s1">61.</span>说出三种支持重绘<span class="s1">(painting)</span>的组件。</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 252%;text-align: left;">Canvas, Frame, Panel,<span class="p">和</span>Applet<span class="p">支持重绘。 </span>62.<span class="p">什么是裁剪</span>(clipping)<span class="p">？</span></p><p style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">限制在一个给定的区域或者形状的绘图操作就做裁剪。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">63.MenuItem<span class="p">和</span>CheckboxMenuItem<span class="p">的区别是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">CheckboxMenuItem<span class="p">类继承自</span>MenuItem<span class="p">类，支持菜单选项可以选中或者不选中。  </span>64.<span class="p">边缘布局</span>(BorderLayout)<span class="p">里面的元素是如何布局的？</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 263%;text-align: left;">BorderLayout<span class="p">里面的元素是按照容器的东西南北中进行布局的。 </span>65.<span class="p">网格包布局</span>(GridBagLayout)<span class="p">里面的元素是如何布局的？</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">GridBagLayout<span class="p">里面的元素是按照网格进行布局的。不同大小的元素可能会占据网格的多于</span>1</p><p style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">行或一列。因此，行数和列数可以有不同的大小。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">66.Window<span class="p">和</span>Frame<span class="p">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Frame<span class="p">类继承了</span>Window<span class="p">类，它定义了一个可以有菜单栏的主应用窗口。 </span>67.<span class="p">裁剪</span>(clipping)<span class="p">和重绘</span>(repainting)<span class="p">有什么联系？</span></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">当窗口被<span class="s1">AWT</span>重绘线程进行重绘的时候，它会把裁剪区域设置成需要重绘的窗口的区域。</p><p style="text-indent: 0pt;text-align: left;"><br></p><ol id="l5"><li data-list-text="68."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">事件监听器接口<span class="s1">(event-listener interface)</span>和事件适配器<span class="s1">(event-adapter)</span>有什么关系？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">事件监听器接口定义了对特定的事件，事件处理器必须要实现的方法。事件适配器给事件监听器接口提供了默认的实现。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="69."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">GUI<span class="p">组件如何来处理它自己的事件？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">GUI<span class="p">组件可以处理它自己的事件，只要它实现相对应的事件监听器接口，并且把自己作为事件监听器。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="70."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="p">的布局管理器比传统的窗口系统有哪些优势？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="p">使用布局管理器以一种一致的方式在所有的窗口平台上摆放组件。因为布局管理器不会和组件的绝对大小和位置相绑定，所以他们能够适应跨窗口系统的特定平台的不同。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="71."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="p">的</span>Swing<span class="p">组件使用了哪种设计模式？</span></p><p class="s1" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Java<span class="p">中的</span>Swing<span class="p">组件使用了</span>MVC(<span class="p">视图</span>-<span class="p">模型</span>-<span class="p">控制器</span>)<span class="p">设计模式。 </span>JDBC</p></li><li data-list-text="72."><p style="padding-top: 4pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是<span class="s1">JDBC</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JDBC<span class="p">是允许用户在不同数据库之间做选择的一个抽象层。</span>JDBC<span class="p">允许开发者用</span>JAVA<span class="p">写数据库应用程序，而不需要关心底层特定数据库的细节。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="73."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">解释下驱动<span class="s1">(Driver)</span>在<span class="s1">JDBC</span>中的角色。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JDBC<span class="p">驱动提供了特定厂商对</span>JDBC  API<span class="p">接口类的实现，驱动必须要提供</span>java.sql<span class="p">包下面这些类的实现：</span>Connection, Statement, PreparedStatement,CallableStatement, ResultSet<span class="p">和</span>Driver<span class="p">。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="74."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Class.forName()<span class="p">方法有什么作用？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">这个方法用来载入跟数据库建立连接的驱动。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="75."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">PreparedStatement<span class="p">比</span>Statement<span class="p">有什么优势？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">PreparedStatements<span class="p">是预编译的，因此，性能会更好。同时，不同的查询参数值， </span>PreparedStatement<span class="p">可以重用。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="76."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么时候使用<span class="s1">CallableStatement</span>？用来准备<span class="s1">CallableStatement</span>的方法是什么？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">CallableStatement<span class="p">用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个</span>CallableStatement<span class="p">的方法是：</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 13pt;text-align: left;">CallableStament.prepareCall();</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="77."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">数据库连接池是什么意思？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 263%;text-align: left;">远程方法调用<span class="s1">(RMI) 78.</span>什么是<span class="s1">RMI</span>？</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 130%;text-align: left;">Java<span class="p">远程方法调用</span>(Java  RMI)<span class="p">是</span>Java  API<span class="p">对远程过程调用</span>(RPC)<span class="p">提供的面向对象的等价形式，支持直接传输序列化的</span>Java<span class="p">对象和分布式垃圾回收。远程方法调用可以看做是激活远程正  在运行的对象上的方法的步骤。</span>RMI<span class="p">对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下</span>RMI<span class="p">的一些注意事项。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><ol id="l6"><li data-list-text="79."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">RMI<span class="p">体系结构的基本原则是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">RMI<span class="p">体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。</span>RMI<span class="p">允许定义行为的代码和实现行为的代码相分离，并且运行在不同的</span>JVM<span class="p">上。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="80."><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">RMI<span class="p">体系结构分哪几层？ </span>RMI<span class="p">体系结构分以下几层：</span></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">存根和骨架层<span class="s1">(Stub and Skeleton layer)</span>：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的<span class="s1">RMI</span>服务。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">远程引用层<span class="s1">(Remote  Reference  Layer)</span>：<span class="s1">RMI</span>体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">传输层<span class="s1">(Transport  layer)</span>：这一层负责连接参与服务的两个<span class="s1">JVM</span>。这一层是建立在网络上机器间的<span class="s1">TCP/IP</span>连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="81."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">RMI<span class="p">中的远程接口</span>(Remote Interface)<span class="p">扮演了什么样的角色？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: justify;">远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="82."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">java.rmi.Naming<span class="p">类扮演了什么样的角色？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">java.rmi.Naming<span class="p">类用来存储和获取在远程对象注册表里面的远程对象的引用。</span>Naming<span class="p">类的</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">每一个方法接收一个<span class="s1">URL</span>格式的<span class="s1">String</span>对象作为它的参数。 <span class="s1">83.RMI</span>的绑定<span class="s1">(Binding)</span>是什么意思？</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">象可以使用<span class="s1">Naming</span>类的<span class="s1">bind()</span>或者<span class="s1">rebind()</span>方法跟名称相关联。 <span class="s1">84.Naming</span>类的<span class="s1">bind()</span>和<span class="s1">rebind()</span>方法有什么区别？</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">bind()<span class="p">方法负责把指定名称绑定给远程对象，</span>rebind()<span class="p">方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><ol id="l7"><li data-list-text="85."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">让<span class="s1">RMI</span>程序能正确运行有哪些步骤？</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 42pt;text-align: left;">为了让<span class="s1">RMI</span>程序能正确运行必须要包含以下几个步骤：编译所有的源文件。</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 128%;text-align: left;">使用<span class="s1">rmic</span>生成<span class="s1">stub</span>。启动<span class="s1">rmiregistry</span>。 启动<span class="s1">RMI</span>服务器。运行客户端程序。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="86."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">RMI<span class="p">的</span>stub<span class="p">扮演了什么样的角色？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">远程对象的<span class="s1">stub</span>扮演了远程对象的代表或者代理的角色。调用者在本地<span class="s1">stub</span>上调用方法，它负责在远程对象上执行方法。当<span class="s1">stub</span>的方法被调用的时候，会经历以下几个步骤：</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 126%;text-align: left;">初始化到包含了远程对象的<span class="s1">JVM</span>的连接。序列化参数到远程的<span class="s1">JVM</span>。</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">等待方法调用和执行的结果。</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">反序列化返回的值或者是方法没有执行成功情况下的异常。把值返回给调用者。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="87."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是分布式垃圾回收<span class="s1">(DGC)</span>？它是如何工作的？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">DGC<span class="p">叫做分布式垃圾回收。</span>RMI<span class="p">使用</span>DGC<span class="p">来做自动垃圾回收。因为</span>RMI<span class="p">包含了跨虚拟机的  远程对象的引用，垃圾回收是很困难的。</span>DGC<span class="p">使用引用计数算法来给远程对象提供自动内存管理。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="88."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">RMI<span class="p">中使用</span>RMI<span class="p">安全管理器</span>(RMISecurityManager)<span class="p">的目的是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">RMISecurityManager<span class="p">使用下载好的代码提供可被</span>RMI<span class="p">应用程序使用的安全管理器。如果没有设置安全管理器，</span>RMI<span class="p">的类加载器就不会从远程下载任何的类。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p></li><li data-list-text="89."><p style="padding-top: 3pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">解释下<span class="s1">Marshalling</span>和<span class="s1">demarshalling</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: left;">当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做<span class="s1">Marshalling</span>，反之就是  <span class="s1">demarshalling</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="90."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">解释下<span class="s1">Serialization</span>和<span class="s1">Deserialization</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">Java<span class="p">提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Servlet</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="91."><p style="padding-top: 12pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是<span class="s1">Servlet</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">Servlet<span class="p">是用来处理客户端请求并产生动态网页内容的</span>Java<span class="p">类。</span>Servlet<span class="p">主要是用来处理或者是存储</span>HTML<span class="p">表单提交的数据，产生动态内容，在无状态的</span>HTTP  <span class="p">协议下管理状态信息。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="92."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">说一下<span class="s1">Servlet</span>的体系结构。</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: justify;">所有的<span class="s1">Servlet</span>都必须要实现的核心的接口是<span class="s1">javax.servlet.Servlet</span>。每一个<span class="s1">Servlet</span>都必须要直接或者是间接实现这个接口，或者是继承<span class="s1">javax.servlet.GenericServlet</span>或者</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">javax.servlet.http.HTTP Servlet<span class="p">。最后，</span>Servlet<span class="p">使用多线程可以并行的为多个请求服务。 </span>93.Applet<span class="p">和</span>Servlet<span class="p">有什么区别？</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">Applet<span class="p">是运行在客户端主机的浏览器上的客户端</span>Java<span class="p">程序。而</span>Servlet<span class="p">是运行在</span>web<span class="p">服务器上的服务端的组件。</span>applet<span class="p">可以使用用户界面类，而</span>Servlet<span class="p">没有用户界面，相反，</span>Servlet<span class="p">是等待客户端的</span>HTTP<span class="p">请求，然后为请求产生响应。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><ol id="l8"><li data-list-text="94."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">GenericServlet<span class="p">和</span>HttpServlet<span class="p">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">GenericServlet<span class="p">是一个通用的协议无关的</span>Servlet<span class="p">，它实现了</span>Servlet<span class="p">和</span>ServletConfig<span class="p">接口。继承自</span>GenericServlet<span class="p">的</span>Servlet<span class="p">应该要覆盖</span>service()<span class="p">方法。最后，为了开发一个能用在网页上服务于使用</span>HTTP<span class="p">协议请求的</span>Servlet<span class="p">，你的</span>Servlet<span class="p">必须要继承自</span>HttpServlet<span class="p">。这里有</span>Servlet<span class="p">的例子。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="95."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">解释下<span class="s1">Servlet</span>的生命周期。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">对每一个客户端的请求，<span class="s1">Servlet</span>引擎载入<span class="s1">Servlet</span>，调用它的<span class="s1">init()</span>方法，完成<span class="s1">Servlet</span>的初始化。然后，<span class="s1">Servlet</span>对象通过为每一个请求单独调用<span class="s1">service()</span>方法来处理所有随后来自客户端</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">的请求，最后，调用<span class="s1">Servlet(</span>译者注：这里应该是<span class="s1">Servlet</span>而不是<span class="s1">server)</span>的<span class="s1">destroy()</span>方法把<span class="s1">Servlet</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">删除掉。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="96."><p class="s1" style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">doGet()<span class="p">方法和</span>doPost()<span class="p">方法有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">doGet<span class="p">：</span>GET<span class="p">方法会把名值对追加在请求的</span>URL<span class="p">后面。因为</span>URL<span class="p">对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">doPOST<span class="p">：</span>POST<span class="p">方法通过把请求参数值放在请求体中来克服</span>GET<span class="p">方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过</span>POST<span class="p">请求传递的敏感信息对外部客户端是不可见的。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="97."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是<span class="s1">Web</span>应用程序？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">Web<span class="p">应用程序是对</span>Web<span class="p">或者是应用服务器的动态扩展。有两种类型的</span>Web<span class="p">应用：面向表现  的和面向服务的。面向表现的</span>Web<span class="p">应用程序会产生包含了很多种标记语言和动态内容的交互的</span>web<span class="p">页面作为对请求的响应。而面向服务的</span>Web<span class="p">应用实现了</span>Web<span class="p">服务的端点</span>(endpoint)<span class="p">。一般来说，一个</span>Web<span class="p">应用可以看成是一组安装在服务器</span>URL<span class="p">名称空间的特定子集下面的  </span>Servlet<span class="p">的集合。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="98."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是服务端包含<span class="s1">(Server Side Include)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">服务端包含<span class="s1">(SSI)</span>是一种简单的解释型服务端脚本语言，大多数时候仅用在<span class="s1">Web</span>上，用<span class="s1">servlet</span>标签嵌入进来。<span class="s1">SSI</span>最常用的场景把一个或多个文件包含到<span class="s1">Web</span>服务器的一个<span class="s1">Web</span>页面中。当浏览器访问<span class="s1">Web</span>页面的时候，<span class="s1">Web</span>服务器会用对应的<span class="s1">servlet</span>产生的文本来替换<span class="s1">Web</span>页</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">面中的<span class="s1">servlet</span>标签。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="99."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是<span class="s1">Servlet</span>链<span class="s1">(Servlet Chaining)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Servlet<span class="p">链是把一个</span>Servlet<span class="p">的输出发送给另一个</span>Servlet<span class="p">的方法。第二个</span>Servlet<span class="p">的输出可以发送给第三个</span>Servlet<span class="p">，依次类推。链条上最后一个</span>Servlet<span class="p">负责把响应发送给客户端。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="100."><p style="padding-left: 29pt;text-indent: -23pt;text-align: left;">如何知道是哪一个客户端的机器正在请求你的<span class="s1">Servlet</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">ServletRequest<span class="p">类可以找出客户端机器的</span>IP<span class="p">地址或者是主机名。</span>getRemoteAddr()<span class="p">方法获取客户端主机的</span>IP<span class="p">地址，</span>getRemoteHost()<span class="p">可以获取主机名。看下这里的例子。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="101."><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">HTTP<span class="p">响应的结构是怎么样的？ </span>HTTP <span class="p">响应由三个部分组成：</span></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">状态码<span class="s1">(Status   Code)</span>：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果<span class="s1">Servlet</span>没有返回状态码，默认会返回成功的状态码<span class="s1">HttpServletResponse.SC_OK</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">HTTP <span class="p">头部</span>(HTTP  Header)<span class="p">：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在</span>Serlet</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">中检索<span class="s1">HTTP </span>的头部看这里。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">主体<span class="s1">(Body)</span>：它包含了响应的内容。它可以包含<span class="s1">HTML</span>代码，图片，等等。主体是由传输在 <span class="s1">HTTP </span>消息中紧跟在头部后面的数据字节组成的。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="102."><p style="padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">cookie</span>？<span class="s1">session</span>和<span class="s1">cookie</span>有什么区别？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">cookie<span class="p">是</span>Web<span class="p">服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个</span>Web<span class="p">服务器存储</span>cookie<span class="p">。以后浏览器在给特定的</span>Web<span class="p">服务器发请求的时候，同时会发送所有为该服务器存储的</span>cookie<span class="p">。下面列出了</span>session<span class="p">和</span>cookie<span class="p">的区别：</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">无论客户端浏览器做怎么样的设置，<span class="s1">session</span>都应该能正常工作。客户端可以选择禁用<span class="s1">cookie</span>，但是，<span class="s1">session</span>仍然是能够工作的，因为客户端无法禁用服务端的<span class="s1">session</span>。</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">在存储的数据量方面<span class="s1">session</span>和<span class="s1">cookies</span>也是不一样的。<span class="s1">session</span>能够存储任意的<span class="s1">Java</span>对象，  <span class="s1">cookie</span>只能存储<span class="s1">String</span>类型的对象。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="103."><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">浏览器和<span class="s1">Servlet</span>通信使用的是什么协议？浏览器和<span class="s1">Servlet</span>通信使用的是<span class="s1">HTTP</span>协议。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="104."><p style="padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">HTTP</span>隧道？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">HTTP <span class="p">隧道是一种利用</span>HTTP<span class="p">或者是</span>HTTP S<span class="p">把多种网络协议封装起来进行通信的技术。因此， </span>HTTP <span class="p">协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成</span>HTTP <span class="p">的请求就是</span>HTTP <span class="p">隧道。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="105."><p class="s1" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">sendRedirect()<span class="p">和</span>forward()<span class="p">方法有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 128%;text-align: left;">sendRedirect()<span class="p">方法会创建一个新的请求，而</span>forward()<span class="p">方法只是把请求转发到一个新的目标  上。重定向</span>(redirect)<span class="p">以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发</span>(forwarding)<span class="p">以后，之前请求作用域范围以内的对象还是能访问的。一般认为  </span>sendRedirect()<span class="p">比</span>forward()<span class="p">要慢。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="106."><p style="padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">URL</span>编码和<span class="s1">URL</span>解码？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 126%;text-align: left;">URL<span class="p">编码是负责把</span>URL<span class="p">里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">JSP</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="107."><p style="padding-top: 12pt;padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">JSP</span>页面？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s1" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JSP<span class="p">页面是一种包含了静态数据和</span>JSP<span class="p">元素两种类型的文本的文本文档。静态数据可以用任何基于文本的格式来表示，比如：</span>HTML<span class="p">或者</span>XML<span class="p">。</span>JSP<span class="p">是一种混合了静态内容和动态产生的内容的技术。这里看下</span>JSP<span class="p">的例子。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="108."><p class="s1" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">JSP<span class="p">请求是如何被处理的？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 130%;text-align: left;">浏览器首先要请求一个以<span class="s1">.jsp</span>扩展名结尾的页面，发起<span class="s1">JSP</span>请求，然后，<span class="s1">Web</span>服务器读取这个请求，使用<span class="s1">JSP</span>编译器把<span class="s1">JSP</span>页面转化成一个<span class="s1">Servlet</span>类。需要注意的是，只有当第一次请求页面或者是<span class="s1">JSP</span>文件发生改变的时候<span class="s1">JSP</span>文件才会被编译，然后服务器调用<span class="s1">servlet</span>类，处理浏览器的请求。一旦请求执行结束，<span class="s1">servlet</span>会把响应发送给客户端。这里看下如何在<span class="s1">JSP</span>中获取请求参数。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="109."><p class="s1" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">JSP<span class="p">有什么优点？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">下面列出了使用<span class="s1">JSP</span>的优点：</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JSP<span class="p">页面是被动态编译成</span>Servlet<span class="p">的，因此，开发者可以很容易的更新展现代码。 </span>JSP<span class="p">页面可以被预编译。</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">JSP<span class="p">页面可以很容易的和静态模板结合，包括：</span>HTML<span class="p">或者</span>XML<span class="p">，也可以很容易的和产生动</span></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">态内容的代码结合起来。</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">开发者可以提供让页面设计者以类<span class="s1">XML</span>格式来访问的自定义的<span class="s1">JSP</span>标签库。</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。</p></li><li data-list-text="110."><p style="padding-top: 5pt;padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">JSP</span>指令<span class="s1">(Directive)</span>？<span class="s1">JSP</span>中有哪些不同类型的指令？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Directive<span class="p">是当</span>JSP<span class="p">页面被编译成</span>Servlet<span class="p">的时候，</span>JSP<span class="p">引擎要处理的指令。</span>Directive<span class="p">用来设置</span></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">页面级别的指令，从外部文件插入数据，指定自定义的标签库。<span class="s1">Directive</span>是定义在<span class="s1">&lt;%@ </span>和 <span class="s1">%&gt;</span></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">之间的。下面列出了不同类型的<span class="s1">Directive</span>：</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">包含指令<span class="s1">(Include directive)</span>：用来包含文件和合并文件内容到当前的页面。</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">页面指令<span class="s1">(Page directive)</span>：用来定义<span class="s1">JSP</span>页面中特定的属性，比如错误页面和缓冲区。 <span class="s1">Taglib</span>指令： 用来声明页面中使用的自定义的标签库。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="111."><p style="padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">JSP</span>动作<span class="s1">(JSP action)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JSP<span class="p">动作以</span>XML<span class="p">语法的结构来控制</span>Servlet<span class="p">引擎的行为。当</span>JSP<span class="p">页面被请求的时候，</span>JSP<span class="p">动作   会被执行。它们可以被动态的插入到文件中，重用</span>JavaBean<span class="p">组件，转发用户到其他的页面，或者是给</span>Java<span class="p">插件产生</span>HTML<span class="p">代码。下面列出了可用的动作：</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">jsp:include-<span class="p">当</span>JSP<span class="p">页面被请求的时候包含一个文件。 </span>jsp:useBean-<span class="p">找出或者是初始化</span>Javabean<span class="p">。 </span>jsp:setProperty-<span class="p">设置</span>JavaBean<span class="p">的属性。 </span>jsp:getProperty-<span class="p">获取</span>JavaBean<span class="p">的属性。</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: left;">jsp:forward-<span class="p">把请求转发到新的页面。 </span>jsp:plugin-<span class="p">产生特定浏览器的代码。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="112."><p style="padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">Scriptlets</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JSP<span class="p">技术中，</span>scriptlet<span class="p">是嵌入在</span>JSP<span class="p">页面中的一段</span>Java<span class="p">代码。</span>scriptlet<span class="p">是位于标签内部的所有的东西，在标签与标签之间，用户可以添加任意有效的</span>scriplet<span class="p">。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="113."><p style="padding-left: 29pt;text-indent: -23pt;text-align: left;">声明<span class="s1">(Decalaration) </span>在哪里？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">声明跟<span class="s1">Java</span>中的变量声明很相似，它用来声明随后要被表达式或者<span class="s1">scriptlet</span>使用的变量。添加的声明必须要用开始和结束标签包起来。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="114."><p style="padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是表达式<span class="s1">(Expression)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JSP<span class="p">表达式是</span>Web<span class="p">服务器把脚本语言表达式的值转化成一个</span>String<span class="p">对象，插入到返回给客户端的数据流中。表达式是在</span>&lt;%=<span class="p">和</span>%&gt;<span class="p">这两个标签之间定义的。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="115."><p style="padding-left: 29pt;text-indent: -23pt;text-align: left;">隐含对象是什么意思？有哪些隐含对象？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JSP<span class="p">隐含对象是页面中的一些</span>Java<span class="p">对象，</span>JSP<span class="p">容器让这些</span>Java<span class="p">对象可以为开发者所使用。开   发者不用明确的声明就可以直接使用他们。</span>JSP<span class="p">隐含对象也叫做预定义变量。下面列出了</span>JSP<span class="p">页面中的隐含对象：</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 144%;text-align: left;">application page request response session exception out</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 146%;text-align: left;">config pageContext</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">祝：编程快乐！</p>
</body>
<script>
    // 获取指定 div 元素
    const nodeContainer = document.querySelector('#node-list');
    // 获取所有 li 标签
    const liList = document.querySelectorAll('li[data-list-text]');
    // 遍历 liList 中的每个 li 标签
    liList.forEach((li) => {
        const pTag = li.querySelector('p:first-of-type');
        li.setAttribute('id', `li[${li.getAttribute('data-list-text')}]`);
        if (pTag) { // 判断是否存在 p 标签
            const text = pTag.innerText;
            const id = li.getAttribute('data-list-text');
            const aTag = document.createElement('a');
            aTag.href = `#li[${id}]`;
            aTag.innerHTML = `${li.getAttribute('data-list-text')}`+text+"<br><br>";
            // 将 a 标签添加到指定 div 元素中
            nodeContainer.append(aTag);
        }
    });
    var a = document.createElement("a");
    a.href = "整合.htm";
    a.innerHTML = "全部面试题";
    a.target = "_blank";
    nodeContainer.append(a);
</script>
</html>
