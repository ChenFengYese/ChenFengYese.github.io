<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>115个Java面试题和答案</title><meta name="author" content="YCanPDF"><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
.s1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12.5pt; }
.p, p { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12.5pt; margin:0pt; }
.s2 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 18.5pt; }
.s3 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 24pt; }
.s4 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 24pt; }
li {display: block; }
#l1 {padding-left: 0pt;counter-reset: c1 1; }
#l1> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
#l1> li:first-child>*:first-child:before {counter-increment: c1 0;  }
li {display: block; }
#l2 {padding-left: 0pt;counter-reset: d1 10; }
#l2> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
#l2> li:first-child>*:first-child:before {counter-increment: d1 0;  }
li {display: block; }
#l3 {padding-left: 0pt;counter-reset: e1 34; }
#l3> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
#l3> li:first-child>*:first-child:before {counter-increment: e1 0;  }
</style></head><body><p style="text-indent: 0pt;text-align: left;"><br></p>
<div id="node-list" style="padding-left: 3vw;margin-top:1vw;"></div>
<p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 3pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p"></span><span class="p"></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s3" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">题目：<span class="s4">115</span>个<span class="s4">Java</span>面试题和答案<span class="s4">——</span>终极（上）</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">本文我们将要讨论<span class="s1">Java</span>面试中的各种不同类型的面试题，它们可以让雇主测试应聘者的<span class="s1">Java</span>和通用的面向对象编程的能力。下面的章节分为上下两篇，第一篇将要讨论面向对象编程和它的特点，关于<span class="s1">Java</span>和它的功能的常见问题，<span class="s1">Java</span>的集合类，垃圾收集器，第二篇主要讨    论异常处理，<span class="s1">Java</span>小应用程序，<span class="s1">Swing</span>，<span class="s1">JDBC</span>，远程方法调用<span class="s1">(RMI)</span>，<span class="s1">Servlet</span>和<span class="s1">JSP</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">目录</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">面向对象编程（<span class="s1">OOP</span>）常见的<span class="s1">Java</span>问题</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Java<span class="p">线程 </span>Java<span class="p">集合类垃圾收集器</span></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">面向对象编程（<span class="s1">OOP</span>）</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="p">是一个支持并发、基于类和面向对象的计算机编程语言。下面列出了面向对象软件开发的优点：</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">代码开发模块化，更易维护和修改。代码复用。</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">增强代码的可靠性和灵活性。增加代码的可理解性。</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。下面的章节我们会逐个分析这些特性。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">封装</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在<span class="s1">Java</span>当中，有<span class="s1">3</span>种修饰符：<span class="s1">public</span>，<span class="s1">private</span>和<span class="s1">protected</span>。每一种修饰符</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。下面列出了使用封装的一些好处：</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">通过隐藏对象的属性来保护对象内部的状态。</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: left;">提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。禁止对象之间的不良交互提高模块化。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p"></span><span class="p"></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">参考这个文档获取更多关于封装的细节和示例。多态</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">作可以应用到其他类型的值上面。继承</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">抽象</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。<span class="s1">Java</span>支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">抽象和封装的不同点</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">常见的<span class="s1">Java</span>问题</p><p style="text-indent: 0pt;text-align: left;"><br></p><ol id="l1"><li data-list-text="1."><p style="padding-left: 16pt;text-indent: -10pt;text-align: left;">什么是<span class="s1">Java</span>虚拟机？为什么<span class="s1">Java</span>被称作是<span class="s1"></span>平台无关的编程语言<span class="s1">”</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="p">虚拟机是一个可以执行</span>Java<span class="p">字节码的虚拟机进程。</span>Java<span class="p">源文件被编译成能被</span>Java<span class="p">虚拟机执行的字节码文件。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: justify;">Java<span class="p">被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。</span>Java<span class="p">虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="2."><p class="s1" style="padding-left: 16pt;text-indent: -10pt;text-align: left;">JDK<span class="p">和</span>JRE<span class="p">的区别是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="p">运行时环境</span>(JRE)<span class="p">是将要执行</span>Java<span class="p">程序的</span>Java<span class="p">虚拟机。它同时也包含了执行</span>applet<span class="p">需要</span></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">的浏览器插件。<span class="s1">Java</span>开发工具包<span class="s1">(JDK)</span>是完整的<span class="s1">Java</span>软件开发包，包含了<span class="s1">JRE</span>，编译器和其他的工具<span class="s1">(</span>比如：<span class="s1">JavaDoc</span>，<span class="s1">Java</span>调试器<span class="s1">)</span>，可以让开发者开发、编译、执行<span class="s1">Java</span>应用程序。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="3."><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">”static”<span class="p">关键字是什么意思？</span>Java<span class="p">中是否可以覆盖</span>(override)<span class="p">一个</span>private<span class="p">或者是</span>static<span class="p">的方法？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p"></span><span class="p"></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s1" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">static”<span class="p">关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">Java<span class="p">中</span>static<span class="p">方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而</span>static<span class="p">方法是编译时静态绑定的。</span>static<span class="p">方法跟类的任何实例都不相关，所以概念上不适用。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="4."><p style="padding-left: 16pt;text-indent: -10pt;text-align: left;">是否可以在<span class="s1">static</span>环境中访问非<span class="s1">static</span>变量？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">static<span class="p">变量在</span>Java<span class="p">中是属于类的，它在所有的实例中的值是一样的。当类被</span>Java<span class="p">虚拟机载入的时候，会对</span>static<span class="p">变量进行初始化。如果你的代码尝试不用实例来访问非</span>static<span class="p">的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="5."><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Java<span class="p">支持的数据类型有哪些？什么是自动拆装箱？ </span>Java<span class="p">语言支持的</span>8<span class="p">中基本数据类型是：</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 144%;text-align: left;">byte short int long float double</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 146%;text-align: left;">boolean char</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">自动装箱是<span class="s1">Java</span>编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把<span class="s1">int</span>转化成<span class="s1">Integer</span>，<span class="s1">double</span>转化成<span class="s1">double</span>，等等。反之就是自动拆箱。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="6."><p class="s1" style="padding-left: 16pt;text-indent: -10pt;text-align: left;">Java<span class="p">中的方法覆盖</span>(Overriding)<span class="p">和方法重载</span>(Overloading)<span class="p">是什么意思？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="p">中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的</span></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="7."><p class="s1" style="padding-left: 16pt;text-indent: -10pt;text-align: left;">Java<span class="p">中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，<span class="s1">Java</span>编译器会为这个类创建一个默认的构造函数。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 126%;text-align: left;">Java<span class="p">中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="p">不支持像</span>C++<span class="p">中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，</span>Java<span class="p">不会创建默认的复制构造函数。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="8."><p class="s1" style="padding-left: 16pt;text-indent: -10pt;text-align: left;">Java<span class="p">支持多继承么？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p"></span><span class="p"></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 252%;text-align: left;">不支持，<span class="s1">Java</span>不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。 <span class="s1">9.</span>接口和抽象类的区别是什么？</p><p class="s1" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="p">提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 126%;text-align: left;">接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。类可以实现很多个接口，但是只能继承一个抽象类</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">抽象类可以在不提供接口方法实现的情况下实现接口。</p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="p">接口中声明的变量默认都是</span>final<span class="p">的。抽象类可以包含非</span>final<span class="p">的变量。</span></p><p class="s1" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="p">接口中的成员函数默认是</span>public<span class="p">的。抽象类的成员函数可以是</span>private<span class="p">，</span>protected<span class="p">或者是</span>public<span class="p">。</span></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含<span class="s1">main</span>方法的话是可以被调用的。</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">也可以参考<span class="s1">JDK8 </span>中抽象类和接口的区别</p><p style="text-indent: 0pt;text-align: left;"><br></p><ol id="l2"><li data-list-text="10."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是值传递和引用传递？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="p">线程</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="11."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">进程和线程的区别是什么？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="12."><p style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">创建线程有几种不同的方式？你喜欢哪一种？为什么？有三种方式可以用来创建线程：</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">继承<span class="s1">Thread</span>类</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">实现<span class="s1">Runnable</span>接口</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">应用程序可以使用<span class="s1">Executor</span>框架来创建线程池</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">实现<span class="s1">Runnable</span>接口这种方式更受欢迎，因为这不需要继承<span class="s1">Thread</span>类。在应用设计中已经继  承了别的对象的情况下，这需要多继承（而<span class="s1">Java</span>不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p"></span><span class="p"></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="13."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">概括的解释下线程的几种可用状态。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">线程在执行过程中，可以处于下面几种状态：</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">就绪<span class="s1">(Runnable):</span>线程准备运行，不一定立马就能开始执行。运行中<span class="s1">(Running)</span>：进程正在执行线程的代码。</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 126%;text-align: left;">等待中<span class="s1">(Waiting):</span>线程处于阻塞的状态，等待外部的处理结束。睡眠中<span class="s1">(Sleeping)</span>：线程被强制睡眠。</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">I/O<span class="p">阻塞</span>(Blocked on I/O)<span class="p">：等待</span>I/O<span class="p">操作完成。</span></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">同步阻塞<span class="s1">(Blocked on Synchronization)</span>：等待获取锁。死亡<span class="s1">(Dead)</span>：线程完成了执行。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="14."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">同步方法和同步代码块的区别是什么？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">在<span class="s1">Java</span>语言中，每一个对象有一把锁。线程可以使用<span class="s1">synchronized</span>关键字来获取对象上的锁。  <span class="s1">synchronized</span>关键字可应用在方法级别<span class="s1">(</span>粗粒度锁<span class="s1">)</span>或者是代码块级别<span class="s1">(</span>细粒度锁<span class="s1">)</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="15."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">在监视器<span class="s1">(Monitor)</span>内部，是如何做线程同步的？程序应该做哪种级别的同步？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">监视器和锁在<span class="s1">Java</span>虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一  个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="16."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是死锁<span class="s1">(deadlock)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="17."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">如何确保<span class="s1">N</span>个线程可以访问<span class="s1">N</span>个资源同时又不导致死锁？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: justify;">使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="p">集合类</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="18."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="p">集合类框架的基本接口有哪些？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">Java<span class="p">集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。</span>Java<span class="p">集合类里面最基本的接口有：</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: left;">Collection<span class="p">：代表一组对象，每一个对象都是它的子元素。 </span>Set<span class="p">：不包含重复元素的</span>Collection<span class="p">。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p"></span><span class="p"></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s1" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">List<span class="p">：有顺序的</span>collection<span class="p">，并且可以包含重复元素。  </span>Map<span class="p">：可以把键</span>(key)<span class="p">映射到值</span>(value)<span class="p">的对象，键不能重复。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="19."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">为什么集合类没有实现<span class="s1">Cloneable</span>和<span class="s1">Serializable</span>接口？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="20."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是迭代器<span class="s1">(Iterator)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Iterator<span class="p">接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的</span></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">克隆<span class="s1">(cloning) </span>或者是序列化<span class="s1">(serialization)</span>的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="21."><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 252%;text-align: left;">Iterator<span class="p">和</span>ListIterator<span class="p">的区别是什么？下面列出了他们的区别：</span></p><p class="s1" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Iterator<span class="p">可用来遍历</span>Set<span class="p">和</span>List<span class="p">集合，但是</span>ListIterator<span class="p">只能用来遍历</span>List<span class="p">。  </span>Iterator<span class="p">对集合只能是前向遍历，</span>ListIterator<span class="p">既可以前向也可以后向。</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">ListIterator<span class="p">实现了</span>Iterator<span class="p">接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="22."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">快速失败<span class="s1">(fail-fast)</span>和安全失败<span class="s1">(fail-safe)</span>的区别是什么？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Iterator<span class="p">的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</span>java.util<span class="p">包下面的所有的集合类都是快速失败的，而</span>java.util.concurrent<span class="p">包下面的所有的类都是安全失败的。快速失败的迭代器会抛出</span>ConcurrentModificationException<span class="p">异常，而安全失败的迭代器永远不会抛出这样的异常。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="23."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="p">中的</span>HashMap<span class="p">的工作原理是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="p">中的</span>HashMap<span class="p">是以键值对</span>(key-value)<span class="p">的形式存储元素的。</span>HashMap<span class="p">需要一个</span>hash<span class="p">函数，它使用</span>hashCode()<span class="p">和</span>equals()<span class="p">方法来向集合</span>/<span class="p">从集合添加和检索元素。当调用</span>put()<span class="p">方法的时   候，</span>HashMap<span class="p">会计算</span>key<span class="p">的</span>hash<span class="p">值，然后把键值对存储在集合中合适的索引上。如果</span>key</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">已经存在了，<span class="s1">value</span>会被更新成新值。<span class="s1">HashMap</span>的一些重要的特性是它的容量<span class="s1">(capacity)</span>，负载因子<span class="s1">(load factor)</span>和扩容极限<span class="s1">(threshold  resizing)</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="24."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">hashCode()<span class="p">和</span>equals()<span class="p">方法的重要性体现在什么地方？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="p">中的</span>HashMap<span class="p">使用</span>hashCode()<span class="p">和</span>equals()<span class="p">方法来确定键值对的索引，当根据键获取值的</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p"></span><span class="p"></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的  <span class="s1">hash</span>值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所  以这两个方法的实现对<span class="s1">HashMap</span>的精确性和正确性是至关重要的。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="25."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">HashMap<span class="p">和</span>Hashtable<span class="p">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">HashMap<span class="p">和</span>Hashtable<span class="p">都实现了</span>Map<span class="p">接口，因此很多特性非常相似。但是，他们有以下不同点：</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">HashMap<span class="p">允许键和值是</span>null<span class="p">，而</span>Hashtable<span class="p">不允许键或者值是</span>null<span class="p">。</span></p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Hashtable<span class="p">是同步的，而</span>HashMap<span class="p">不是。因此，</span>HashMap<span class="p">更适合于单线程环境，而</span>Hashtable</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">适合于多线程环境。</p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">HashMap<span class="p">提供了可供应用迭代的键的集合，因此，</span>HashMap<span class="p">是快速失败的。另一方面，  </span>Hashtable<span class="p">提供了对键的列举</span>(Enumeration)<span class="p">。</span></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">一般认为<span class="s1">Hashtable</span>是一个遗留的类。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="26."><p style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">数组<span class="s1">(Array)</span>和列表<span class="s1">(ArrayList)</span>有什么区别？什么时候应该使用<span class="s1">Array</span>而不是<span class="s1">ArrayList</span>？下面列出了<span class="s1">Array</span>和<span class="s1">ArrayList</span>的不同点：</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Array<span class="p">可以包含基本类型和对象类型，</span>ArrayList<span class="p">只能包含对象类型。</span></p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Array<span class="p">大小是固定的，</span>ArrayList<span class="p">的大小是动态变化的。</span></p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">ArrayList<span class="p">提供了更多的方法和特性，比如：</span>addAll()<span class="p">，</span>removeAll()<span class="p">，</span>iterator()<span class="p">等等。</span></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: left;">对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="27."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">ArrayList<span class="p">和</span>LinkedList<span class="p">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">ArrayList<span class="p">和</span>LinkedList<span class="p">都实现了</span>List<span class="p">接口，他们有以下的不同点：</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">ArrayList<span class="p">是基于索引的数据接口，它的底层是数组。它可以以</span>O(1)<span class="p">时间复杂度对元素进行随机访问。与此对应，</span>LinkedList<span class="p">是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是</span>O(n)<span class="p">。</span></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">相对于<span class="s1">ArrayList</span>，<span class="s1">LinkedList</span>的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</p><p class="s1" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">LinkedList<span class="p">比</span>ArrayList<span class="p">更占内存，因为</span>LinkedList<span class="p">为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</span></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">也可以参考<span class="s1">ArrayList vs. LinkedList</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="28."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Comparable<span class="p">和</span>Comparator<span class="p">接口是干什么的？列出它们的区别。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="p">提供了只包含一个</span>compareTo()<span class="p">方法的</span>Comparable<span class="p">接口。这个方法可以个给两个对象排序。具体来说，它返回负数，</span>0<span class="p">，正数来表明输入对象小于，等于，大于已经存在的对象。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="p">提供了包含</span>compare()<span class="p">和</span>equals()<span class="p">两个方法的</span>Comparator<span class="p">接口。</span>compare()<span class="p">方法用来给两</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p"></span><span class="p"></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">个输入参数排序，返回负数，<span class="s1">0</span>，正数表明第一个参数是小于，等于，大于第二个参数。<span class="s1">equals()</span>方法需要一个对象作为参数，它用来决定输入参数是否和<span class="s1">comparator</span>相等。只有当输入参</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">数也是一个<span class="s1">comparator</span>并且输入参数和当前<span class="s1">comparator</span>的排序结果是相同的时候，这个方法才返回<span class="s1">true</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="29."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是<span class="s1">Java</span>优先级队列<span class="s1">(Priority Queue)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 126%;text-align: left;">PriorityQueue<span class="p">是一个基于优先级堆的无界队列，它的元素是按照自然顺序</span>(natural  order)<span class="p">排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。</span>PriorityQueue<span class="p">不允许</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">null<span class="p">值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，</span>PriorityQueue</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">不是线程安全的，入队和出队的时间复杂度是<span class="s1">O(log(n))</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="30."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">你了解大<span class="s1">O</span>符号<span class="s1">(big-O notation)</span>么？你能给出不同数据结构的例子么？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">大<span class="s1">O</span>符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: justify;">大<span class="s1">O</span>符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大<span class="s1">O</span>符号基于时间，内存和性能来选择最好的实现。大<span class="s1">O</span>符号可以对大量数据的性能给出一个很好的说明。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="31."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">如何权衡是使用无序的数组还是有序的数组？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">有序数组最大的好处在于查找的时间复杂度是<span class="s1">O(log n)</span>，而无序数组是<span class="s1">O(n)</span>。有序数组的缺</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">点是插入操作的时间复杂度是<span class="s1">O(n)</span>，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量<span class="s1">O(1)</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="32."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="p">集合类框架的最佳实践有哪些？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用<span class="s1">Array</span>而不是<span class="s1">ArrayList</span>。</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算<span class="s1">hash</span>值或者是扩容。</p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的<span class="s1">ClassCastException</span>。</p><p style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">使用<span class="s1">JDK</span>提供的不变类<span class="s1">(immutable class)</span>作为<span class="s1">Map</span>的键可以避免为我们自己的类实现 <span class="s1">hashCode()</span>和<span class="s1">equals()</span>方法。</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">编程的时候接口优于实现。</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: justify;">底层的集合实际上是空的情况下，返回长度是<span class="s1">0</span>的集合或者是数组，不要返回<span class="s1">null</span>。 <span class="s1">33.Enumeration</span>接口和<span class="s1">Iterator</span>接口的区别有哪些？</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: justify;">Enumeration<span class="p">速度是</span>Iterator<span class="p">的</span>2<span class="p">倍，同时占用更少的内存。但是，</span>Iterator<span class="p">远远比</span>Enumeration<span class="p">安全，因为其他线程不能够修改正在被</span>iterator<span class="p">遍历的集合里面的对象。同时，</span>Iterator<span class="p">允许调用者删除底层集合里面的元素，这对</span>Enumeration<span class="p">来说是不可能的。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p"></span><span class="p"></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br></p><ol id="l3"><li data-list-text="34."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">HashSet<span class="p">和</span>TreeSet<span class="p">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">HashSet<span class="p">是由一个</span>hash<span class="p">表来实现的，因此，它的元素是无序的。</span>add()<span class="p">，</span>remove()<span class="p">，</span>contains()</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">方法的时间复杂度是<span class="s1">O(1)</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">另一方面，<span class="s1">TreeSet</span>是由一个树形的结构来实现的，它里面的元素是有序的。因此，<span class="s1">add()</span>，  <span class="s1">remove()</span>，<span class="s1">contains()</span>方法的时间复杂度是<span class="s1">O(logn)</span>。</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">垃圾收集器<span class="s1">(Garbage Collectors)</span></p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="35."><p class="s1" style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="p">中垃圾回收有什么目的？什么时候进行垃圾回收？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="36."><p class="s1" style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">System.gc()<span class="p">和</span>Runtime.gc()<span class="p">会做什么事情？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">这两个方法用来提示<span class="s1">JVM</span>要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于<span class="s1">JVM</span>的。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="37."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">finalize()<span class="p">方法什么时候被调用？析构函数</span>(finalization)<span class="p">的目的是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: left;">在释放对象占用的内存之前，垃圾收集器会调用对象的<span class="s1">finalize()</span>方法。一般建议在该方法中释放对象持有的资源。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="38."><p style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">如果对象的引用被置为<span class="s1">null</span>，垃圾收集器是否会立即释放对象占用的内存？不会，在下一个垃圾回收周期中，这个对象将是可被回收的。</p></li><li data-list-text="39."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;line-height: 15pt;text-align: left;">Java<span class="p">堆的结构是什么样子的？什么是堆中的永久代</span>(Perm Gen space)?</p><p style="text-indent: 0pt;text-align: left;"><br></p><p class="s1" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JVM<span class="p">的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在</span>JVM<span class="p">启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。</span></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="40."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">串行<span class="s1">(serial)</span>收集器和吞吐量<span class="s1">(throughput)</span>收集器的区别是什么？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程  序。而串行收集器对大多数的小应用<span class="s1">(</span>在现代处理器上需要大概<span class="s1">100M</span>左右的内存<span class="s1">)</span>就足够了。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="41."><p style="padding-left: 22pt;text-indent: -16pt;text-align: left;">在<span class="s1">Java</span>中，对象什么时候可以被垃圾回收？</p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="p"></span><span class="p"></span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</p><p style="text-indent: 0pt;text-align: left;"><br></p></li><li data-list-text="42."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">JVM<span class="p">的永久代中会发生垃圾回收么？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 130%;text-align: left;">垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收  <span class="s1">(Full  GC)</span>。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免<span class="s1">Full  GC</span>是非常重要的原因。请参考下<span class="s1">Java8</span>：从永久代到元数据区</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">(<span class="p">译者注：</span>Java8<span class="p">中已经移除了永久代，新加了一个叫做元数据区的</span>native<span class="p">内存区</span>)</p>
</body>
<script>
    // 获取指定 div 元素
    const nodeContainer = document.querySelector('#node-list');
    // 获取所有 li 标签
    const liList = document.querySelectorAll('li[data-list-text]');
    // 遍历 liList 中的每个 li 标签
    liList.forEach((li) => {
        const pTag = li.querySelector('p:first-of-type');
        li.setAttribute('id', `li[${li.getAttribute('data-list-text')}]`);
        if (pTag) { // 判断是否存在 p 标签
            const text = pTag.innerText;
            const id = li.getAttribute('data-list-text');
            const aTag = document.createElement('a');
            aTag.href = `#li[${id}]`;
            aTag.innerHTML = `${li.getAttribute('data-list-text')}`+text+"<br><br>";
            // 将 a 标签添加到指定 div 元素中
            nodeContainer.append(aTag);
        }
    });
    var a = document.createElement("a");
    a.href = "120个Java面试题和答案.htm";
    a.innerHTML = "下一页面试题";
    a.target = "_blank";
    nodeContainer.append(a);
</script>
</html>