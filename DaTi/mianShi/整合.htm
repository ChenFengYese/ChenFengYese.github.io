<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>无标题</title><meta name="author" content="wt"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 .s1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12.5pt; }
 .s2 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12.5pt; }
 .s3 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 18.5pt; }
 .s4 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 24pt; }
 .s5 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 24pt; }
 .s6 { color: #4F4F4F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s7 { color: #4F4F4F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s8 { color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8pt; }
 .s9 { color: #333; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8pt; }
 .s10 { color: #333; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s11 { color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s12 { color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s13 { color: #369; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s14 { color: #4F4F4F; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s15 { color: #4F4F4F; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s16 { color: #6795B5; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s17 { color: #333; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s18 { color: #4F4F4F; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s19 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s20 { color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11.5pt; }
 .s21 { color: #333; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11.5pt; }
 .s22 { color: #333; font-family:宋体; font-style: italic; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 .s23 { color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 .s24 { color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13.5pt; }
 .s25 { color: #333; font-family:宋体; font-style: italic; font-weight: normal; text-decoration: none; font-size: 13.5pt; }
 .s26 { color: #222; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 .s27 { color: #222; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13.5pt; }
 .s28 { color: #222; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s29 { color: #333; font-family:"Lucida Sans", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 22.5pt; }
 h2 { color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 22pt; }
 .s30 { color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 22pt; }
 .s31 { color: #F00; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s32 { color: #333; font-family:"Lucida Sans", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15pt; }
 .s33 { color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14.5pt; }
 .s34 { color: #333; font-family:"Lucida Console", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s35 { color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s36 { color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s37 { color: #008000; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s39 { color: #770087; font-family:"Lucida Console", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s40 { color: #008754; font-family:"Lucida Console", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s41 { color: black; font-family:"Lucida Console", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s42 { color: #971A1A; font-family:"Lucida Console", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s45 { color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14.5pt; }
 .s46 { color: #F00; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 .s47 { color: #F00; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 .s48 { color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s49 { color: #AA5400; font-family:"Lucida Console", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s50 { color: #AA5400; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s51 { color: #A11; font-family:"Lucida Console", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s52 { color: #A11; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s53 { color: #A11; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s54 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s55 { color: #777; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s56 { color: #777; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s57 { color: #777; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s58 { color: #F00; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s60 { color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s61 { color: black; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s62 { color: #F00; font-family:"Lucida Console", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s63 { color: #AA5400; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .h3, h3 { color: #24292E; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 .s64 { color: #24292E; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 15pt; }
 .s65 { color: #24292E; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s66 { color: #24292E; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s67 { color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s68 { color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 .s69 { color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 15pt; }
 .s70 { color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s71 { color: #6A737D; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s72 { color: #6A737D; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s73 { color: #6A737D; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s74 { color: #6A737D; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s75 { color: #24292E; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s76 { color: #D73949; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s77 { color: #6F42C1; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s80 { color: #6A737D; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s82 { color: #0366D6; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s83 { color: #0366D6; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s84 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .p, p { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; margin:0pt; }
 .s85 { color: #7C7C7C; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 .s86 { color: #7C7C7C; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 .s87 { color: #7C7C7C; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s88 { color: #7C7C7C; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s89 { color: #7C7C7C; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 10.5pt; }
 .s90 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 .s91 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 .s92 { color: black; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 .s93 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s94 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s95 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s96 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s97 { color: black; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 .s99 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 .s100 { color: black; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 .s101 { color: #337FE5; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s102 { color: #337FE5; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s103 { color: #00F; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: underline; font-size: 13.5pt; }
 .s104 { color: black; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s105 { color: #00F; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s106 { color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s107 { color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s108 { color: black; font-family:Verdana, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s109 { color: black; font-family:Verdana, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s110 { color: #1B1F21; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s111 { color: #3D464D; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s112 { color: #3D464D; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s113 { color: #3D464D; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s114 { color: #3D464D; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s115 { color: #1B1F21; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12.5pt; }
 .s116 { color: #4078F2; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s117 { color: #A626A4; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s118 { color: #C18401; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s119 { color: #373942; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s120 { color: #373942; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s121 { color: #50A14F; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s122 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s123 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s124 { color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s125 { color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s126 { color: black; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s127 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 9.5pt; }
 .s128 { color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 9.5pt; }
 .s129 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s130 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s131 { color: #00F; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s132 { color: #800000; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s133 { color: #008000; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s135 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s136 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s137 { color: #F00; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s138 { color: black; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 .s139 { color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 .s140 { color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s141 { color: #333; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s142 { color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s144 { color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 21pt; }
 .s145 { color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s146 { color: #FFA900; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13.5pt; }
 .s147 { color: #FFA900; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 .s148 { color: #FFA900; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s149 { color: #555; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s150 { color: #B2B2B2; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s151 { color: #B2B2B2; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s152 { color: #555; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 .s153 { color: #1B1F21; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 .s154 { color: #1B1F21; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s155 { color: #1B1F21; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 16.5pt; }
 .s156 { color: #1B1F21; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 15pt; }
 .s157 { color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 h4 { color: #1B1F21; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 16pt; }
 .s158 { color: #1B1F21; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s159 { color: #1B1F21; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 a { color: #1B1F21; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 12pt; }
 .s161 { color: #3E3E3E; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s162 { color: #3E3E3E; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s163 { color: #3E3E3E; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 .s164 { color: #444; font-family:"Courier New", monospace; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s165 { color: #444; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s166 { color: #800; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s167 { color: #3E3E3E; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 h1 { color: #3E3E3E; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 28.5pt; }
 .s168 { color: #3E3E3E; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 28.5pt; }
 .s169 { color: #444; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s170 { color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 .s171 { color: #4F4F4F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s172 { color: #4F4F4F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s173 { color: #4F4F4F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12.5pt; }
 .s174 { color: #6A737D; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s175 { color: #6A737D; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s176 { color: #24292E; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s177 { color: #24292E; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l1 {padding-left: 0pt;counter-reset: c1 1; }
 #l1> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 #l1> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 10; }
 #l2> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 li {display: block; }
 #l3 {padding-left: 0pt;counter-reset: e1 34; }
 #l3> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 #l3> li:first-child>*:first-child:before {counter-increment: e1 0;  }
 li {display: block; }
 #l4 {padding-left: 0pt;counter-reset: f1 45; }
 #l4> li>*:first-child:before {counter-increment: f1; content: counter(f1, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l4> li:first-child>*:first-child:before {counter-increment: f1 0;  }
 #l5 {padding-left: 0pt;counter-reset: f2 1; }
 #l5> li>*:first-child:before {counter-increment: f2; content: counter(f1, decimal)"."counter(f2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12.5pt; }
 #l5> li:first-child>*:first-child:before {counter-increment: f2 0;  }
 li {display: block; }
 #l6 {padding-left: 0pt;counter-reset: g1 53; }
 #l6> li>*:first-child:before {counter-increment: g1; content: counter(g1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 #l6> li:first-child>*:first-child:before {counter-increment: g1 0;  }
 li {display: block; }
 #l7 {padding-left: 0pt;counter-reset: h1 68; }
 #l7> li>*:first-child:before {counter-increment: h1; content: counter(h1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 #l7> li:first-child>*:first-child:before {counter-increment: h1 0;  }
 li {display: block; }
 #l8 {padding-left: 0pt;counter-reset: i1 79; }
 #l8> li>*:first-child:before {counter-increment: i1; content: counter(i1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 #l8> li:first-child>*:first-child:before {counter-increment: i1 0;  }
 li {display: block; }
 #l9 {padding-left: 0pt;counter-reset: j1 85; }
 #l9> li>*:first-child:before {counter-increment: j1; content: counter(j1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 #l9> li:first-child>*:first-child:before {counter-increment: j1 0;  }
 li {display: block; }
 #l10 {padding-left: 0pt;counter-reset: k1 94; }
 #l10> li>*:first-child:before {counter-increment: k1; content: counter(k1, decimal)". "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 #l10> li:first-child>*:first-child:before {counter-increment: k1 0;  }
 li {display: block; }
 #l11 {padding-left: 0pt;counter-reset: l1 1; }
 #l11> li>*:first-child:before {counter-increment: l1; content: counter(l1, decimal)". "; color: #4F4F4F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8pt; }
 #l11> li:first-child>*:first-child:before {counter-increment: l1 0;  }
 li {display: block; }
 #l12 {padding-left: 0pt;counter-reset: m1 1; }
 #l12> li>*:first-child:before {counter-increment: m1; content: counter(m1, decimal)". "; color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l12> li:first-child>*:first-child:before {counter-increment: m1 0;  }
 li {display: block; }
 #l13 {padding-left: 0pt;counter-reset: n1 1; }
 #l13> li>*:first-child:before {counter-increment: n1; content: counter(n1, decimal)". "; color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l13> li:first-child>*:first-child:before {counter-increment: n1 0;  }
 #l14 {padding-left: 0pt; }
 #l14> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 li {display: block; }
 #l15 {padding-left: 0pt; }
 #l15> li>*:first-child:before {content: " "; color: #222; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l16 {padding-left: 0pt; }
 #l16> li>*:first-child:before {content: " "; color: #222; font-family:Wingdings; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l17 {padding-left: 0pt;counter-reset: p1 1; }
 #l17> li>*:first-child:before {counter-increment: p1; content: counter(p1, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l17> li:first-child>*:first-child:before {counter-increment: p1 0;  }
 #l18 {padding-left: 0pt;counter-reset: p2 7; }
 #l18> li>*:first-child:before {counter-increment: p2; content: counter(p1, decimal)"."counter(p2, decimal)" "; color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14.5pt; }
 #l18> li:first-child>*:first-child:before {counter-increment: p2 0;  }
 #l19 {padding-left: 0pt;counter-reset: p3 1; }
 #l19> li>*:first-child:before {counter-increment: p3; content: counter(p3, decimal)". "; color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 #l19> li:first-child>*:first-child:before {counter-increment: p3 0;  }
 #l20 {padding-left: 0pt;counter-reset: p4 1; }
 #l20> li>*:first-child:before {counter-increment: p4; content: "("counter(p4, lower-latin)") "; color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 #l20> li:first-child>*:first-child:before {counter-increment: p4 0;  }
 li {display: block; }
 #l21 {padding-left: 0pt;counter-reset: q1 0; }
 #l21> li>*:first-child:before {counter-increment: q1; content: "（"counter(q1, decimal)"） "; color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 #l21> li:first-child>*:first-child:before {counter-increment: q1 0;  }
 li {display: block; }
 #l22 {padding-left: 0pt;counter-reset: r1 1; }
 #l22> li>*:first-child:before {counter-increment: r1; content: "("counter(r1, decimal)") "; color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l22> li:first-child>*:first-child:before {counter-increment: r1 0;  }
 #l23 {padding-left: 0pt;counter-reset: r2 1; }
 #l23> li>*:first-child:before {counter-increment: r2; content: counter(r2, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 17pt; }
 #l23> li:first-child>*:first-child:before {counter-increment: r2 0;  }
 #l24 {padding-left: 0pt;counter-reset: r3 1; }
 #l24> li>*:first-child:before {counter-increment: r3; content: counter(r3, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l24> li:first-child>*:first-child:before {counter-increment: r3 0;  }
 #l25 {padding-left: 0pt;counter-reset: r3 1; }
 #l25> li>*:first-child:before {counter-increment: r3; content: counter(r3, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l25> li:first-child>*:first-child:before {counter-increment: r3 0;  }
 #l26 {padding-left: 0pt; }
 #l26> li>*:first-child:before {content: " "; color: #24292E; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l27 {padding-left: 0pt;counter-reset: r3 1; }
 #l27> li>*:first-child:before {counter-increment: r3; content: counter(r3, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l27> li:first-child>*:first-child:before {counter-increment: r3 0;  }
 #l28 {padding-left: 0pt;counter-reset: r3 1; }
 #l28> li>*:first-child:before {counter-increment: r3; content: counter(r3, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l28> li:first-child>*:first-child:before {counter-increment: r3 0;  }
 #l29 {padding-left: 0pt;counter-reset: r3 1; }
 #l29> li>*:first-child:before {counter-increment: r3; content: counter(r3, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l29> li:first-child>*:first-child:before {counter-increment: r3 0;  }
 li {display: block; }
 #l30 {padding-left: 0pt;counter-reset: t1 13; }
 #l30> li>*:first-child:before {counter-increment: t1; content: counter(t1, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l30> li:first-child>*:first-child:before {counter-increment: t1 0;  }
 li {display: block; }
 #l31 {padding-left: 0pt;counter-reset: u1 1; }
 #l31> li>*:first-child:before {counter-increment: u1; content: counter(u1, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l31> li:first-child>*:first-child:before {counter-increment: u1 0;  }
 li {display: block; }
 #l32 {padding-left: 0pt;counter-reset: v1 18; }
 #l32> li>*:first-child:before {counter-increment: v1; content: counter(v1, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l32> li:first-child>*:first-child:before {counter-increment: v1 0;  }
 #l33 {padding-left: 0pt;counter-reset: w1 1; }
 #l33> li>*:first-child:before {counter-increment: w1; content: counter(w1, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l33> li:first-child>*:first-child:before {counter-increment: w1 0;  }
 li {display: block; }
 #l34 {padding-left: 0pt;counter-reset: x1 1; }
 #l34> li>*:first-child:before {counter-increment: x1; content: counter(x1, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l34> li:first-child>*:first-child:before {counter-increment: x1 0;  }
 li {display: block; }
 #l35 {padding-left: 0pt;counter-reset: y1 1; }
 #l35> li>*:first-child:before {counter-increment: y1; content: counter(y1, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l35> li:first-child>*:first-child:before {counter-increment: y1 0;  }
 li {display: block; }
 #l36 {padding-left: 0pt;counter-reset: z1 24; }
 #l36> li>*:first-child:before {counter-increment: z1; content: counter(z1, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l36> li:first-child>*:first-child:before {counter-increment: z1 0;  }
 #l37 {padding-left: 0pt; }
 #l37> li>*:first-child:before {content: " "; color: #24292E; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l38 {padding-left: 0pt;counter-reset: c1 27; }
 #l38> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l38> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l39 {padding-left: 0pt;counter-reset: c2 1; }
 #l39> li>*:first-child:before {counter-increment: c2; content: counter(c2, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l39> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 li {display: block; }
 #l40 {padding-left: 0pt;counter-reset: d1 28; }
 #l40> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l40> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 li {display: block; }
 #l41 {padding-left: 0pt;counter-reset: e1 31; }
 #l41> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)" "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 18pt; }
 #l41> li:first-child>*:first-child:before {counter-increment: e1 0;  }
 #l42 {padding-left: 0pt;counter-reset: e2 1; }
 #l42> li>*:first-child:before {counter-increment: e2; content: counter(e2, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l42> li:first-child>*:first-child:before {counter-increment: e2 0;  }
 #l43 {padding-left: 0pt; }
 #l43> li>*:first-child:before {content: " "; color: #24292E; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l44 {padding-left: 0pt;counter-reset: e2 1; }
 #l44> li>*:first-child:before {counter-increment: e2; content: counter(e2, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l44> li:first-child>*:first-child:before {counter-increment: e2 0;  }
 li {display: block; }
 #l45 {padding-left: 0pt;counter-reset: g1 1; }
 #l45> li>*:first-child:before {counter-increment: g1; content: counter(g1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l45> li:first-child>*:first-child:before {counter-increment: g1 0;  }
 #l46 {padding-left: 0pt;counter-reset: h1 1; }
 #l46> li>*:first-child:before {counter-increment: h1; content: "（"counter(h1, decimal)"） "; color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l46> li:first-child>*:first-child:before {counter-increment: h1 0;  }
 #l47 {padding-left: 0pt;counter-reset: i1 1; }
 #l47> li>*:first-child:before {counter-increment: i1; content: "（"counter(i1, decimal)"） "; color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l47> li:first-child>*:first-child:before {counter-increment: i1 0;  }
 li {display: block; }
 #l48 {padding-left: 0pt;counter-reset: j1 7; }
 #l48> li>*:first-child:before {counter-increment: j1; content: counter(j1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l48> li:first-child>*:first-child:before {counter-increment: j1 0;  }
 #l49 {padding-left: 0pt;counter-reset: k1 2; }
 #l49> li>*:first-child:before {counter-increment: k1; content: "("counter(k1, decimal)"). "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l49> li:first-child>*:first-child:before {counter-increment: k1 0;  }
 li {display: block; }
 #l50 {padding-left: 0pt; }
 #l50> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l51 {padding-left: 0pt;counter-reset: m1 2; }
 #l51> li>*:first-child:before {counter-increment: m1; content: counter(m1, decimal)") "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l51> li:first-child>*:first-child:before {counter-increment: m1 0;  }
 #l52 {padding-left: 0pt;counter-reset: n1 1; }
 #l52> li>*:first-child:before {counter-increment: n1; content: "("counter(n1, decimal)") "; color: #7C7C7C; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 #l52> li:first-child>*:first-child:before {counter-increment: n1 0;  }
 #l53 {padding-left: 0pt;counter-reset: o1 1; }
 #l53> li>*:first-child:before {counter-increment: o1; content: "("counter(o1, decimal)") "; color: #7C7C7C; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l53> li:first-child>*:first-child:before {counter-increment: o1 0;  }
 #l54 {padding-left: 0pt;counter-reset: p1 2; }
 #l54> li>*:first-child:before {counter-increment: p1; content: counter(p1, decimal)". "; color: #7C7C7C; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l54> li:first-child>*:first-child:before {counter-increment: p1 0;  }
 #l55 {padding-left: 0pt;counter-reset: q1 1; }
 #l55> li>*:first-child:before {counter-increment: q1; content: counter(q1, decimal)". "; color: #7C7C7C; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l55> li:first-child>*:first-child:before {counter-increment: q1 0;  }
 #l56 {padding-left: 0pt; }
 #l56> li>*:first-child:before {content: "* "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 #l57 {padding-left: 0pt; }
 #l57> li>*:first-child:before {content: "* "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 #l58 {padding-left: 0pt;counter-reset: t1 1; }
 #l58> li>*:first-child:before {counter-increment: t1; content: counter(t1, decimal)". "; color: #4F4F4F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l58> li:first-child>*:first-child:before {counter-increment: t1 0;  }
 #l59 {padding-left: 0pt; }
 #l59> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l60 {padding-left: 0pt;counter-reset: u1 7; }
 #l60> li>*:first-child:before {counter-increment: u1; content: counter(u1, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l60> li:first-child>*:first-child:before {counter-increment: u1 0;  }
 #l61 {padding-left: 0pt;counter-reset: v1 1; }
 #l61> li>*:first-child:before {counter-increment: v1; content: counter(v1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l61> li:first-child>*:first-child:before {counter-increment: v1 0;  }
 #l62 {padding-left: 0pt;counter-reset: w1 1; }
 #l62> li>*:first-child:before {counter-increment: w1; content: counter(w1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l62> li:first-child>*:first-child:before {counter-increment: w1 0;  }
 #l63 {padding-left: 0pt;counter-reset: x1 1; }
 #l63> li>*:first-child:before {counter-increment: x1; content: counter(x1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l63> li:first-child>*:first-child:before {counter-increment: x1 0;  }
 #l64 {padding-left: 0pt;counter-reset: y1 1; }
 #l64> li>*:first-child:before {counter-increment: y1; content: counter(y1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l64> li:first-child>*:first-child:before {counter-increment: y1 0;  }
 #l65 {padding-left: 0pt;counter-reset: z1 1; }
 #l65> li>*:first-child:before {counter-increment: z1; content: counter(z1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l65> li:first-child>*:first-child:before {counter-increment: z1 0;  }
 #l66 {padding-left: 0pt;counter-reset: c1 1; }
 #l66> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l66> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l67 {padding-left: 0pt;counter-reset: d1 1; }
 #l67> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l67> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l68 {padding-left: 0pt;counter-reset: e1 1; }
 #l68> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l68> li:first-child>*:first-child:before {counter-increment: e1 0;  }
 #l69 {padding-left: 0pt;counter-reset: f1 1; }
 #l69> li>*:first-child:before {counter-increment: f1; content: counter(f1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l69> li:first-child>*:first-child:before {counter-increment: f1 0;  }
 #l70 {padding-left: 0pt;counter-reset: g1 1; }
 #l70> li>*:first-child:before {counter-increment: g1; content: counter(g1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l70> li:first-child>*:first-child:before {counter-increment: g1 0;  }
 #l71 {padding-left: 0pt;counter-reset: h1 1; }
 #l71> li>*:first-child:before {counter-increment: h1; content: counter(h1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l71> li:first-child>*:first-child:before {counter-increment: h1 0;  }
 #l72 {padding-left: 0pt;counter-reset: i1 1; }
 #l72> li>*:first-child:before {counter-increment: i1; content: counter(i1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l72> li:first-child>*:first-child:before {counter-increment: i1 0;  }
 #l73 {padding-left: 0pt;counter-reset: j1 1; }
 #l73> li>*:first-child:before {counter-increment: j1; content: counter(j1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l73> li:first-child>*:first-child:before {counter-increment: j1 0;  }
 #l74 {padding-left: 0pt;counter-reset: k1 33; }
 #l74> li>*:first-child:before {counter-increment: k1; content: counter(k1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l74> li:first-child>*:first-child:before {counter-increment: k1 0;  }
 #l75 {padding-left: 0pt;counter-reset: k2 1; }
 #l75> li>*:first-child:before {counter-increment: k2; content: counter(k2, decimal)". "; color: black; font-family:"Microsoft JhengHei", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l75> li:first-child>*:first-child:before {counter-increment: k2 0;  }
 #l76 {padding-left: 0pt;counter-reset: l1 1; }
 #l76> li>*:first-child:before {counter-increment: l1; content: counter(l1, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 #l76> li:first-child>*:first-child:before {counter-increment: l1 0;  }
 #l77 {padding-left: 0pt;counter-reset: l2 1; }
 #l77> li>*:first-child:before {counter-increment: l2; content: counter(l2, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l77> li:first-child>*:first-child:before {counter-increment: l2 0;  }
 #l78 {padding-left: 0pt;counter-reset: l2 1; }
 #l78> li>*:first-child:before {counter-increment: l2; content: counter(l2, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l78> li:first-child>*:first-child:before {counter-increment: l2 0;  }
 #l79 {padding-left: 0pt;counter-reset: l2 1; }
 #l79> li>*:first-child:before {counter-increment: l2; content: counter(l2, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l79> li:first-child>*:first-child:before {counter-increment: l2 0;  }
 #l80 {padding-left: 0pt;counter-reset: l2 1; }
 #l80> li>*:first-child:before {counter-increment: l2; content: counter(l2, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l80> li:first-child>*:first-child:before {counter-increment: l2 0;  }
 #l81 {padding-left: 0pt;counter-reset: l2 1; }
 #l81> li>*:first-child:before {counter-increment: l2; content: counter(l2, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l81> li:first-child>*:first-child:before {counter-increment: l2 0;  }
 #l82 {padding-left: 0pt;counter-reset: l2 1; }
 #l82> li>*:first-child:before {counter-increment: l2; content: counter(l2, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l82> li:first-child>*:first-child:before {counter-increment: l2 0;  }
 #l83 {padding-left: 0pt;counter-reset: l3 1; }
 #l83> li>*:first-child:before {counter-increment: l3; content: counter(l3, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l83> li:first-child>*:first-child:before {counter-increment: l3 0;  }
 #l84 {padding-left: 0pt;counter-reset: l3 1; }
 #l84> li>*:first-child:before {counter-increment: l3; content: counter(l3, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l84> li:first-child>*:first-child:before {counter-increment: l3 0;  }
 #l85 {padding-left: 0pt;counter-reset: l3 1; }
 #l85> li>*:first-child:before {counter-increment: l3; content: counter(l3, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l85> li:first-child>*:first-child:before {counter-increment: l3 0;  }
 #l86 {padding-left: 0pt;counter-reset: l3 1; }
 #l86> li>*:first-child:before {counter-increment: l3; content: counter(l3, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l86> li:first-child>*:first-child:before {counter-increment: l3 0;  }
 #l87 {padding-left: 0pt;counter-reset: l3 1; }
 #l87> li>*:first-child:before {counter-increment: l3; content: counter(l3, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l87> li:first-child>*:first-child:before {counter-increment: l3 0;  }
 #l88 {padding-left: 0pt;counter-reset: m1 1; }
 #l88> li>*:first-child:before {counter-increment: m1; content: counter(m1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l88> li:first-child>*:first-child:before {counter-increment: m1 0;  }
 #l89 {padding-left: 0pt;counter-reset: n1 1; }
 #l89> li>*:first-child:before {counter-increment: n1; content: counter(n1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l89> li:first-child>*:first-child:before {counter-increment: n1 0;  }
 #l90 {padding-left: 0pt; }
 #l90> li>*:first-child:before {content: "● "; color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 #l91 {padding-left: 0pt;counter-reset: p1 1; }
 #l91> li>*:first-child:before {counter-increment: p1; content: counter(p1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l91> li:first-child>*:first-child:before {counter-increment: p1 0;  }
 #l92 {padding-left: 0pt;counter-reset: q1 1; }
 #l92> li>*:first-child:before {counter-increment: q1; content: counter(q1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l92> li:first-child>*:first-child:before {counter-increment: q1 0;  }
 #l93 {padding-left: 0pt;counter-reset: q2 1; }
 #l93> li>*:first-child:before {counter-increment: q2; content: counter(q2, lower-latin)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l93> li:first-child>*:first-child:before {counter-increment: q2 0;  }
 #l94 {padding-left: 0pt;counter-reset: r1 1; }
 #l94> li>*:first-child:before {counter-increment: r1; content: counter(r1, decimal)". "; color: #1B1F21; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l94> li:first-child>*:first-child:before {counter-increment: r1 0;  }
 #l95 {padding-left: 0pt;counter-reset: s1 1; }
 #l95> li>*:first-child:before {counter-increment: s1; content: counter(s1, decimal)". "; color: #1B1F21; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l95> li:first-child>*:first-child:before {counter-increment: s1 0;  }
 #l96 {padding-left: 0pt;counter-reset: t1 1; }
 #l96> li>*:first-child:before {counter-increment: t1; content: counter(t1, decimal)". "; color: #1B1F21; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l96> li:first-child>*:first-child:before {counter-increment: t1 0;  }
 #l97 {padding-left: 0pt;counter-reset: u1 1; }
 #l97> li>*:first-child:before {counter-increment: u1; content: "（"counter(u1, decimal)"） "; color: #1B1F21; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l97> li:first-child>*:first-child:before {counter-increment: u1 0;  }
 #l98 {padding-left: 0pt;counter-reset: v1 28; }
 #l98> li>*:first-child:before {counter-increment: v1; content: counter(v1, decimal)". "; color: #3D464D; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 #l98> li:first-child>*:first-child:before {counter-increment: v1 0;  }
 #l99 {padding-left: 0pt;counter-reset: w1 1; }
 #l99> li>*:first-child:before {counter-increment: w1; content: counter(w1, decimal)". "; color: #373942; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l99> li:first-child>*:first-child:before {counter-increment: w1 0;  }
 #l100 {padding-left: 0pt;counter-reset: x1 4; }
 #l100> li>*:first-child:before {counter-increment: x1; content: counter(x1, decimal)". "; color: #373942; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l100> li:first-child>*:first-child:before {counter-increment: x1 0;  }
 #l101 {padding-left: 0pt;counter-reset: y1 17; }
 #l101> li>*:first-child:before {counter-increment: y1; content: counter(y1, decimal)". "; color: #373942; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l101> li:first-child>*:first-child:before {counter-increment: y1 0;  }
 #l102 {padding-left: 0pt;counter-reset: z1 26; }
 #l102> li>*:first-child:before {counter-increment: z1; content: counter(z1, decimal)". "; color: #373942; font-family:Consolas, monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l102> li:first-child>*:first-child:before {counter-increment: z1 0;  }
 #l103 {padding-left: 0pt;counter-reset: z2 1; }
 #l103> li>*:first-child:before {counter-increment: z2; content: counter(z2, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l103> li:first-child>*:first-child:before {counter-increment: z2 0;  }
 #l104 {padding-left: 0pt;counter-reset: c1 1; }
 #l104> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l104> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l105 {padding-left: 0pt;counter-reset: d1 3; }
 #l105> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l105> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l106 {padding-left: 0pt;counter-reset: e1 10; }
 #l106> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l106> li:first-child>*:first-child:before {counter-increment: e1 0;  }
 #l107 {padding-left: 0pt;counter-reset: f1 1; }
 #l107> li>*:first-child:before {counter-increment: f1; content: counter(f1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l107> li:first-child>*:first-child:before {counter-increment: f1 0;  }
 #l108 {padding-left: 0pt; }
 #l108> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l109 {padding-left: 0pt;counter-reset: h1 1; }
 #l109> li>*:first-child:before {counter-increment: h1; content: counter(h1, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l109> li:first-child>*:first-child:before {counter-increment: h1 0;  }
 #l110 {padding-left: 0pt;counter-reset: i1 1; }
 #l110> li>*:first-child:before {counter-increment: i1; content: counter(i1, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l110> li:first-child>*:first-child:before {counter-increment: i1 0;  }
 #l111 {padding-left: 0pt;counter-reset: j1 1; }
 #l111> li>*:first-child:before {counter-increment: j1; content: counter(j1, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l111> li:first-child>*:first-child:before {counter-increment: j1 0;  }
 #l112 {padding-left: 0pt;counter-reset: k1 1; }
 #l112> li>*:first-child:before {counter-increment: k1; content: counter(k1, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l112> li:first-child>*:first-child:before {counter-increment: k1 0;  }
 #l113 {padding-left: 0pt;counter-reset: l1 1; }
 #l113> li>*:first-child:before {counter-increment: l1; content: counter(l1, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l113> li:first-child>*:first-child:before {counter-increment: l1 0;  }
 #l114 {padding-left: 0pt; }
 #l114> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l115 {padding-left: 0pt;counter-reset: m1 1; }
 #l115> li>*:first-child:before {counter-increment: m1; content: counter(m1, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l115> li:first-child>*:first-child:before {counter-increment: m1 0;  }
 #l116 {padding-left: 0pt; }
 #l116> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l117 {padding-left: 0pt;counter-reset: o1 1; }
 #l117> li>*:first-child:before {counter-increment: o1; content: counter(o1, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l117> li:first-child>*:first-child:before {counter-increment: o1 0;  }
 #l118 {padding-left: 0pt;counter-reset: p1 1; }
 #l118> li>*:first-child:before {counter-increment: p1; content: counter(p1, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l118> li:first-child>*:first-child:before {counter-increment: p1 0;  }
 #l119 {padding-left: 0pt;counter-reset: q1 1; }
 #l119> li>*:first-child:before {counter-increment: q1; content: counter(q1, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l119> li:first-child>*:first-child:before {counter-increment: q1 0;  }
 #l120 {padding-left: 0pt; }
 #l120> li>*:first-child:before {content: "o "; color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l121 {padding-left: 0pt;counter-reset: q2 1; }
 #l121> li>*:first-child:before {counter-increment: q2; content: counter(q2, decimal)". "; color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 #l121> li:first-child>*:first-child:before {counter-increment: q2 0;  }
 #l122 {padding-left: 0pt;counter-reset: s1 1; }
 #l122> li>*:first-child:before {counter-increment: s1; content: counter(s1, decimal)"） "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l122> li:first-child>*:first-child:before {counter-increment: s1 0;  }
 #l123 {padding-left: 0pt;counter-reset: t1 5; }
 #l123> li>*:first-child:before {counter-increment: t1; content: counter(t1, decimal)". "; color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 #l123> li:first-child>*:first-child:before {counter-increment: t1 0;  }
 #l124 {padding-left: 0pt;counter-reset: u1 1; }
 #l124> li>*:first-child:before {counter-increment: u1; content: counter(u1, decimal)") "; color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l124> li:first-child>*:first-child:before {counter-increment: u1 0;  }
 #l125 {padding-left: 0pt;counter-reset: v1 1; }
 #l125> li>*:first-child:before {counter-increment: v1; content: counter(v1, decimal)"). "; color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l125> li:first-child>*:first-child:before {counter-increment: v1 0;  }
 #l126 {padding-left: 0pt;counter-reset: w1 8; }
 #l126> li>*:first-child:before {counter-increment: w1; content: counter(w1, decimal)". "; color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 #l126> li:first-child>*:first-child:before {counter-increment: w1 0;  }
 #l127 {padding-left: 0pt;counter-reset: x1 1; }
 #l127> li>*:first-child:before {counter-increment: x1; content: counter(x1, decimal)") "; color: #333; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l127> li:first-child>*:first-child:before {counter-increment: x1 0;  }
 #l128 {padding-left: 0pt;counter-reset: y1 1; }
 #l128> li>*:first-child:before {counter-increment: y1; content: counter(y1, decimal)". "; color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 20pt; }
 #l128> li:first-child>*:first-child:before {counter-increment: y1 0;  }
 #l129 {padding-left: 0pt;counter-reset: z1 1; }
 #l129> li>*:first-child:before {counter-increment: z1; content: "（"counter(z1, decimal)"） "; color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 #l129> li:first-child>*:first-child:before {counter-increment: z1 0;  }
 #l130 {padding-left: 0pt;counter-reset: c1 1; }
 #l130> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l130> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l131 {padding-left: 0pt;counter-reset: d1 7; }
 #l131> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 #l131> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l132 {padding-left: 0pt;counter-reset: e1 14; }
 #l132> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 #l132> li:first-child>*:first-child:before {counter-increment: e1 0;  }
 #l133 {padding-left: 0pt;counter-reset: f1 1; }
 #l133> li>*:first-child:before {counter-increment: f1; content: counter(f1, decimal)". "; color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 #l133> li:first-child>*:first-child:before {counter-increment: f1 0;  }
 #l134 {padding-left: 0pt; }
 #l134> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 li {display: block; }
 #l135 {padding-left: 0pt;counter-reset: f1 1; }
 #l135> li>*:first-child:before {counter-increment: f1; content: counter(f1, decimal)". "; color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 #l135> li:first-child>*:first-child:before {counter-increment: f1 0;  }
 #l136 {padding-left: 0pt;counter-reset: f2 1; }
 #l136> li>*:first-child:before {counter-increment: f2; content: counter(f2, decimal)". "; color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 #l136> li:first-child>*:first-child:before {counter-increment: f2 0;  }
 li {display: block; }
 #l137 {padding-left: 0pt;counter-reset: g1 1; }
 #l137> li>*:first-child:before {counter-increment: g1; content: counter(g1, decimal)". "; color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 #l137> li:first-child>*:first-child:before {counter-increment: g1 0;  }
 #l138 {padding-left: 0pt; }
 #l138> li>*:first-child:before {content: "o "; color: #333; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l139 {padding-left: 0pt; }
 #l139> li>*:first-child:before {content: " "; color: #333; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l140 {padding-left: 0pt;counter-reset: g2 1; }
 #l140> li>*:first-child:before {counter-increment: g2; content: counter(g2, decimal)". "; color: #555; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 #l140> li:first-child>*:first-child:before {counter-increment: g2 0;  }
 #l141 {padding-left: 0pt;counter-reset: g2 2; }
 #l141> li>*:first-child:before {counter-increment: g2; content: counter(g2, decimal)". "; color: #555; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 #l141> li:first-child>*:first-child:before {counter-increment: g2 0;  }
 #l142 {padding-left: 0pt;counter-reset: g2 3; }
 #l142> li>*:first-child:before {counter-increment: g2; content: counter(g2, decimal)". "; color: #555; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 #l142> li:first-child>*:first-child:before {counter-increment: g2 0;  }
 #l143 {padding-left: 0pt;counter-reset: g2 4; }
 #l143> li>*:first-child:before {counter-increment: g2; content: counter(g2, decimal)". "; color: #555; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10.5pt; }
 #l143> li:first-child>*:first-child:before {counter-increment: g2 0;  }
 li {display: block; }
 #l144 {padding-left: 0pt; }
 #l144> li>*:first-child:before {content: " "; color: #333; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l145 {padding-left: 0pt;counter-reset: j1 1; }
 #l145> li>*:first-child:before {counter-increment: j1; content: counter(j1, decimal)". "; color: #555; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 #l145> li:first-child>*:first-child:before {counter-increment: j1 0;  }
 #l146 {padding-left: 0pt;counter-reset: k1 1; }
 #l146> li>*:first-child:before {counter-increment: k1; content: counter(k1, decimal)". "; color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 #l146> li:first-child>*:first-child:before {counter-increment: k1 0;  }
 #l147 {padding-left: 0pt;counter-reset: k1 1; }
 #l147> li>*:first-child:before {counter-increment: k1; content: counter(k1, decimal)". "; color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 #l147> li:first-child>*:first-child:before {counter-increment: k1 0;  }
 #l148 {padding-left: 0pt;counter-reset: k2 1; }
 #l148> li>*:first-child:before {counter-increment: k2; content: counter(k2, decimal)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l148> li:first-child>*:first-child:before {counter-increment: k2 0;  }
 #l149 {padding-left: 0pt;counter-reset: l1 4; }
 #l149> li>*:first-child:before {counter-increment: l1; content: counter(l1, decimal)"） "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 #l149> li:first-child>*:first-child:before {counter-increment: l1 0;  }
 #l150 {padding-left: 0pt;counter-reset: m1 7; }
 #l150> li>*:first-child:before {counter-increment: m1; content: counter(m1, decimal)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 #l150> li:first-child>*:first-child:before {counter-increment: m1 0;  }
 #l151 {padding-left: 0pt;counter-reset: n1 14; }
 #l151> li>*:first-child:before {counter-increment: n1; content: counter(n1, decimal)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 #l151> li:first-child>*:first-child:before {counter-increment: n1 0;  }
 #l152 {padding-left: 0pt; }
 #l152> li>*:first-child:before {content: "> "; color: #1B1F21; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 #l153 {padding-left: 0pt; }
 #l153> li>*:first-child:before {content: "> "; color: #1B1F21; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 li {display: block; }
 #l154 {padding-left: 0pt; }
 #l154> li>*:first-child:before {content: "> "; color: #1B1F21; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 li {display: block; }
 #l155 {padding-left: 0pt; }
 #l155> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l156 {padding-left: 0pt; }
 #l156> li>*:first-child:before {content: " "; color: #3E3E3E; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l157 {padding-left: 0pt; }
 #l157> li>*:first-child:before {content: "o "; color: #3E3E3E; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l158 {padding-left: 0pt; }
 #l158> li>*:first-child:before {content: "o "; color: #3E3E3E; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l159 {padding-left: 0pt; }
 #l159> li>*:first-child:before {content: "o "; color: #3E3E3E; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l160 {padding-left: 0pt; }
 #l160> li>*:first-child:before {content: "o "; color: #3E3E3E; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l161 {padding-left: 0pt; }
 #l161> li>*:first-child:before {content: "o "; color: #3E3E3E; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l162 {padding-left: 0pt; }
 #l162> li>*:first-child:before {content: "o "; color: #3E3E3E; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l163 {padding-left: 0pt;counter-reset: r1 1; }
 #l163> li>*:first-child:before {counter-increment: r1; content: counter(r1, decimal)". "; color: #3E3E3E; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l163> li:first-child>*:first-child:before {counter-increment: r1 0;  }
 #l164 {padding-left: 0pt;counter-reset: r2 1; }
 #l164> li>*:first-child:before {counter-increment: r2; content: counter(r2, decimal)". "; color: #3E3E3E; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l164> li:first-child>*:first-child:before {counter-increment: r2 0;  }
 li {display: block; }
 #l165 {padding-left: 0pt;counter-reset: s1 1; }
 #l165> li>*:first-child:before {counter-increment: s1; content: counter(s1, decimal)". "; color: #3E3E3E; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l165> li:first-child>*:first-child:before {counter-increment: s1 0;  }
 li {display: block; }
 #l166 {padding-left: 0pt;counter-reset: t1 1; }
 #l166> li>*:first-child:before {counter-increment: t1; content: counter(t1, decimal)". "; color: #3E3E3E; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l166> li:first-child>*:first-child:before {counter-increment: t1 0;  }
 li {display: block; }
 #l167 {padding-left: 0pt;counter-reset: u1 1; }
 #l167> li>*:first-child:before {counter-increment: u1; content: counter(u1, decimal)". "; color: #3E3E3E; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l167> li:first-child>*:first-child:before {counter-increment: u1 0;  }
 li {display: block; }
 #l168 {padding-left: 0pt;counter-reset: v1 1; }
 #l168> li>*:first-child:before {counter-increment: v1; content: counter(v1, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l168> li:first-child>*:first-child:before {counter-increment: v1 0;  }
 #l169 {padding-left: 0pt;counter-reset: v2 1; }
 #l169> li>*:first-child:before {counter-increment: v2; content: counter(v2, decimal)". "; color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 #l169> li:first-child>*:first-child:before {counter-increment: v2 0;  }
 li {display: block; }
 #l170 {padding-left: 0pt;counter-reset: w1 1; }
 #l170> li>*:first-child:before {counter-increment: w1; content: counter(w1, decimal)". "; color: #333; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 #l170> li:first-child>*:first-child:before {counter-increment: w1 0;  }
 #l171 {padding-left: 0pt;counter-reset: w2 3; }
 #l171> li>*:first-child:before {counter-increment: w2; content: counter(w2, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l171> li:first-child>*:first-child:before {counter-increment: w2 0;  }
 li {display: block; }
 #l172 {padding-left: 0pt;counter-reset: x1 1; }
 #l172> li>*:first-child:before {counter-increment: x1; content: counter(x1, decimal)". "; color: #4F4F4F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l172> li:first-child>*:first-child:before {counter-increment: x1 0;  }
 li {display: block; }
 #l173 {padding-left: 0pt;counter-reset: y1 7; }
 #l173> li>*:first-child:before {counter-increment: y1; content: counter(y1, decimal)". "; color: #4F4F4F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 11pt; }
 #l173> li:first-child>*:first-child:before {counter-increment: y1 0;  }
 li {display: block; }
 #l174 {padding-left: 0pt;counter-reset: z1 1; }
 #l174> li>*:first-child:before {counter-increment: z1; content: counter(z1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 #l174> li:first-child>*:first-child:before {counter-increment: z1 0;  }
 li {display: block; }
 #l175 {padding-left: 0pt;counter-reset: c1 1; }
 #l175> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l175> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l176 {padding-left: 0pt;counter-reset: c2 1; }
 #l176> li>*:first-child:before {counter-increment: c2; content: counter(c2, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l176> li:first-child>*:first-child:before {counter-increment: c2 0;  }
 li {display: block; }
 #l177 {padding-left: 0pt; }
 #l177> li>*:first-child:before {content: " "; color: #24292E; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 li {display: block; }
 #l178 {padding-left: 0pt;counter-reset: e1 1; }
 #l178> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)" "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 #l178> li:first-child>*:first-child:before {counter-increment: e1 0;  }
 #l179 {padding-left: 0pt;counter-reset: e2 1; }
 #l179> li>*:first-child:before {counter-increment: e2; content: counter(e2, decimal)". "; color: #24292E; font-family:"Segoe UI", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l179> li:first-child>*:first-child:before {counter-increment: e2 0;  }
 table, tbody {vertical-align: top; overflow: visible; }
 *{font-size: 15pt!important;}
</style></head><body><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 3pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s4" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">题目：<span class="s5">115</span>个<span class="s5">Java</span>面试题和答案<span class="s5">——</span>终极（上）</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">本文我们将要讨论<span class="s1">Java</span>面试中的各种不同类型的面试题，它们可以让雇主测试应聘者的<span class="s1">Java</span>和通用的面向对象编程的能力。下面的章节分为上下两篇，第一篇将要讨论面向对象编程和它的特点，关于<span class="s1">Java</span>和它的功能的常见问题，<span class="s1">Java</span>的集合类，垃圾收集器，第二篇主要讨    论异常处理，<span class="s1">Java</span>小应用程序，<span class="s1">Swing</span>，<span class="s1">JDBC</span>，远程方法调用<span class="s1">(RMI)</span>，<span class="s1">Servlet</span>和<span class="s1">JSP</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">目录</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">面向对象编程（<span class="s1">OOP</span>）常见的<span class="s1">Java</span>问题</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Java<span class="s2">线程 </span>Java<span class="s2">集合类垃圾收集器</span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">面向对象编程（<span class="s1">OOP</span>）</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="s2">是一个支持并发、基于类和面向对象的计算机编程语言。下面列出了面向对象软件开发的优点：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">代码开发模块化，更易维护和修改。代码复用。</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">增强代码的可靠性和灵活性。增加代码的可理解性。</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。下面的章节我们会逐个分析这些特性。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">封装</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在<span class="s1">Java</span>当中，有<span class="s1">3</span>种修饰符：<span class="s1">public</span>，<span class="s1">private</span>和<span class="s1">protected</span>。每一种修饰符</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。下面列出了使用封装的一些好处：</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">通过隐藏对象的属性来保护对象内部的状态。</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: left;">提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。禁止对象之间的不良交互提高模块化。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s2" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">参考这个文档获取更多关于封装的细节和示例。多态</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">作可以应用到其他类型的值上面。继承</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">抽象</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。<span class="s1">Java</span>支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">抽象和封装的不同点</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">常见的<span class="s1">Java</span>问题</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l1"><li data-list-text="1."><p class="s2" style="padding-left: 16pt;text-indent: -10pt;text-align: left;">什么是<span class="s1">Java</span>虚拟机？为什么<span class="s1">Java</span>被称作是<span class="s1">“</span>平台无关的编程语言<span class="s1">”</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="s2">虚拟机是一个可以执行</span>Java<span class="s2">字节码的虚拟机进程。</span>Java<span class="s2">源文件被编译成能被</span>Java<span class="s2">虚拟机执行的字节码文件。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: justify;">Java<span class="s2">被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。</span>Java<span class="s2">虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s1" style="padding-left: 16pt;text-indent: -10pt;text-align: left;">JDK<span class="s2">和</span>JRE<span class="s2">的区别是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="s2">运行时环境</span>(JRE)<span class="s2">是将要执行</span>Java<span class="s2">程序的</span>Java<span class="s2">虚拟机。它同时也包含了执行</span>applet<span class="s2">需要</span></p><p class="s2" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">的浏览器插件。<span class="s1">Java</span>开发工具包<span class="s1">(JDK)</span>是完整的<span class="s1">Java</span>软件开发包，包含了<span class="s1">JRE</span>，编译器和其他的工具<span class="s1">(</span>比如：<span class="s1">JavaDoc</span>，<span class="s1">Java</span>调试器<span class="s1">)</span>，可以让开发者开发、编译、执行<span class="s1">Java</span>应用程序。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">”static”<span class="s2">关键字是什么意思？</span>Java<span class="s2">中是否可以覆盖</span>(override)<span class="s2">一个</span>private<span class="s2">或者是</span>static<span class="s2">的方法？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s1" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">“static”<span class="s2">关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">Java<span class="s2">中</span>static<span class="s2">方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而</span>static<span class="s2">方法是编译时静态绑定的。</span>static<span class="s2">方法跟类的任何实例都不相关，所以概念上不适用。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s2" style="padding-left: 16pt;text-indent: -10pt;text-align: left;">是否可以在<span class="s1">static</span>环境中访问非<span class="s1">static</span>变量？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">static<span class="s2">变量在</span>Java<span class="s2">中是属于类的，它在所有的实例中的值是一样的。当类被</span>Java<span class="s2">虚拟机载入的时候，会对</span>static<span class="s2">变量进行初始化。如果你的代码尝试不用实例来访问非</span>static<span class="s2">的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5."><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Java<span class="s2">支持的数据类型有哪些？什么是自动拆装箱？ </span>Java<span class="s2">语言支持的</span>8<span class="s2">中基本数据类型是：</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 144%;text-align: left;">byte short int long float double</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 146%;text-align: left;">boolean char</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">自动装箱是<span class="s1">Java</span>编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把<span class="s1">int</span>转化成<span class="s1">Integer</span>，<span class="s1">double</span>转化成<span class="s1">double</span>，等等。反之就是自动拆箱。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="6."><p class="s1" style="padding-left: 16pt;text-indent: -10pt;text-align: left;">Java<span class="s2">中的方法覆盖</span>(Overriding)<span class="s2">和方法重载</span>(Overloading)<span class="s2">是什么意思？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="s2">中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的</span></p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="7."><p class="s1" style="padding-left: 16pt;text-indent: -10pt;text-align: left;">Java<span class="s2">中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，<span class="s1">Java</span>编译器会为这个类创建一个默认的构造函数。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 126%;text-align: left;">Java<span class="s2">中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="s2">不支持像</span>C++<span class="s2">中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，</span>Java<span class="s2">不会创建默认的复制构造函数。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="8."><p class="s1" style="padding-left: 16pt;text-indent: -10pt;text-align: left;">Java<span class="s2">支持多继承么？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 252%;text-align: left;">不支持，<span class="s1">Java</span>不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。 <span class="s1">9.</span>接口和抽象类的区别是什么？</p><p class="s1" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="s2">提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 126%;text-align: left;">接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。类可以实现很多个接口，但是只能继承一个抽象类</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">抽象类可以在不提供接口方法实现的情况下实现接口。</p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="s2">接口中声明的变量默认都是</span>final<span class="s2">的。抽象类可以包含非</span>final<span class="s2">的变量。</span></p><p class="s1" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="s2">接口中的成员函数默认是</span>public<span class="s2">的。抽象类的成员函数可以是</span>private<span class="s2">，</span>protected<span class="s2">或者是</span>public<span class="s2">。</span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含<span class="s1">main</span>方法的话是可以被调用的。</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">也可以参考<span class="s1">JDK8 </span>中抽象类和接口的区别</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l2"><li data-list-text="10."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是值传递和引用传递？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="s2">线程</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="11."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">进程和线程的区别是什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="12."><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">创建线程有几种不同的方式？你喜欢哪一种？为什么？有三种方式可以用来创建线程：</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">继承<span class="s1">Thread</span>类</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">实现<span class="s1">Runnable</span>接口</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">应用程序可以使用<span class="s1">Executor</span>框架来创建线程池</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">实现<span class="s1">Runnable</span>接口这种方式更受欢迎，因为这不需要继承<span class="s1">Thread</span>类。在应用设计中已经继  承了别的对象的情况下，这需要多继承（而<span class="s1">Java</span>不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="13."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">概括的解释下线程的几种可用状态。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">线程在执行过程中，可以处于下面几种状态：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">就绪<span class="s1">(Runnable):</span>线程准备运行，不一定立马就能开始执行。运行中<span class="s1">(Running)</span>：进程正在执行线程的代码。</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 126%;text-align: left;">等待中<span class="s1">(Waiting):</span>线程处于阻塞的状态，等待外部的处理结束。睡眠中<span class="s1">(Sleeping)</span>：线程被强制睡眠。</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">I/O<span class="s2">阻塞</span>(Blocked on I/O)<span class="s2">：等待</span>I/O<span class="s2">操作完成。</span></p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">同步阻塞<span class="s1">(Blocked on Synchronization)</span>：等待获取锁。死亡<span class="s1">(Dead)</span>：线程完成了执行。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="14."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">同步方法和同步代码块的区别是什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">在<span class="s1">Java</span>语言中，每一个对象有一把锁。线程可以使用<span class="s1">synchronized</span>关键字来获取对象上的锁。  <span class="s1">synchronized</span>关键字可应用在方法级别<span class="s1">(</span>粗粒度锁<span class="s1">)</span>或者是代码块级别<span class="s1">(</span>细粒度锁<span class="s1">)</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="15."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">在监视器<span class="s1">(Monitor)</span>内部，是如何做线程同步的？程序应该做哪种级别的同步？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">监视器和锁在<span class="s1">Java</span>虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一  个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="16."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是死锁<span class="s1">(deadlock)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="17."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">如何确保<span class="s1">N</span>个线程可以访问<span class="s1">N</span>个资源同时又不导致死锁？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: justify;">使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="s2">集合类</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="18."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="s2">集合类框架的基本接口有哪些？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">Java<span class="s2">集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。</span>Java<span class="s2">集合类里面最基本的接口有：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: left;">Collection<span class="s2">：代表一组对象，每一个对象都是它的子元素。 </span>Set<span class="s2">：不包含重复元素的</span>Collection<span class="s2">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s1" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">List<span class="s2">：有顺序的</span>collection<span class="s2">，并且可以包含重复元素。  </span>Map<span class="s2">：可以把键</span>(key)<span class="s2">映射到值</span>(value)<span class="s2">的对象，键不能重复。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="19."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">为什么集合类没有实现<span class="s1">Cloneable</span>和<span class="s1">Serializable</span>接口？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="20."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是迭代器<span class="s1">(Iterator)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Iterator<span class="s2">接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的</span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">克隆<span class="s1">(cloning) </span>或者是序列化<span class="s1">(serialization)</span>的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="21."><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 252%;text-align: left;">Iterator<span class="s2">和</span>ListIterator<span class="s2">的区别是什么？下面列出了他们的区别：</span></p><p class="s1" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Iterator<span class="s2">可用来遍历</span>Set<span class="s2">和</span>List<span class="s2">集合，但是</span>ListIterator<span class="s2">只能用来遍历</span>List<span class="s2">。  </span>Iterator<span class="s2">对集合只能是前向遍历，</span>ListIterator<span class="s2">既可以前向也可以后向。</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">ListIterator<span class="s2">实现了</span>Iterator<span class="s2">接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="22."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">快速失败<span class="s1">(fail-fast)</span>和安全失败<span class="s1">(fail-safe)</span>的区别是什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Iterator<span class="s2">的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</span>java.util<span class="s2">包下面的所有的集合类都是快速失败的，而</span>java.util.concurrent<span class="s2">包下面的所有的类都是安全失败的。快速失败的迭代器会抛出</span>ConcurrentModificationException<span class="s2">异常，而安全失败的迭代器永远不会抛出这样的异常。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="23."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="s2">中的</span>HashMap<span class="s2">的工作原理是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="s2">中的</span>HashMap<span class="s2">是以键值对</span>(key-value)<span class="s2">的形式存储元素的。</span>HashMap<span class="s2">需要一个</span>hash<span class="s2">函数，它使用</span>hashCode()<span class="s2">和</span>equals()<span class="s2">方法来向集合</span>/<span class="s2">从集合添加和检索元素。当调用</span>put()<span class="s2">方法的时   候，</span>HashMap<span class="s2">会计算</span>key<span class="s2">的</span>hash<span class="s2">值，然后把键值对存储在集合中合适的索引上。如果</span>key</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">已经存在了，<span class="s1">value</span>会被更新成新值。<span class="s1">HashMap</span>的一些重要的特性是它的容量<span class="s1">(capacity)</span>，负载因子<span class="s1">(load factor)</span>和扩容极限<span class="s1">(threshold  resizing)</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="24."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">hashCode()<span class="s2">和</span>equals()<span class="s2">方法的重要性体现在什么地方？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="s2">中的</span>HashMap<span class="s2">使用</span>hashCode()<span class="s2">和</span>equals()<span class="s2">方法来确定键值对的索引，当根据键获取值的</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s2" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的  <span class="s1">hash</span>值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所  以这两个方法的实现对<span class="s1">HashMap</span>的精确性和正确性是至关重要的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="25."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">HashMap<span class="s2">和</span>Hashtable<span class="s2">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">HashMap<span class="s2">和</span>Hashtable<span class="s2">都实现了</span>Map<span class="s2">接口，因此很多特性非常相似。但是，他们有以下不同点：</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">HashMap<span class="s2">允许键和值是</span>null<span class="s2">，而</span>Hashtable<span class="s2">不允许键或者值是</span>null<span class="s2">。</span></p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Hashtable<span class="s2">是同步的，而</span>HashMap<span class="s2">不是。因此，</span>HashMap<span class="s2">更适合于单线程环境，而</span>Hashtable</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">适合于多线程环境。</p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">HashMap<span class="s2">提供了可供应用迭代的键的集合，因此，</span>HashMap<span class="s2">是快速失败的。另一方面，  </span>Hashtable<span class="s2">提供了对键的列举</span>(Enumeration)<span class="s2">。</span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">一般认为<span class="s1">Hashtable</span>是一个遗留的类。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="26."><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">数组<span class="s1">(Array)</span>和列表<span class="s1">(ArrayList)</span>有什么区别？什么时候应该使用<span class="s1">Array</span>而不是<span class="s1">ArrayList</span>？下面列出了<span class="s1">Array</span>和<span class="s1">ArrayList</span>的不同点：</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Array<span class="s2">可以包含基本类型和对象类型，</span>ArrayList<span class="s2">只能包含对象类型。</span></p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Array<span class="s2">大小是固定的，</span>ArrayList<span class="s2">的大小是动态变化的。</span></p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">ArrayList<span class="s2">提供了更多的方法和特性，比如：</span>addAll()<span class="s2">，</span>removeAll()<span class="s2">，</span>iterator()<span class="s2">等等。</span></p><p class="s2" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: left;">对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="27."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">ArrayList<span class="s2">和</span>LinkedList<span class="s2">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">ArrayList<span class="s2">和</span>LinkedList<span class="s2">都实现了</span>List<span class="s2">接口，他们有以下的不同点：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">ArrayList<span class="s2">是基于索引的数据接口，它的底层是数组。它可以以</span>O(1)<span class="s2">时间复杂度对元素进行随机访问。与此对应，</span>LinkedList<span class="s2">是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是</span>O(n)<span class="s2">。</span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">相对于<span class="s1">ArrayList</span>，<span class="s1">LinkedList</span>的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</p><p class="s1" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">LinkedList<span class="s2">比</span>ArrayList<span class="s2">更占内存，因为</span>LinkedList<span class="s2">为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">也可以参考<span class="s1">ArrayList vs. LinkedList</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="28."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Comparable<span class="s2">和</span>Comparator<span class="s2">接口是干什么的？列出它们的区别。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="s2">提供了只包含一个</span>compareTo()<span class="s2">方法的</span>Comparable<span class="s2">接口。这个方法可以个给两个对象排序。具体来说，它返回负数，</span>0<span class="s2">，正数来表明输入对象小于，等于，大于已经存在的对象。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="s2">提供了包含</span>compare()<span class="s2">和</span>equals()<span class="s2">两个方法的</span>Comparator<span class="s2">接口。</span>compare()<span class="s2">方法用来给两</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s2" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">个输入参数排序，返回负数，<span class="s1">0</span>，正数表明第一个参数是小于，等于，大于第二个参数。<span class="s1">equals()</span>方法需要一个对象作为参数，它用来决定输入参数是否和<span class="s1">comparator</span>相等。只有当输入参</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">数也是一个<span class="s1">comparator</span>并且输入参数和当前<span class="s1">comparator</span>的排序结果是相同的时候，这个方法才返回<span class="s1">true</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="29."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是<span class="s1">Java</span>优先级队列<span class="s1">(Priority Queue)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 126%;text-align: left;">PriorityQueue<span class="s2">是一个基于优先级堆的无界队列，它的元素是按照自然顺序</span>(natural  order)<span class="s2">排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。</span>PriorityQueue<span class="s2">不允许</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">null<span class="s2">值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，</span>PriorityQueue</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">不是线程安全的，入队和出队的时间复杂度是<span class="s1">O(log(n))</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="30."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">你了解大<span class="s1">O</span>符号<span class="s1">(big-O notation)</span>么？你能给出不同数据结构的例子么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">大<span class="s1">O</span>符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: justify;">大<span class="s1">O</span>符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大<span class="s1">O</span>符号基于时间，内存和性能来选择最好的实现。大<span class="s1">O</span>符号可以对大量数据的性能给出一个很好的说明。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="31."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">如何权衡是使用无序的数组还是有序的数组？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">有序数组最大的好处在于查找的时间复杂度是<span class="s1">O(log n)</span>，而无序数组是<span class="s1">O(n)</span>。有序数组的缺</p><p class="s2" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">点是插入操作的时间复杂度是<span class="s1">O(n)</span>，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量<span class="s1">O(1)</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="32."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="s2">集合类框架的最佳实践有哪些？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用<span class="s1">Array</span>而不是<span class="s1">ArrayList</span>。</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算<span class="s1">hash</span>值或者是扩容。</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的<span class="s1">ClassCastException</span>。</p><p class="s2" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">使用<span class="s1">JDK</span>提供的不变类<span class="s1">(immutable class)</span>作为<span class="s1">Map</span>的键可以避免为我们自己的类实现 <span class="s1">hashCode()</span>和<span class="s1">equals()</span>方法。</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">编程的时候接口优于实现。</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: justify;">底层的集合实际上是空的情况下，返回长度是<span class="s1">0</span>的集合或者是数组，不要返回<span class="s1">null</span>。 <span class="s1">33.Enumeration</span>接口和<span class="s1">Iterator</span>接口的区别有哪些？</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: justify;">Enumeration<span class="s2">速度是</span>Iterator<span class="s2">的</span>2<span class="s2">倍，同时占用更少的内存。但是，</span>Iterator<span class="s2">远远比</span>Enumeration<span class="s2">安全，因为其他线程不能够修改正在被</span>iterator<span class="s2">遍历的集合里面的对象。同时，</span>Iterator<span class="s2">允许调用者删除底层集合里面的元素，这对</span>Enumeration<span class="s2">来说是不可能的。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l3"><li data-list-text="34."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">HashSet<span class="s2">和</span>TreeSet<span class="s2">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">HashSet<span class="s2">是由一个</span>hash<span class="s2">表来实现的，因此，它的元素是无序的。</span>add()<span class="s2">，</span>remove()<span class="s2">，</span>contains()</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">方法的时间复杂度是<span class="s1">O(1)</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">另一方面，<span class="s1">TreeSet</span>是由一个树形的结构来实现的，它里面的元素是有序的。因此，<span class="s1">add()</span>，  <span class="s1">remove()</span>，<span class="s1">contains()</span>方法的时间复杂度是<span class="s1">O(logn)</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">垃圾收集器<span class="s1">(Garbage Collectors)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="35."><p class="s1" style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="s2">中垃圾回收有什么目的？什么时候进行垃圾回收？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="36."><p class="s1" style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">System.gc()<span class="s2">和</span>Runtime.gc()<span class="s2">会做什么事情？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">这两个方法用来提示<span class="s1">JVM</span>要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于<span class="s1">JVM</span>的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="37."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">finalize()<span class="s2">方法什么时候被调用？析构函数</span>(finalization)<span class="s2">的目的是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: left;">在释放对象占用的内存之前，垃圾收集器会调用对象的<span class="s1">finalize()</span>方法。一般建议在该方法中释放对象持有的资源。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="38."><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">如果对象的引用被置为<span class="s1">null</span>，垃圾收集器是否会立即释放对象占用的内存？不会，在下一个垃圾回收周期中，这个对象将是可被回收的。</p></li><li data-list-text="39."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;line-height: 15pt;text-align: left;">Java<span class="s2">堆的结构是什么样子的？什么是堆中的永久代</span>(Perm Gen space)?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JVM<span class="s2">的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在</span>JVM<span class="s2">启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="40."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">串行<span class="s1">(serial)</span>收集器和吞吐量<span class="s1">(throughput)</span>收集器的区别是什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程  序。而串行收集器对大多数的小应用<span class="s1">(</span>在现代处理器上需要大概<span class="s1">100M</span>左右的内存<span class="s1">)</span>就足够了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="41."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">在<span class="s1">Java</span>中，对象什么时候可以被垃圾回收？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="42."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">JVM<span class="s2">的永久代中会发生垃圾回收么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 130%;text-align: left;">垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收  <span class="s1">(Full  GC)</span>。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免<span class="s1">Full  GC</span>是非常重要的原因。请参考下<span class="s1">Java8</span>：从永久代到元数据区</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">(<span class="s2">译者注：</span>Java8<span class="s2">中已经移除了永久代，新加了一个叫做元数据区的</span>native<span class="s2">内存区</span>)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 3pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s4" style="padding-top: 17pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">题目：<span class="s5">115</span>个<span class="s5">Java</span>面试题和答案<span class="s5">——</span>终极（下）</p><p class="s2" style="padding-top: 16pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">第一篇讨论了面向对象编程和它的特点，关于<span class="s1">Java</span>和它的功能的常见问题，<span class="s1">Java</span>的集合类，</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">垃圾收集器，本章主要讨论异常处理，<span class="s1">Java</span>小应用程序，<span class="s1">Swing</span>，<span class="s1">JDBC</span>，远程方法调用<span class="s1">(RMI)</span>， <span class="s1">Servlet</span>和<span class="s1">JSP</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">异常处理</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Java<span class="s2">小应用程序</span>(Applet) Swing</p><p class="s1" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">JDBC</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-top: 12pt;padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">远程方法调用（<span class="s1">RMI</span>） <span class="s1">Servlet</span></p><p class="s1" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">JSP</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-top: 12pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">异常处理</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="43."><p class="s1" style="padding-top: 8pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="s2">中的两种异常类型是什么？他们有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 130%;text-align: left;">Java<span class="s2">中有两种异常：受检查的</span>(checked)<span class="s2">异常和不受检查的</span>(unchecked)<span class="s2">异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用</span>throws<span class="s2">语句在方法或者是构造函数上声明。这里有</span>Java<span class="s2">异常处理的一些小建议。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="44."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="s2">中</span>Exception<span class="s2">和</span>Error<span class="s2">有什么区别？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Exception<span class="s2">和</span>Error<span class="s2">都是</span>Throwable<span class="s2">的子类。</span>Exception<span class="s2">用于用户程序可以捕获的异常情况。</span>Error</p><p class="s2" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">定义了不期望被用户程序捕获的异常。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l4"><ol id="l5"><li data-list-text="45.1"><p class="s1" style="padding-top: 9pt;padding-left: 32pt;text-indent: -26pt;text-align: left;">throw<span class="s2">和</span>throws<span class="s2">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">throw<span class="s2">关键字用来在程序中明确的抛出异常，相反，</span>throws<span class="s2">语句用来表明方法不能处理的异  常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="45.2"><p class="s2" style="padding-left: 35pt;text-indent: -29pt;text-align: left;">异常处理的时候，<span class="s1">finally</span>代码块的重要性是什么？</p></li></ol></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">无论是否抛出异常，<span class="s1">finally</span>代码块总是会被执行。就算是没有<span class="s1">catch</span>语句同时又抛出异常的</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s2" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">情况下，<span class="s1">finally</span>代码块仍然会被执行。最后要说的是，<span class="s1">finally</span>代码块主要用来释放资源，比如：<span class="s1">I/O</span>缓冲区，数据库连接。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">46.<span class="s2">异常处理完成以后，</span>Exception<span class="s2">对象会发生什么变化？ </span>Exception<span class="s2">对象会在下一个垃圾回收过程中被回收掉。 </span>47.finally<span class="s2">代码块和</span>finalize()<span class="s2">方法有什么区别？</span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">无论是否抛出异常，<span class="s1">finally</span>代码块都会执行，它主要是用来释放应用占用的资源。<span class="s1">finalize()</span>方法是<span class="s1">Object</span>类的一个<span class="s1">protected</span>方法，它是在对象被垃圾回收之前由<span class="s1">Java</span>虚拟机来调用的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Java<span class="s2">小应用程序</span>(Applet) 48.<span class="s2">什么是</span>Applet<span class="s2">？</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">java applet<span class="s2">是能够被包含在</span>HTML<span class="s2">页面中并且能被启用了</span>java<span class="s2">的客户端浏览器执行的程序。 </span>Applet<span class="s2">主要用来创建动态交互的</span>web<span class="s2">应用程序。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">49.<span class="s2">解释一下</span>Applet<span class="s2">的生命周期 </span>applet<span class="s2">可以经历下面的状态：</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Init<span class="s2">：每次被载入的时候都会被初始化。 </span>Start<span class="s2">：开始执行</span>applet<span class="s2">。</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Stop<span class="s2">：结束执行</span>applet<span class="s2">。</span></p><p class="s1" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Destroy<span class="s2">：卸载</span>applet<span class="s2">之前，做最后的清理工作。 </span>50.<span class="s2">当</span>applet<span class="s2">被载入的时候会发生什么？</span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">首先，创建<span class="s1">applet</span>控制类的实例，然后初始化<span class="s1">applet</span>，最后开始运行。 <span class="s1">51.Applet</span>和普通的<span class="s1">Java</span>应用程序有什么区别？</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">applet<span class="s2">是运行在启用了</span>java<span class="s2">的浏览器中，</span>Java<span class="s2">应用程序是可以在浏览器之外运行的独立的</span></p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Java<span class="s2">程序。但是，它们都需要有</span>Java<span class="s2">虚拟机。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">进一步来说，<span class="s1">Java</span>应用程序需要一个有特定方法签名的<span class="s1">main</span>函数来开始执行。<span class="s1">Java applet</span></p><p class="s2" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">不需要这样的函数来开始执行。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">最后，<span class="s1">Java applet</span>一般会使用很严格的安全策略，<span class="s1">Java</span>应用一般使用比较宽松的安全策略。 <span class="s1">52.Java applet</span>有哪些限制条件？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s2" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">主要是由于安全的原因，给<span class="s1">applet</span>施加了以下的限制：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">applet<span class="s2">不能够载入类库或者定义本地方法。 </span>applet<span class="s2">不能在宿主机上读写文件。</span></p><p class="s1" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">applet<span class="s2">不能读取特定的系统属性。</span></p><p class="s1" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">applet<span class="s2">不能发起网络连接，除非是跟宿主机。 </span>applet<span class="s2">不能够开启宿主机上其他任何的程序。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l6"><li data-list-text="53."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是不受信任的<span class="s1">applet</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">不受信任的<span class="s1">applet</span>是不能访问或是执行本地系统文件的<span class="s1">Java applet</span>，默认情况下，所有下载的<span class="s1">applet</span>都是不受信任的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="54."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">从网络上加载的<span class="s1">applet</span>和从本地文件系统加载的<span class="s1">applet</span>有什么区别？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">当<span class="s1">applet</span>是从网络上加载的时候，<span class="s1">applet</span>是由<span class="s1">applet</span>类加载器载入的，它受<span class="s1">applet</span>安全管理器的限制。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">当<span class="s1">applet</span>是从客户端的本地磁盘载入的时候，<span class="s1">applet</span>是由文件系统加载器载入的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">从文件系统载入的<span class="s1">applet</span>允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="55."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">applet<span class="s2">类加载器是什么？它会做哪些工作？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">当<span class="s1">applet</span>是从网络上加载的时候，它是由<span class="s1">applet</span>类加载器载入的。类加载器有自己的<span class="s1">java</span></p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">当浏览器通过网络载入<span class="s1">applet</span>的时候，<span class="s1">applet</span>的类被放置于和<span class="s1">applet</span>的源相关联的私有的名</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守<span class="s1">Java</span>语言规范，确保不会出现堆栈溢出<span class="s1">(stack overflow)</span>或者下溢  <span class="s1">(underflow)</span>，传递给字节码指令的参数是正确的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="56."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">applet<span class="s2">安全管理器是什么？它会做哪些工作？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">applet<span class="s2">安全管理器是给</span>applet<span class="s2">施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Swing</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="57."><p class="s2" style="padding-top: 12pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">弹出式选择菜单<span class="s1">(Choice)</span>和列表<span class="s1">(List)</span>有什么区别</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Choice<span class="s2">是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。</span>Choice<span class="s2">中一次只能选中</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s2" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">一个选项。<span class="s1">List</span>同时可以有多个元素可见，支持选中一个或者多个元素。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="58."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是布局管理器？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">布局管理器用来在容器中组织组件。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="59."><p class="s2" style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">滚动条<span class="s1">(Scrollbar)</span>和滚动面板<span class="s1">(JScrollPane)</span>有什么区别？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 263%;text-align: left;">Scrollbar<span class="s2">是一个组件，不是容器。而</span>ScrollPane<span class="s2">是容器。</span>ScrollPane<span class="s2">自己处理滚动事件。 </span>60.<span class="s2">哪些</span>Swing<span class="s2">的方法是线程安全的？</span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">只有<span class="s1">3</span>个线程安全的方法： <span class="s1">repaint(), revalidate(), and invalidate()</span>。 <span class="s1">61.</span>说出三种支持重绘<span class="s1">(painting)</span>的组件。</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 252%;text-align: left;">Canvas, Frame, Panel,<span class="s2">和</span>Applet<span class="s2">支持重绘。 </span>62.<span class="s2">什么是裁剪</span>(clipping)<span class="s2">？</span></p><p class="s2" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">限制在一个给定的区域或者形状的绘图操作就做裁剪。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">63.MenuItem<span class="s2">和</span>CheckboxMenuItem<span class="s2">的区别是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">CheckboxMenuItem<span class="s2">类继承自</span>MenuItem<span class="s2">类，支持菜单选项可以选中或者不选中。  </span>64.<span class="s2">边缘布局</span>(BorderLayout)<span class="s2">里面的元素是如何布局的？</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 263%;text-align: left;">BorderLayout<span class="s2">里面的元素是按照容器的东西南北中进行布局的。 </span>65.<span class="s2">网格包布局</span>(GridBagLayout)<span class="s2">里面的元素是如何布局的？</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">GridBagLayout<span class="s2">里面的元素是按照网格进行布局的。不同大小的元素可能会占据网格的多于</span>1</p><p class="s2" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">行或一列。因此，行数和列数可以有不同的大小。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">66.Window<span class="s2">和</span>Frame<span class="s2">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Frame<span class="s2">类继承了</span>Window<span class="s2">类，它定义了一个可以有菜单栏的主应用窗口。 </span>67.<span class="s2">裁剪</span>(clipping)<span class="s2">和重绘</span>(repainting)<span class="s2">有什么联系？</span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">当窗口被<span class="s1">AWT</span>重绘线程进行重绘的时候，它会把裁剪区域设置成需要重绘的窗口的区域。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l7"><li data-list-text="68."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">事件监听器接口<span class="s1">(event-listener interface)</span>和事件适配器<span class="s1">(event-adapter)</span>有什么关系？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">事件监听器接口定义了对特定的事件，事件处理器必须要实现的方法。事件适配器给事件监听器接口提供了默认的实现。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="69."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">GUI<span class="s2">组件如何来处理它自己的事件？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">GUI<span class="s2">组件可以处理它自己的事件，只要它实现相对应的事件监听器接口，并且把自己作为事件监听器。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="70."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="s2">的布局管理器比传统的窗口系统有哪些优势？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Java<span class="s2">使用布局管理器以一种一致的方式在所有的窗口平台上摆放组件。因为布局管理器不会和组件的绝对大小和位置相绑定，所以他们能够适应跨窗口系统的特定平台的不同。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="71."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Java<span class="s2">的</span>Swing<span class="s2">组件使用了哪种设计模式？</span></p><p class="s1" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">Java<span class="s2">中的</span>Swing<span class="s2">组件使用了</span>MVC(<span class="s2">视图</span>-<span class="s2">模型</span>-<span class="s2">控制器</span>)<span class="s2">设计模式。 </span>JDBC</p></li><li data-list-text="72."><p class="s2" style="padding-top: 4pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是<span class="s1">JDBC</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JDBC<span class="s2">是允许用户在不同数据库之间做选择的一个抽象层。</span>JDBC<span class="s2">允许开发者用</span>JAVA<span class="s2">写数据库应用程序，而不需要关心底层特定数据库的细节。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="73."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">解释下驱动<span class="s1">(Driver)</span>在<span class="s1">JDBC</span>中的角色。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JDBC<span class="s2">驱动提供了特定厂商对</span>JDBC  API<span class="s2">接口类的实现，驱动必须要提供</span>java.sql<span class="s2">包下面这些类的实现：</span>Connection, Statement, PreparedStatement,CallableStatement, ResultSet<span class="s2">和</span>Driver<span class="s2">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="74."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">Class.forName()<span class="s2">方法有什么作用？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">这个方法用来载入跟数据库建立连接的驱动。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="75."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">PreparedStatement<span class="s2">比</span>Statement<span class="s2">有什么优势？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">PreparedStatements<span class="s2">是预编译的，因此，性能会更好。同时，不同的查询参数值， </span>PreparedStatement<span class="s2">可以重用。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="76."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么时候使用<span class="s1">CallableStatement</span>？用来准备<span class="s1">CallableStatement</span>的方法是什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">CallableStatement<span class="s2">用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个</span>CallableStatement<span class="s2">的方法是：</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 13pt;text-align: left;">CallableStament.prepareCall();</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 3pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="77."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">数据库连接池是什么意思？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 263%;text-align: left;">远程方法调用<span class="s1">(RMI) 78.</span>什么是<span class="s1">RMI</span>？</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 130%;text-align: left;">Java<span class="s2">远程方法调用</span>(Java  RMI)<span class="s2">是</span>Java  API<span class="s2">对远程过程调用</span>(RPC)<span class="s2">提供的面向对象的等价形式，支持直接传输序列化的</span>Java<span class="s2">对象和分布式垃圾回收。远程方法调用可以看做是激活远程正  在运行的对象上的方法的步骤。</span>RMI<span class="s2">对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下</span>RMI<span class="s2">的一些注意事项。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l8"><li data-list-text="79."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">RMI<span class="s2">体系结构的基本原则是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">RMI<span class="s2">体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。</span>RMI<span class="s2">允许定义行为的代码和实现行为的代码相分离，并且运行在不同的</span>JVM<span class="s2">上。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="80."><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">RMI<span class="s2">体系结构分哪几层？ </span>RMI<span class="s2">体系结构分以下几层：</span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">存根和骨架层<span class="s1">(Stub and Skeleton layer)</span>：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的<span class="s1">RMI</span>服务。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">远程引用层<span class="s1">(Remote  Reference  Layer)</span>：<span class="s1">RMI</span>体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">传输层<span class="s1">(Transport  layer)</span>：这一层负责连接参与服务的两个<span class="s1">JVM</span>。这一层是建立在网络上机器间的<span class="s1">TCP/IP</span>连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="81."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">RMI<span class="s2">中的远程接口</span>(Remote Interface)<span class="s2">扮演了什么样的角色？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: justify;">远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="82."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">java.rmi.Naming<span class="s2">类扮演了什么样的角色？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">java.rmi.Naming<span class="s2">类用来存储和获取在远程对象注册表里面的远程对象的引用。</span>Naming<span class="s2">类的</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s2" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">每一个方法接收一个<span class="s1">URL</span>格式的<span class="s1">String</span>对象作为它的参数。 <span class="s1">83.RMI</span>的绑定<span class="s1">(Binding)</span>是什么意思？</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">象可以使用<span class="s1">Naming</span>类的<span class="s1">bind()</span>或者<span class="s1">rebind()</span>方法跟名称相关联。 <span class="s1">84.Naming</span>类的<span class="s1">bind()</span>和<span class="s1">rebind()</span>方法有什么区别？</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">bind()<span class="s2">方法负责把指定名称绑定给远程对象，</span>rebind()<span class="s2">方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l9"><li data-list-text="85."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">让<span class="s1">RMI</span>程序能正确运行有哪些步骤？</p><p class="s2" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 42pt;text-align: left;">为了让<span class="s1">RMI</span>程序能正确运行必须要包含以下几个步骤：编译所有的源文件。</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 128%;text-align: left;">使用<span class="s1">rmic</span>生成<span class="s1">stub</span>。启动<span class="s1">rmiregistry</span>。 启动<span class="s1">RMI</span>服务器。运行客户端程序。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="86."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">RMI<span class="s2">的</span>stub<span class="s2">扮演了什么样的角色？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">远程对象的<span class="s1">stub</span>扮演了远程对象的代表或者代理的角色。调用者在本地<span class="s1">stub</span>上调用方法，它负责在远程对象上执行方法。当<span class="s1">stub</span>的方法被调用的时候，会经历以下几个步骤：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 126%;text-align: left;">初始化到包含了远程对象的<span class="s1">JVM</span>的连接。序列化参数到远程的<span class="s1">JVM</span>。</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">等待方法调用和执行的结果。</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">反序列化返回的值或者是方法没有执行成功情况下的异常。把值返回给调用者。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="87."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是分布式垃圾回收<span class="s1">(DGC)</span>？它是如何工作的？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">DGC<span class="s2">叫做分布式垃圾回收。</span>RMI<span class="s2">使用</span>DGC<span class="s2">来做自动垃圾回收。因为</span>RMI<span class="s2">包含了跨虚拟机的  远程对象的引用，垃圾回收是很困难的。</span>DGC<span class="s2">使用引用计数算法来给远程对象提供自动内存管理。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="88."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">RMI<span class="s2">中使用</span>RMI<span class="s2">安全管理器</span>(RMISecurityManager)<span class="s2">的目的是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">RMISecurityManager<span class="s2">使用下载好的代码提供可被</span>RMI<span class="s2">应用程序使用的安全管理器。如果没有设置安全管理器，</span>RMI<span class="s2">的类加载器就不会从远程下载任何的类。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p></li><li data-list-text="89."><p class="s2" style="padding-top: 3pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">解释下<span class="s1">Marshalling</span>和<span class="s1">demarshalling</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: left;">当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做<span class="s1">Marshalling</span>，反之就是  <span class="s1">demarshalling</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="90."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">解释下<span class="s1">Serialization</span>和<span class="s1">Deserialization</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">Java<span class="s2">提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Servlet</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="91."><p class="s2" style="padding-top: 12pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是<span class="s1">Servlet</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 122%;text-align: left;">Servlet<span class="s2">是用来处理客户端请求并产生动态网页内容的</span>Java<span class="s2">类。</span>Servlet<span class="s2">主要是用来处理或者是存储</span>HTML<span class="s2">表单提交的数据，产生动态内容，在无状态的</span>HTTP  <span class="s2">协议下管理状态信息。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="92."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">说一下<span class="s1">Servlet</span>的体系结构。</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: justify;">所有的<span class="s1">Servlet</span>都必须要实现的核心的接口是<span class="s1">javax.servlet.Servlet</span>。每一个<span class="s1">Servlet</span>都必须要直接或者是间接实现这个接口，或者是继承<span class="s1">javax.servlet.GenericServlet</span>或者</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 262%;text-align: left;">javax.servlet.http.HTTP Servlet<span class="s2">。最后，</span>Servlet<span class="s2">使用多线程可以并行的为多个请求服务。 </span>93.Applet<span class="s2">和</span>Servlet<span class="s2">有什么区别？</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">Applet<span class="s2">是运行在客户端主机的浏览器上的客户端</span>Java<span class="s2">程序。而</span>Servlet<span class="s2">是运行在</span>web<span class="s2">服务器上的服务端的组件。</span>applet<span class="s2">可以使用用户界面类，而</span>Servlet<span class="s2">没有用户界面，相反，</span>Servlet<span class="s2">是等待客户端的</span>HTTP<span class="s2">请求，然后为请求产生响应。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l10"><li data-list-text="94."><p class="s1" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">GenericServlet<span class="s2">和</span>HttpServlet<span class="s2">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">GenericServlet<span class="s2">是一个通用的协议无关的</span>Servlet<span class="s2">，它实现了</span>Servlet<span class="s2">和</span>ServletConfig<span class="s2">接口。继承自</span>GenericServlet<span class="s2">的</span>Servlet<span class="s2">应该要覆盖</span>service()<span class="s2">方法。最后，为了开发一个能用在网页上服务于使用</span>HTTP<span class="s2">协议请求的</span>Servlet<span class="s2">，你的</span>Servlet<span class="s2">必须要继承自</span>HttpServlet<span class="s2">。这里有</span>Servlet<span class="s2">的例子。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="95."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">解释下<span class="s1">Servlet</span>的生命周期。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">对每一个客户端的请求，<span class="s1">Servlet</span>引擎载入<span class="s1">Servlet</span>，调用它的<span class="s1">init()</span>方法，完成<span class="s1">Servlet</span>的初始化。然后，<span class="s1">Servlet</span>对象通过为每一个请求单独调用<span class="s1">service()</span>方法来处理所有随后来自客户端</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">的请求，最后，调用<span class="s1">Servlet(</span>译者注：这里应该是<span class="s1">Servlet</span>而不是<span class="s1">server)</span>的<span class="s1">destroy()</span>方法把<span class="s1">Servlet</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 3pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s2" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">删除掉。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="96."><p class="s1" style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">doGet()<span class="s2">方法和</span>doPost()<span class="s2">方法有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">doGet<span class="s2">：</span>GET<span class="s2">方法会把名值对追加在请求的</span>URL<span class="s2">后面。因为</span>URL<span class="s2">对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">doPOST<span class="s2">：</span>POST<span class="s2">方法通过把请求参数值放在请求体中来克服</span>GET<span class="s2">方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过</span>POST<span class="s2">请求传递的敏感信息对外部客户端是不可见的。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="97."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是<span class="s1">Web</span>应用程序？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">Web<span class="s2">应用程序是对</span>Web<span class="s2">或者是应用服务器的动态扩展。有两种类型的</span>Web<span class="s2">应用：面向表现  的和面向服务的。面向表现的</span>Web<span class="s2">应用程序会产生包含了很多种标记语言和动态内容的交互的</span>web<span class="s2">页面作为对请求的响应。而面向服务的</span>Web<span class="s2">应用实现了</span>Web<span class="s2">服务的端点</span>(endpoint)<span class="s2">。一般来说，一个</span>Web<span class="s2">应用可以看成是一组安装在服务器</span>URL<span class="s2">名称空间的特定子集下面的  </span>Servlet<span class="s2">的集合。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="98."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是服务端包含<span class="s1">(Server Side Include)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">服务端包含<span class="s1">(SSI)</span>是一种简单的解释型服务端脚本语言，大多数时候仅用在<span class="s1">Web</span>上，用<span class="s1">servlet</span>标签嵌入进来。<span class="s1">SSI</span>最常用的场景把一个或多个文件包含到<span class="s1">Web</span>服务器的一个<span class="s1">Web</span>页面中。当浏览器访问<span class="s1">Web</span>页面的时候，<span class="s1">Web</span>服务器会用对应的<span class="s1">servlet</span>产生的文本来替换<span class="s1">Web</span>页</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">面中的<span class="s1">servlet</span>标签。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="99."><p class="s2" style="padding-left: 22pt;text-indent: -16pt;text-align: left;">什么是<span class="s1">Servlet</span>链<span class="s1">(Servlet Chaining)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">Servlet<span class="s2">链是把一个</span>Servlet<span class="s2">的输出发送给另一个</span>Servlet<span class="s2">的方法。第二个</span>Servlet<span class="s2">的输出可以发送给第三个</span>Servlet<span class="s2">，依次类推。链条上最后一个</span>Servlet<span class="s2">负责把响应发送给客户端。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="100."><p class="s2" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">如何知道是哪一个客户端的机器正在请求你的<span class="s1">Servlet</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">ServletRequest<span class="s2">类可以找出客户端机器的</span>IP<span class="s2">地址或者是主机名。</span>getRemoteAddr()<span class="s2">方法获取客户端主机的</span>IP<span class="s2">地址，</span>getRemoteHost()<span class="s2">可以获取主机名。看下这里的例子。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="101."><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 258%;text-align: left;">HTTP<span class="s2">响应的结构是怎么样的？ </span>HTTP <span class="s2">响应由三个部分组成：</span></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">状态码<span class="s1">(Status   Code)</span>：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果<span class="s1">Servlet</span>没有返回状态码，默认会返回成功的状态码<span class="s1">HttpServletResponse.SC_OK</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">HTTP <span class="s2">头部</span>(HTTP  Header)<span class="s2">：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在</span>Serlet</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">中检索<span class="s1">HTTP </span>的头部看这里。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">主体<span class="s1">(Body)</span>：它包含了响应的内容。它可以包含<span class="s1">HTML</span>代码，图片，等等。主体是由传输在 <span class="s1">HTTP </span>消息中紧跟在头部后面的数据字节组成的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="102."><p class="s2" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">cookie</span>？<span class="s1">session</span>和<span class="s1">cookie</span>有什么区别？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: justify;">cookie<span class="s2">是</span>Web<span class="s2">服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个</span>Web<span class="s2">服务器存储</span>cookie<span class="s2">。以后浏览器在给特定的</span>Web<span class="s2">服务器发请求的时候，同时会发送所有为该服务器存储的</span>cookie<span class="s2">。下面列出了</span>session<span class="s2">和</span>cookie<span class="s2">的区别：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">无论客户端浏览器做怎么样的设置，<span class="s1">session</span>都应该能正常工作。客户端可以选择禁用<span class="s1">cookie</span>，但是，<span class="s1">session</span>仍然是能够工作的，因为客户端无法禁用服务端的<span class="s1">session</span>。</p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">在存储的数据量方面<span class="s1">session</span>和<span class="s1">cookies</span>也是不一样的。<span class="s1">session</span>能够存储任意的<span class="s1">Java</span>对象，  <span class="s1">cookie</span>只能存储<span class="s1">String</span>类型的对象。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="103."><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">浏览器和<span class="s1">Servlet</span>通信使用的是什么协议？浏览器和<span class="s1">Servlet</span>通信使用的是<span class="s1">HTTP</span>协议。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="104."><p class="s2" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">HTTP</span>隧道？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">HTTP <span class="s2">隧道是一种利用</span>HTTP<span class="s2">或者是</span>HTTP S<span class="s2">把多种网络协议封装起来进行通信的技术。因此， </span>HTTP <span class="s2">协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成</span>HTTP <span class="s2">的请求就是</span>HTTP <span class="s2">隧道。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="105."><p class="s1" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">sendRedirect()<span class="s2">和</span>forward()<span class="s2">方法有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 128%;text-align: left;">sendRedirect()<span class="s2">方法会创建一个新的请求，而</span>forward()<span class="s2">方法只是把请求转发到一个新的目标  上。重定向</span>(redirect)<span class="s2">以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发</span>(forwarding)<span class="s2">以后，之前请求作用域范围以内的对象还是能访问的。一般认为  </span>sendRedirect()<span class="s2">比</span>forward()<span class="s2">要慢。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="106."><p class="s2" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">URL</span>编码和<span class="s1">URL</span>解码？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 126%;text-align: left;">URL<span class="s2">编码是负责把</span>URL<span class="s2">里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">JSP</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="107."><p class="s2" style="padding-top: 12pt;padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">JSP</span>页面？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p class="s1" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JSP<span class="s2">页面是一种包含了静态数据和</span>JSP<span class="s2">元素两种类型的文本的文本文档。静态数据可以用任何基于文本的格式来表示，比如：</span>HTML<span class="s2">或者</span>XML<span class="s2">。</span>JSP<span class="s2">是一种混合了静态内容和动态产生的内容的技术。这里看下</span>JSP<span class="s2">的例子。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="108."><p class="s1" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">JSP<span class="s2">请求是如何被处理的？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 130%;text-align: left;">浏览器首先要请求一个以<span class="s1">.jsp</span>扩展名结尾的页面，发起<span class="s1">JSP</span>请求，然后，<span class="s1">Web</span>服务器读取这个请求，使用<span class="s1">JSP</span>编译器把<span class="s1">JSP</span>页面转化成一个<span class="s1">Servlet</span>类。需要注意的是，只有当第一次请求页面或者是<span class="s1">JSP</span>文件发生改变的时候<span class="s1">JSP</span>文件才会被编译，然后服务器调用<span class="s1">servlet</span>类，处理浏览器的请求。一旦请求执行结束，<span class="s1">servlet</span>会把响应发送给客户端。这里看下如何在<span class="s1">JSP</span>中获取请求参数。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="109."><p class="s1" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">JSP<span class="s2">有什么优点？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">下面列出了使用<span class="s1">JSP</span>的优点：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JSP<span class="s2">页面是被动态编译成</span>Servlet<span class="s2">的，因此，开发者可以很容易的更新展现代码。 </span>JSP<span class="s2">页面可以被预编译。</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">JSP<span class="s2">页面可以很容易的和静态模板结合，包括：</span>HTML<span class="s2">或者</span>XML<span class="s2">，也可以很容易的和产生动</span></p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">态内容的代码结合起来。</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">开发者可以提供让页面设计者以类<span class="s1">XML</span>格式来访问的自定义的<span class="s1">JSP</span>标签库。</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。</p></li><li data-list-text="110."><p class="s2" style="padding-top: 5pt;padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">JSP</span>指令<span class="s1">(Directive)</span>？<span class="s1">JSP</span>中有哪些不同类型的指令？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Directive<span class="s2">是当</span>JSP<span class="s2">页面被编译成</span>Servlet<span class="s2">的时候，</span>JSP<span class="s2">引擎要处理的指令。</span>Directive<span class="s2">用来设置</span></p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">页面级别的指令，从外部文件插入数据，指定自定义的标签库。<span class="s1">Directive</span>是定义在<span class="s1">&lt;%@ </span>和 <span class="s1">%&gt;</span></p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">之间的。下面列出了不同类型的<span class="s1">Directive</span>：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">包含指令<span class="s1">(Include directive)</span>：用来包含文件和合并文件内容到当前的页面。</p><p class="s2" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">页面指令<span class="s1">(Page directive)</span>：用来定义<span class="s1">JSP</span>页面中特定的属性，比如错误页面和缓冲区。 <span class="s1">Taglib</span>指令： 用来声明页面中使用的自定义的标签库。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="111."><p class="s2" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">JSP</span>动作<span class="s1">(JSP action)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JSP<span class="s2">动作以</span>XML<span class="s2">语法的结构来控制</span>Servlet<span class="s2">引擎的行为。当</span>JSP<span class="s2">页面被请求的时候，</span>JSP<span class="s2">动作   会被执行。它们可以被动态的插入到文件中，重用</span>JavaBean<span class="s2">组件，转发用户到其他的页面，或者是给</span>Java<span class="s2">插件产生</span>HTML<span class="s2">代码。下面列出了可用的动作：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">jsp:include-<span class="s2">当</span>JSP<span class="s2">页面被请求的时候包含一个文件。 </span>jsp:useBean-<span class="s2">找出或者是初始化</span>Javabean<span class="s2">。 </span>jsp:setProperty-<span class="s2">设置</span>JavaBean<span class="s2">的属性。 </span>jsp:getProperty-<span class="s2">获取</span>JavaBean<span class="s2">的属性。</span></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 127%;text-align: left;">jsp:forward-<span class="s2">把请求转发到新的页面。 </span>jsp:plugin-<span class="s2">产生特定浏览器的代码。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s1" style="padding-top: 11pt;padding-left: 343pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span class="s2"></span><span class="s2"></span></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 19pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="112."><p class="s2" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是<span class="s1">Scriptlets</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JSP<span class="s2">技术中，</span>scriptlet<span class="s2">是嵌入在</span>JSP<span class="s2">页面中的一段</span>Java<span class="s2">代码。</span>scriptlet<span class="s2">是位于标签内部的所有的东西，在标签与标签之间，用户可以添加任意有效的</span>scriplet<span class="s2">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="113."><p class="s2" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">声明<span class="s1">(Decalaration) </span>在哪里？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">声明跟<span class="s1">Java</span>中的变量声明很相似，它用来声明随后要被表达式或者<span class="s1">scriptlet</span>使用的变量。添加的声明必须要用开始和结束标签包起来。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="114."><p class="s2" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">什么是表达式<span class="s1">(Expression)</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JSP<span class="s2">表达式是</span>Web<span class="s2">服务器把脚本语言表达式的值转化成一个</span>String<span class="s2">对象，插入到返回给客户端的数据流中。表达式是在</span>&lt;%=<span class="s2">和</span>%&gt;<span class="s2">这两个标签之间定义的。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="115."><p class="s2" style="padding-left: 29pt;text-indent: -23pt;text-align: left;">隐含对象是什么意思？有哪些隐含对象？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 131%;text-align: left;">JSP<span class="s2">隐含对象是页面中的一些</span>Java<span class="s2">对象，</span>JSP<span class="s2">容器让这些</span>Java<span class="s2">对象可以为开发者所使用。开   发者不用明确的声明就可以直接使用他们。</span>JSP<span class="s2">隐含对象也叫做预定义变量。下面列出了</span>JSP<span class="s2">页面中的隐含对象：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 144%;text-align: left;">application page request response session exception out</p><p class="s1" style="padding-left: 6pt;text-indent: 0pt;line-height: 146%;text-align: left;">config pageContext</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">祝：编程快乐！</p><ol id="l11"><li data-list-text="1."><p class="s6" style="padding-top: 1pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">什么是 ActiveMQ?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 2pt;text-align: justify;">activeMQ 是一种开源的，实现了 JMS1.1 规范的，面向消息(MOM)的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信</p></li><li data-list-text="2."><p class="s6" style="padding-top: 8pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">ActiveMQ 服务器宕机怎么办？</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">这得从 ActiveMQ 的储存机制说起。在通常的情况下，非持久化消息是存储在内存中的，持久化消息是存储在文件中的，它们的最大限制在配置文件的&lt;systemUsage&gt;节点中配置。但是，在非持久化消息堆积到一定程度，内存告急的时候，ActiveMQ 会将内存中的非持久化消息写入临时文件中，以腾出内存。虽然都保存到了文件里，但它和持久化消息的区别是，重启后持久化消息会从文件中恢复，非持久化的临时文件会直接删除。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">那如果文件增大到达了配置中的最大限制的时候会发生什么？我做了以下实验：</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">设置 2G 左右的持久化文件限制，大量生产持久化消息直到文件达到最大限制，此时生产者阻塞，但消费者可正常连接并消费消息，等消息消费掉一部分，文件删除又腾出空间之后，生产者又可继续发送消息，服务自动恢复正常。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">设置 2G 左右的临时文件限制，大量生产非持久化消息并写入临时文件，在达到最大限制时，生产者阻塞，消费者可正常连接但不能消费消息，或者原本慢速消费的消费者，消费突然停止。整个系统可连接，但是无法提供服务，就这样挂了。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">具体原因不详，解决方案：尽量不要用非持久化消息，非要用的话，将临时文件限制尽可能的调大。</p></li><li data-list-text="3."><p class="s6" style="padding-top: 8pt;padding-left: 35pt;text-indent: -12pt;text-align: left;">丢消息怎么办？</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">这得从 java 的 java.net.SocketException 异常说起。简单点说就是当网络发送方发送一堆数据，然后调用 close 关闭连接之后。这些发送的数据都在接收者的缓存里，接收者如果调用 read 方法仍旧能从缓存中读取这些数据，尽管对方已经关闭了连接。但是当接收者尝试发送数据时，由于此时连接已关闭，所以会发生异常，这个很好理解。不过需要注意的是，当发生 SocketException 后，原本缓存区中数据也作废了，此时接收者再次调用 read 方法去读取缓存中的数据，就会报 Software caused connection abort: recv failed 错误。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">通过抓包得知，ActiveMQ 会每隔 10 秒发送一个心跳包，这个心跳包是服务器发送给客户端的，用来判断客户端死没死。如果你看过上面第一条，就会知道非持久化消息堆积到一定程度会写到文件里，这个写的过程会阻塞所有动作，而且会持续 20 到 30 秒，并且随着内存的增大而增大。当客户端发完消息调用 connection.close()时，会期待服务器对于关闭连接的回答，如果超过 15 秒没回答就直接调用 socket 层的 close 关闭 tcp 连接了。这时客户端发出的消息其实还在服务器的缓存里等待处理，不过由于服务器心跳包的设置，导致发生了 java.net.SocketException 异常，把缓存里的数据作废了，没处理的消息全部丢失。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">解决方案：用持久化消息，或者非持久化消息及时处理不要堆积，或者启动事务，启动事务后，commit()方法会负责任的等待服务器的返回，也就不会关闭连接导致消息丢失了。</p></li><li data-list-text="4."><p class="s6" style="padding-top: 1pt;padding-left: 35pt;text-indent: -12pt;text-align: left;">持久化消息非常慢。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">默认的情况下，非持久化的消息是异步发送的，持久化的消息是同步发送的，遇到慢一点的硬盘，发送消息的速度是无法忍受的。但是在开启事务的情况下，消息都是异步发送的，效率会有 2 个数量级的提升。所以在发送持久化消息时，请务必开启事务模式。其实发送非持久化消息时也建议开启事务，因为根本不会影响性能。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5."><p class="s6" style="padding-left: 35pt;text-indent: -12pt;text-align: left;">消息的不均匀消费。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">有时在发送一些消息之后，开启 2 个消费者去处理消息。会发现一个消费者处理了所有的消息，另一个消费者根本没收到消息。原因在于 ActiveMQ 的 prefetch 机制。当消费者去获取消息时，不会一条一条去获取，而是一次性获取一批，默认是 1000 条。这些预获取的消息，在还没确认消费之前，在管理控制台还是可以看见这些消息的，但是不会再分配给其他消费者，此时这些消息的状态应该算作“已分配未消费”，如果消息最后被消费，则会在服务器端被删除，如果消费者崩溃，则这些消息会被重新分配给新的消费者。但是如果消费者既不消费确认，又不崩溃，那这些消息就永远躺在消费者的缓存区里无法处理。更通常的情况是，消费这些消息非常耗时，你开了 10 个消费者去处理，结果发现只有一台机器吭哧吭哧处理，另</p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: justify;">外 9 台啥事不干。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">解决方案：将 prefetch 设为 1，每次处理 1 条消息，处理完再去取，这样也慢不了多少。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="6."><p class="s6" style="padding-left: 35pt;text-indent: -12pt;text-align: left;">死信队列。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">如果你想在消息处理失败后，不被服务器删除，还能被其他消费者处理或重试，可以关闭 AUTO_ACKNOWLEDGE，将 ack 交由程序自己处理。那如果使用了 AUTO_ACKNOWLEDGE，消息是什么时候被确认的，还有没有阻止消息确认的方法？有！</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">消费消息有 2 种方法，一种是调用 consumer.receive()方法，该方法将阻塞直到获得并返回一条消息。这种情况下，消息返回给方法调用者之后就自动被确认了。另一种方法是采用 listener 回调函数，在有消息到达时，会调用 listener 接口的 onMessage 方法。在这种情况下，在 onMessage 方法执行完毕后，消息才会被确认，此时只要在方法中抛出异常，该消息就不会被确认。那么问题来了，如果一条消息不能被处理，会被退回服务器重新分配，如果只有一个消费者，该消息又会重新被获取，重新抛异常。就算有多个消费者，往往在一个服务器上不能处理的消息，在另外的服务器上依然不能被处理。难道就这么退回--获取--报错死循环了吗？</p><p class="s7" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">在重试 6 次后，ActiveMQ 认为这条消息是“有毒”的，将会把消息丢到死信队列里。如果你的消息不见了，去 ActiveMQ.DLQ 里找找，说不定就躺在那里。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="7."><p class="s6" style="padding-left: 33pt;text-indent: -10pt;text-align: left;">ActiveMQ 中的消息重发时间间隔和重发次数吗？</p></li></ol><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">ActiveMQ：是 Apache 出品，最流行的，能力强劲的开源消息总线。是一个完全支持 JMS1.1 和 J2EE 1.4规范的 JMS Provider 实现。JMS（Java 消息服务）：是一个 Java 平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">首先，我们得大概了解下，在哪些情况下，ActiveMQ 服务器会将消息重发给消费者，这里为简单起见，假定采用的消息发送模式为队列（即消息发送者和消息接收者）。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">① 如果消息接收者在处理完一条消息的处理过程后没有对 MOM 进行应答，则该消息将由 MOM 重发.</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">② 如果我们队某个队列设置了预读参数（consumer.prefetchSize），如果消息接收者在处理第一条消息时（没向 MOM 发送消息接收确认）就宕机了，则预读数量的所有消息都将被重发!</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">③ 如果 Session 是事务的，则只要消息接收者有一条消息没有确认，或发送消息期间 MOM 或客户端某一方突然宕机了，则该事务范围中的所有消息 MOM 都将重发。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">④ 说到这里，大家可能会有疑问，ActiveMQ 消息服务器怎么知道消费者客户端到底是消息正在处理中还没来得急对消息进行应答还是已经处理完成了没有应答或是宕机了根本没机会应答呢？其实在所有的客户端机器上，内存中都运行着一套客户端的 ActiveMQ 环境，该环境负责缓存发来的消息，负责维持着和 ActiveMQ 服务器的消息通讯，负责失效转移（fail-over）等，所有的判断和处理都是由这套客户端环境来完成的。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">我们可以来对 ActiveMQ 的重发策略（Redelivery Policy）来进行自定义配置，其中的配置参数主要有以下几个：</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">可用的属性</p><p class="s7" style="padding-top: 7pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">属性 默认值 说明</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">l collisionAvoidanceFactor 默认值 0.15 , 设置防止冲突范围的正负百分比，只有启用</p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">useCollisionAvoidance 参数时才生效。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l maximumRedeliveries 默认值 6 , 最大重传次数，达到最大重连次数后抛出异常。为-1 时不限制次数，为 0 时表示不进行重传。</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">l maximumRedeliveryDelay 默认值-1, 最大传送延迟，只在 useExponentialBackOff 为 true 时有效</p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">（V5.5），假设首次重连间隔为 10ms，倍数为 2，那么第二次重连时间间隔为 20ms，第三次重连时间间隔为 40ms，当重连时间间隔大的最大重连时间间隔时，以后每次重连时间间隔都为最大重连时间间隔。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l initialRedeliveryDelay 默认值 1000L, 初始重发延迟时间</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l redeliveryDelay 默认值 1000L, 重发延迟时间，当 initialRedeliveryDelay=0 时生效（v5.4）</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">l useCollisionAvoidance 默认值 false, 启用防止冲突功能，因为消息接收时是可以使用多线程并发处理的，应该是为了重发的安全性，避开所有并发线程都在同一个时间点进行消息接收处理。所有线程在同</p><p class="s7" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">一个时间点处理时会发生什么问题呢？应该没有问题，只是为了平衡 broker 处理性能，不会有时很忙，有时很空闲。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l useExponentialBackOff 默认值 false, 启用指数倍数递增的方式增加延迟时间。</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">l backOffMultiplier 默认值 5, 重连时间间隔递增倍数，只有值大于 1 和启用 useExponentialBackOff</p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">参数时才生效。</p><ol id="l12"><li data-list-text="1."><p class="s8" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">Dubbo <span class="s9">中 </span>zookeeper <span class="s9">做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？</span></p><p class="s10" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 152%;text-align: justify;">可以通信的，启动 <span class="s11">dubbo </span>时，消费者会从 <span class="s11">zk </span>拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用；</p><p class="s10" style="padding-left: 23pt;text-indent: 0pt;line-height: 152%;text-align: justify;">注册中心对等集群，任意一台宕机后，将会切换到另一台；注册中心全部宕机后，服务的提供者和消费者仍能通过本地缓存通讯。服务提供者无状态，任一台 宕机后，不影响使用；服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复；</p><p class="s10" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">挂掉是不要紧的，但前提是你没有增加新的服务，如果你要调用新的服务，则是不能办到的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="padding-bottom: 2pt;padding-left: 39pt;text-indent: 0pt;text-align: center;">附文档截图：</p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s8" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">dubbo <span class="s9">服务负载均衡策略？</span></p><p class="s11" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l Random LoadBalance</p><p class="s10" style="padding-top: 5pt;padding-left: 23pt;text-indent: 8pt;line-height: 152%;text-align: left;">随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。<span class="s11">(</span>权重可以在 <span class="s11">dubbo </span>管控台配置<span class="s11">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l RoundRobin LoadBalance</p><p class="s10" style="padding-top: 5pt;padding-left: 23pt;text-indent: 8pt;line-height: 152%;text-align: left;">轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l LeastActive LoadBalance</p><p class="s10" style="padding-top: 5pt;padding-left: 23pt;text-indent: 6pt;line-height: 152%;text-align: left;">最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l ConsistentHash LoadBalance</p><p class="s10" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 152%;text-align: left;">一致性 <span class="s11">Hash</span>，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。缺省只对第一个参数 <span class="s11">Hash</span>，如果要修改，请配置</p><p class="s12" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">[AppleScript] <span class="s13">纯文本查看 复制代码</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="680" height="34" alt="image" src="整合_files/Image_024.png"/></span></p><p class="s14" style="padding-top: 5pt;padding-left: 45pt;text-indent: 0pt;text-align: left;">&lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-top: 7pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">1</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://bbs.itheima.com/" class="s16">?</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">缺省用 <span class="s11">160 </span>份虚拟节点，如果要修改，请配置</p><p class="s12" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">[AppleScript] <span class="s13">纯文本查看 复制代码</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="680" height="34" alt="image" src="整合_files/Image_025.png"/></span></p><p class="s14" style="padding-top: 5pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-top: 7pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">1</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://bbs.itheima.com/" class="s16">?</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s8" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">Dubbo <span class="s9">在安全机制方面是如何解决的</span></p><p class="s11" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 152%;text-align: left;">Dubbo <span class="s10">通过 </span>Token <span class="s10">令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。</span>Dubbo <span class="s10">还提供服务黑白名单，来控制服务所允许的调用方。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s8" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">dubbo <span class="s9">连接注册中心和直连的区别</span></p></li></ol><p class="s10" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 152%;text-align: left;">在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，这时候可能需要点对点直连，点对点直联方式，将以服务接口为单位，忽略注册中心的提供者列表，</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 152%;text-align: justify;">服务注册中心，动态的注册和发现服务，使服务的位置透明，并通过在消费方获取服务提供方地址列表，实现软负载均衡和 <span class="s11">Failover</span>， 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p><p class="s10" style="padding-left: 23pt;text-indent: 0pt;line-height: 152%;text-align: left;">服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调 用。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外，注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</p><p class="s10" style="padding-left: 23pt;text-indent: 0pt;line-height: 152%;text-align: left;">注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。</p><p class="s11" style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">1. <b>dubbo </b><span class="s9">服务集群配置（集群容错模式）</span></p><p class="s10" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">在集群调用失败时，<span class="s11">Dubbo </span>提供了多种容错方案，缺省为 <span class="s11">failover </span>重试。可以自行扩展集群容错策略</p><p class="s11" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l Failover Cluster(<span class="s10">默认</span>)</p><p class="s17" style="padding-top: 2pt;padding-left: 23pt;text-indent: 24pt;text-align: left;">失败自动切换，当出现失败，重试其它服务器。(缺省)通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot;来设置重试次数(不含第一次)。</p><p class="s12" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">[AppleScript] <span class="s13">纯文本查看 复制代码</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="680" height="97" alt="image" src="整合_files/Image_026.png"/></span></p><p class="s14" style="padding-top: 5pt;padding-left: 43pt;text-indent: 0pt;text-align: left;">&lt;dubbo:service retries=&quot;2&quot; cluster=&quot;failover&quot;/&gt;</p><p class="s18" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">或：</p><p class="s14" style="padding-left: 70pt;text-indent: 0pt;line-height: 108%;text-align: left;">&lt;dubbo:reference retries=&quot;2&quot; cluster=&quot;failover&quot;/&gt; cluster=&quot;failover&quot;<span class="s18">可以不用写</span>,<span class="s18">因为默认就是 </span>failover</p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-top: 7pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">1</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">2</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">3</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">4</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://bbs.itheima.com/" class="s16">?</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l Failfast Cluster</p><p class="s17" style="padding-top: 3pt;padding-left: 23pt;text-indent: 18pt;text-align: left;">快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p><p class="s12" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">[AppleScript] <span class="s13">纯文本查看 复制代码</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="680" height="97" alt="image" src="整合_files/Image_027.png"/></span></p><p class="s14" style="padding-top: 5pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">dubbo:service cluster=&quot;failfast&quot; /&gt;</p><p class="s18" style="padding-top: 1pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">或：</p><p class="s14" style="padding-left: 56pt;text-indent: 0pt;text-align: left;">&lt;dubbo:reference cluster=&quot;failfast&quot; /&gt;</p><p class="s14" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">cluster=&quot;failfast&quot;<span class="s18">和 把 </span>cluster=&quot;failover&quot;<span class="s18">、</span>retries=&quot;0&quot;<span class="s18">是一样的效果</span>,retries=&quot;0&quot;<span class="s18">就是不重试</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s15" style="padding-top: 7pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">1</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">2</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">3</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">4</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://bbs.itheima.com/" class="s16">?</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l Failsafe Cluster</p><p class="s17" style="padding-top: 3pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p><p class="s12" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">[AppleScript] <span class="s13">纯文本查看 复制代码</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://bbs.itheima.com/" class="s16">?</a></p><p style="text-indent: 0pt;text-align: left;"><span><img width="680" height="1" alt="image" src="整合_files/Image_028.png"/></span></p><p class="s15" style="padding-top: 7pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">1</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">2</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">3</p><p style="text-indent: 0pt;text-align: left;"/><p class="s14" style="padding-top: 5pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">&lt;dubbo:service cluster=&quot;failsafe&quot; /&gt;</p><p class="s18" style="padding-top: 1pt;padding-left: 99pt;text-indent: 0pt;text-align: left;">或：</p><p style="text-indent: 0pt;text-align: left;"><span><img width="680" height="1" alt="image" src="整合_files/Image_029.png"/></span></p><p class="s14" style="padding-left: 99pt;text-indent: 0pt;text-align: left;">&lt;dubbo:reference cluster=&quot;failsafe&quot; /&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l Failback Cluster</p><p class="s17" style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p><p class="s12" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">[AppleScript] <span class="s13">纯文本查看 复制代码</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="680" height="1" alt="image" src="整合_files/Image_030.png"/></span></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://bbs.itheima.com/" class="s16">?</a></p><p class="s15" style="padding-top: 7pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">1</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">2</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">3</p><p style="text-indent: 0pt;text-align: left;"/><p class="s14" style="padding-top: 9pt;padding-left: 71pt;text-indent: 0pt;text-align: left;">&lt;dubbo:service cluster=&quot;failback&quot; /&gt;</p><p class="s18" style="padding-top: 1pt;padding-left: 98pt;text-indent: 0pt;text-align: left;">或：</p><p style="text-indent: 0pt;text-align: left;"><span><img width="680" height="1" alt="image" src="整合_files/Image_031.png"/></span></p><p class="s14" style="padding-left: 98pt;text-indent: 0pt;text-align: left;">&lt;dubbo:reference cluster=&quot;failback&quot; /&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">l Forking Cluster</p><p class="s17" style="padding-top: 3pt;padding-left: 23pt;text-indent: 18pt;text-align: left;">并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot;来设置最大并行数。</p><p class="s12" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">[AppleScript] <span class="s13">纯文本查看 复制代码</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="680" height="1" alt="image" src="整合_files/Image_032.png"/></span></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://bbs.itheima.com/" class="s16">?</a></p><p class="s15" style="padding-top: 7pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">1</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">2</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">3</p><p style="text-indent: 0pt;text-align: left;"/><p class="s14" style="padding-top: 9pt;padding-left: 65pt;text-indent: 0pt;text-align: left;">&lt;dubbo:service cluster=“forking&quot; forks=&quot;2&quot;/&gt;</p><p class="s18" style="padding-top: 1pt;padding-left: 92pt;text-indent: 0pt;text-align: left;">或：</p><p style="text-indent: 0pt;text-align: left;"><span><img width="680" height="1" alt="image" src="整合_files/Image_033.png"/></span></p><p class="s14" style="padding-left: 92pt;text-indent: 0pt;text-align: left;">&lt;dubbo:reference cluster=“forking&quot; forks=&quot;2&quot;/&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">l <span class="s10">配置</span></p><p class="s12" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">[AppleScript] <span class="s13">纯文本查看 复制代码</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="680" height="1" alt="image" src="整合_files/Image_034.png"/></span></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://bbs.itheima.com/" class="s16">?</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s15" style="padding-top: 7pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">1</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">2</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">3</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">4</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">5</p><p class="s15" style="padding-top: 5pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">6</p><p style="text-indent: 0pt;text-align: left;"/><p class="s18" style="padding-top: 3pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">服务端服务级别</p><p class="s14" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">&lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</p><p class="s18" style="padding-top: 1pt;padding-left: 64pt;text-indent: 0pt;text-align: left;">客户端服务级别</p><p class="s14" style="padding-left: 88pt;text-indent: 0pt;text-align: left;">&lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&gt;</p><p class="s18" style="padding-top: 1pt;text-indent: 0pt;text-align: right;">服务端方法级别   <span class="s14">&lt;dubbo:service interface=&quot;...&quot;&gt; &lt;dubbo:method name=&quot;...&quot; loadbalanc</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="680" height="1" alt="image" src="整合_files/Image_035.png"/></span></p><p class="s18" style="text-indent: 0pt;text-align: right;">客户端方法级别   <span class="s14">&lt;dubbo:reference interface=&quot;...&quot;&gt; &lt;dubbo:method name=&quot;...&quot; loadbalance=</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l13"><li data-list-text="1."><p class="s8" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">dubbo <span class="s9">通信协议 </span>dubbo <span class="s9">协议为什么要消费者比提供者个数多：</span></p><p class="s10" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">因 <span class="s11">dubbo </span>协议采用单一长连接，假设网络为千兆网卡<span class="s11">(1024Mbit=128MByte)</span>，</p><p class="s10" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">根据测试经验数据每条连接最多只能压满 <span class="s11">7MByte(</span>不同的环境可能不一样，供参考<span class="s11">)</span>，理论上 <span class="s11">1 </span>个服务提供者需要 <span class="s11">20</span></p><p class="s10" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">个服务消费者才能压满网卡。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s8" style="padding-top: 1pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">dubbo <span class="s9">通信协议 </span>dubbo <span class="s9">协议为什么不能传大包：</span></p><p class="s10" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">因 <span class="s11">dubbo </span>协议采用单一长连接，</p><p class="s10" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 152%;text-align: left;">如果每次请求的数据包大小为 <span class="s11">500KByte</span>，假设网络为千兆网卡<span class="s11">(1024Mbit=128MByte)</span>，每条连接最大 <span class="s11">7MByte(</span>不同的环境可能不一样，供参考<span class="s11">)</span>，</p><p class="s10" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">单个服务提供者的 <span class="s11">TPS(</span>每秒处理事务数<span class="s11">)</span>最大为：<span class="s11">128MByte / 500KByte = 262</span>。</p><p class="s10" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">单个消费者调用单个服务提供者的 <span class="s11">TPS(</span>每秒处理事务数<span class="s11">)</span>最大为：<span class="s11">7MByte / 500KByte = 14</span>。</p><p class="s10" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">如果能接受，可以考虑使用，否则网络将成为瓶颈。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s8" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">dubbo <span class="s9">通信协议 </span>dubbo <span class="s9">协议为什么采用异步单一长连接：</span><span class="s10">因为服务的现状大都是服务提供者少，通常只有几台机器， 而服务的消费者多，可能整个网站都在访问该服务，</span></p><p class="s10" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 152%;text-align: left;">比如 <span class="s11">Morgan </span>的提供者只有 <span class="s11">6 </span>台提供者，却有上百台消费者，每天有 <span class="s11">1.5 </span>亿次调用，如果采用常规的 <span class="s11">hessian </span>服务，服务提供者很容易就被压跨，</p><p class="s10" style="padding-left: 23pt;text-indent: 0pt;line-height: 152%;text-align: left;">通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，</p><p class="s10" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">并使用异步 <span class="s11">IO</span>，复用线程池，防止 <span class="s11">C10K </span>问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s8" style="padding-top: 6pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">dubbo <span class="s9">通信协议 </span>dubbo <span class="s9">协议适用范围和适用场景</span></p><p class="s19" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">适用范围：传入传出参数数据包较小（建议小于 100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">适用场景：常规远程服务方法调用</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">dubbo 协议补充：</p><p class="s10" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 152%;text-align: justify;">连接个数：单连接连接方式：长连接传输协议：<span class="s11">TCP</span></p><p class="s10" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">传输方式：<span class="s11">NIO </span>异步传输</p><p class="s10" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">序列化：<span class="s11">Hessian </span>二进制序列化</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5."><p class="s8" style="padding-top: 6pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">RMI <span class="s9">协议</span></p><p class="s19" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">RMI 协议采用 JDK 标准的 java.rmi.*实现，采用阻塞式短连接和 JDK 标准序列化方式，Java 标准的远程调用协议。</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">连接个数：多连接连接方式：短连接传输协议：TCP</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">传输方式：同步传输</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">序列化：Java 标准二进制序列化</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">适用场景：常规远程服务方法调用，与原生 RMI 服务互操作</p></li><li data-list-text="6."><p class="s8" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">Hessian <span class="s9">协议</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Hessian 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">基于 Hessian 的远程调用协议。连接个数：多连接</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">连接方式：短连接传输协议：HTTP</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">传输方式：同步传输</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">序列化：Hessian 二进制序列化</p><p class="s19" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">适用范围：传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">适用场景：页面传输，文件传输，或与原生 hessian 服务互操作</p></li><li data-list-text="7."><p class="s8" style="padding-top: 3pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">http</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">采用 Spring 的 HttpInvoker 实现基于 http 表单的远程调用协议。连接个数：多连接</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">连接方式：短连接传输协议：HTTP</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">传输方式：同步传输</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">序列化：表单序列化（JSON）</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或 URL 传入参数，暂不支持传文件。</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">适用场景：需同时给应用程序和浏览器 JS 使用的服务。</p></li><li data-list-text="8."><p class="s8" style="padding-top: 3pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">Webservice</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">基于 CXF 的 frontend-simple 和 transports-http 实现基于 WebService 的远程调用协议。</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">连接个数：多连接连接方式：短连接传输协议：HTTP</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">传输方式：同步传输</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">序列化：SOAP 文本序列化</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">适用场景：系统集成，跨语言调用。</p></li><li data-list-text="9."><p class="s8" style="padding-top: 3pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">Thrif</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Thrift 是 Facebook 捐给 Apache 的一个 RPC 框架，当前 dubbo 支持的 thrift协议是对 thrift 原生协议的扩展，在原生协议的基础上添加了一些额外的头信息，比如 service name，magic number 等</p><p class="s20" style="padding-left: 23pt;text-indent: 0pt;line-height: 20pt;text-align: left;">Dubbo <span class="s21">支持哪些协议，每种协议的应用场景，优缺点？</span></p><ul id="l14"><li data-list-text=""><p class="s22" style="padding-top: 4pt;padding-left: 56pt;text-indent: -18pt;line-height: 90%;text-align: left;"><span class="s20">dubbo</span><span class="s21">： </span>单一长连接和 <span class="s23">NIO </span>异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 <span class="s23">TCP</span>，异步，<span class="s23">Hessian </span>序列化；</p></li><li data-list-text=""><p class="s22" style="padding-left: 56pt;text-indent: -18pt;line-height: 18pt;text-align: left;"><span class="s20">rmi</span><span class="s21">： </span>采用 <span class="s23">JDK </span>标准的 <span class="s23">rmi </span>协议实现，传输参数和返回参数对象需要实现</p><p class="s23" style="padding-left: 56pt;text-indent: 0pt;line-height: 14pt;text-align: left;">Serializable <span class="s22">接口，使用 </span>java <span class="s22">标准序列化机制，使用阻塞式短连接，传输数</span></p><p class="s22" style="padding-left: 56pt;text-indent: 0pt;line-height: 106%;text-align: left;">据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 <span class="s23">TCP</span>。多个短连接，<span class="s23">TCP </span>协议传输，同步传输，适用常规的远程服务调用和 <span class="s23">rmi </span>互操作。在依赖低版本的 <span class="s23">Common-Collections </span>包，<span class="s23">java </span>序列化存在安全漏 洞；</p></li><li data-list-text=""><p class="s22" style="padding-left: 56pt;text-indent: -18pt;line-height: 16pt;text-align: left;"><span class="s20">webservice</span><span class="s21">： </span>基于 <span class="s23">WebService </span>的远程调用协议，集成 <span class="s23">CXF </span>实现，提供和</p><p class="s22" style="padding-left: 56pt;text-indent: 0pt;line-height: 14pt;text-align: left;">原生 <span class="s23">WebService </span>的互操作。多个短连接，基于 <span class="s23">HTTP </span>传输，同步传输，适</p><p class="s22" style="padding-left: 56pt;text-indent: 0pt;line-height: 13pt;text-align: left;">用系统集成和跨语言调用；</p></li><li data-list-text=""><p class="s22" style="padding-left: 56pt;text-indent: -18pt;line-height: 90%;text-align: left;"><span class="s20">http</span><span class="s21">： </span>基于 <span class="s23">Http </span>表单提交的远程调用协议，使用 <span class="s23">Spring </span>的 <span class="s23">HttpInvoke </span>实现。多个短连接，传输协议 <span class="s23">HTTP</span>，传入参数大小混合，提供者个数多于消</p><p class="s22" style="padding-top: 1pt;padding-left: 56pt;text-indent: 0pt;line-height: 13pt;text-align: left;">费者，需要给应用程序和浏览器 <span class="s23">JS </span>调用；</p></li><li data-list-text=""><p class="s22" style="padding-left: 56pt;text-indent: -18pt;line-height: 90%;text-align: left;"><span class="s20">hessian</span><span class="s21">： </span>集成 <span class="s23">Hessian </span>服务，基于 <span class="s23">HTTP </span>通讯，采用 <span class="s23">Servlet </span>暴露服务， <span class="s23">Dubbo </span>内嵌 <span class="s23">Jetty </span>作为服务器时默认实现，提供与 <span class="s23">Hession </span>服务互操作。多</p><p class="s22" style="padding-top: 1pt;padding-left: 56pt;text-indent: 0pt;line-height: 106%;text-align: left;">个短连接，同步 <span class="s23">HTTP </span>传输，<span class="s23">Hessian </span>序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；</p></li><li data-list-text=""><p class="s22" style="padding-left: 56pt;text-indent: -18pt;line-height: 15pt;text-align: left;"><span class="s20">memcache</span><span class="s21">： </span>基于 <span class="s23">memcached </span>实现的 <span class="s23">RPC </span>协议</p></li><li data-list-text=""><p class="s22" style="padding-left: 56pt;text-indent: -18pt;line-height: 18pt;text-align: left;"><span class="s20">redis</span><span class="s21">： </span>基于 <span class="s23">redis </span>实现的 <span class="s23">RPC </span>协议</p><p class="s20" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo <span class="s21">超时时间怎样设置？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s24" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">Dubbo <span class="s25">超时时间设置有两种方式：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s22" style="padding-left: 56pt;text-indent: -18pt;line-height: 106%;text-align: left;">服务提供者端设置超时时间，在 <span class="s23">Dubbo </span>的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。</p></li><li data-list-text=""><p class="s22" style="padding-left: 56pt;text-indent: -18pt;line-height: 106%;text-align: justify;">服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。</p><p class="s20" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo <span class="s21">有些哪些注册中心？</span></p></li><li data-list-text=""><p class="s20" style="padding-top: 4pt;padding-left: 56pt;text-indent: -18pt;line-height: 90%;text-align: justify;">Multicast <span class="s21">注册中心： </span><span class="s23">Multicast </span><span class="s22">注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现；</span></p></li><li data-list-text=""><p class="s22" style="padding-left: 56pt;text-indent: -18pt;line-height: 18pt;text-align: left;"><span class="s20">Zookeeper </span><span class="s21">注册中心： </span>基于分布式协调系统 <span class="s23">Zookeeper </span>实现，采用</p><p class="s23" style="padding-left: 56pt;text-indent: 0pt;line-height: 12pt;text-align: left;">Zookeeper <span class="s22">的 </span>watch <span class="s22">机制实现数据变更；</span></p></li><li data-list-text=""><p class="s22" style="padding-left: 56pt;text-indent: -18pt;line-height: 90%;text-align: left;"><span class="s20">redis </span><span class="s21">注册中心： </span>基于 <span class="s23">redis </span>实现，采用 <span class="s23">key/Map </span>存储，住 <span class="s23">key </span>存储服务名和类型，<span class="s23">Map </span>中 <span class="s23">key </span>存储服务 <span class="s23">URL</span>，<span class="s23">value </span>服务过期时间。基于 <span class="s23">redis </span>的发</p><p class="s22" style="padding-top: 1pt;padding-left: 56pt;text-indent: 0pt;line-height: 13pt;text-align: left;">布<span class="s23">/</span>订阅模式通知数据变更；</p></li><li data-list-text=""><p class="s20" style="padding-left: 56pt;text-indent: -18pt;line-height: 20pt;text-align: left;">Simple <span class="s21">注册中心</span></p><p class="s20" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo <span class="s21">集群的负载均衡有哪些策略</span></p><p class="s24" style="padding-top: 3pt;padding-left: 36pt;text-indent: 0pt;text-align: left;">Dubbo <span class="s25">提供了常见的集群策略实现，并预扩展点予以自行实现。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s20" style="padding-left: 56pt;text-indent: -18pt;line-height: 106%;text-align: left;">Random LoadBalance: <span class="s22">随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；</span></p></li><li data-list-text=""><p class="s20" style="padding-left: 56pt;text-indent: -18pt;line-height: 106%;text-align: left;">RoundRobin LoadBalance: <span class="s22">轮循选取提供者策略，平均分布，但是存在请求累积的问题；</span></p></li><li data-list-text=""><p class="s20" style="padding-left: 56pt;text-indent: -18pt;line-height: 106%;text-align: left;">LeastActive LoadBalance: <span class="s22">最少活跃调用策略，解决慢提供者接收更少的请求；</span></p></li><li data-list-text=""><p class="s22" style="padding-left: 56pt;text-indent: -18pt;line-height: 106%;text-align: justify;"><span class="s20">ConstantHash LoadBalance: </span>一致性 <span class="s23">Hash </span>策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s26" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">Dubbo 是什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s27" style="padding-left: 59pt;text-indent: -18pt;line-height: 125%;text-align: left;">Dubbo 是一个分布式、高性能、透明化的 RPC 服务框架，提供服务自动注册、自动发现等高效服务治理方案， 可以和 Spring 框架无缝集成。</p></li><li data-list-text=""><p class="s26" style="padding-top: 13pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">Dubbo 的主要应用场景？</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s27" style="padding-left: 59pt;text-indent: -18pt;line-height: 125%;text-align: left;">透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何 API 侵入。</p></li><li data-list-text=""><p class="s27" style="padding-top: 13pt;padding-left: 59pt;text-indent: -18pt;line-height: 125%;text-align: left;">软负载均衡及容错机制，可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。</p></li><li data-list-text=""><p class="s27" style="padding-top: 13pt;padding-left: 59pt;text-indent: -18pt;line-height: 125%;text-align: left;">服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的 IP 地址，并且能够平滑添加或删除服务提供者。</p></li></ul></li></ol><p class="s26" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 的核心功能？</p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">主要就是如下 3 个核心功能：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l15"><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">Remoting：<span class="s27">网络通信框架，提供对多种 NIO 框架抽象封装，包括 “同步转异步”和“请求-响应”模式的信息交换方式。</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">Cluster：服务框架<span class="s27">，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: justify;">Registry：服务注册<span class="s27">，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</span></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><ul id="l16"><li data-list-text=""><p class="s26" style="padding-top: 13pt;padding-left: 59pt;text-indent: -18pt;text-align: justify;">Dubbo 的核心组件？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s28" style="padding-left: 41pt;text-indent: 0pt;text-align: left;"></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 服务注册与发现的流程？</p><p style="padding-left: 78pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">流程说明：</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li data-list-text=""><p class="s27" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">Provider(提供者)绑定指定端口并启动服务</p></li><li data-list-text=""><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">指供者连接注册中心，并发本机 IP、端口、应用信息和提供服务信息发送至注册中心存储</p></li><li data-list-text=""><p class="s27" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">Consumer(消费者），连接注册中心 ，并发送应用信息、所求服务信息至注册中心</p></li><li data-list-text=""><p class="s27" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">注册中心根据 消费 者所求服务信息匹配对应的提供者列表发送至</p><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Consumer 应用缓存。</p></li><li data-list-text=""><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调用。</p></li><li data-list-text=""><p class="s27" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">Provider 状态变更会实时通知注册中心、在由注册中心实时推送至</p><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Consumer</p><p class="s26" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">设计的原因：</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s27" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">Consumer 与 Provider 解偶，双方都可以横向增减节点数。</p></li><li data-list-text=""><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台</p></li><li data-list-text=""><p class="s27" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">去中心化，双方不直接依懒注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用</p></li><li data-list-text=""><p class="s27" style="padding-bottom: 4pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">服务提供者无状态，任意一台宕掉后，不影响使用</p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p class="s26" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 的架构设计？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 框架设计一共划分了 10 个层：</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">服务接口层（Service）<span class="s27">：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">配置层（Config）<span class="s27">：对外配置接口，以 ServiceConfig 和</span></p><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">ReferenceConfig 为中心。</p></li><li data-list-text=""><p class="s26" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">服务代理层（Proxy<span class="s27">）：服务接口透明代理，生成服务的客户端 Stub</span></p><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">和服务器端 Skeleton。</p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">服务注册层（Registry）<span class="s27">：封装服务地址的注册与发现，以服务 URL</span></p><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">为中心。</p></li><li data-list-text=""><p class="s26" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">集群层（Cluster）<span class="s27">：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心。</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">监控层（Monitor）<span class="s27">：RPC 调用次数和调用时间监控。</span></p></li><li data-list-text=""><p class="s26" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">远程调用层（Protocol）<span class="s27">：封将 RPC 调用，以 Invocation 和 Result</span></p><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">为中心，扩展接口为 Protocol、Invoker 和 Exporter。</p></li><li data-list-text=""><p class="s26" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">信息交换层（Exchange）<span class="s27">：封装请求响应模式，同步转异步，以</span></p><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Request 和 Response 为中心。</p></li><li data-list-text=""><p class="s26" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">网络传输层（Transport）<span class="s27">：抽象 mina 和 netty 为统一接口，以 Message 为中心。</span></p><p class="s26" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 的服务调用流程？</p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 支持哪些协议，每种协议的应用场景，优缺点？</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: justify;">dubbo： <span class="s27">单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步，Hessian 序列化；</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: justify;">rmi： <span class="s27">采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，</span></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;line-height: 125%;text-align: justify;">传输协议 TCP。 多个短连接，TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互操作。在依赖低版本的 Common-Collections包，java 序列化存在安全漏洞；</p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: justify;">webservice： <span class="s27">基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用；</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">http： <span class="s27">基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用；</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">hessian： <span class="s27">集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">memcache： <span class="s27">基于 memcached 实现的 RPC 协议</span></p></li><li data-list-text=""><p class="s26" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">redis： <span class="s27">基于 redis 实现的 RPC 协议</span></p><p class="s26" style="padding-top: 6pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">dubbo 推荐用什么协议？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">默认使用 dubbo 协议</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Dubbo 有些哪些注册中心？</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">Multicast 注册中心： <span class="s27">Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现；</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: justify;">Zookeeper 注册中心： <span class="s27">基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 watch 机制实现数据变更；</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: justify;">redis 注册中心： <span class="s27">基于 redis 实现，采用 key/Map 存储，住 key 存储服务名和类型，Map 中 key 存储服务 URL，value 服务过期时间。基于 redis 的发布/订阅模式通知数据变更；</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;text-align: justify;">Simple 注册中心</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 默认采用注册中心？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">采用 Zookeeper</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">为什么需要服务治理？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s27" style="padding-top: 1pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">过多的服务 URL 配置困难</p></li><li data-list-text=""><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">负载均衡分配节点压力过大的情况下也需要部署集群</p></li><li data-list-text=""><p class="s27" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">服务依赖混乱，启动顺序不清晰</p></li><li data-list-text=""><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">过多服务导致性能指标分析难度较大，需要监控</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;line-height: 125%;text-align: left;">可以的，启动 dubbo 时，消费者会从 zookeeper 拉取注册的生产者的地址接口等数据，缓存在本地。</p><p class="s27" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">每次调用时，按照本地存储的地址进行调用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 与 Spring 的关系？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;line-height: 125%;text-align: left;">Dubbo 采用全 Spring 配置方式，透明化接入应用，对应用没有任何 API 侵入，只需用 Spring 加载 Dubbo 的配置即可，Dubbo 基于 Spring 的 Schema 扩展进行加载。</p><p class="s26" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 使用的是什么通信框架?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">默认使用 NIO Netty 框架</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 集群提供了哪些负载均衡策略？</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">Random LoadBalance: <span class="s27">随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀；</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">RoundRobin LoadBalance: <span class="s27">轮循选取提供者策略，平均分布，但是存在请求累积的问题；</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: justify;">LeastActive LoadBalance: <span class="s27">最少活跃调用策略，解决慢提供者接收更少的请求；</span></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: justify;">ConstantHash LoadBalance: <span class="s27">一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；</span></p><p class="s27" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">缺省时为 Random 随机调用</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Dubbo 的集群容错方案有哪些？</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">Failover Cluster</p></li><li data-list-text=""><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。</p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">Failfast Cluster</p></li><li data-list-text=""><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">Failsafe Cluster</p></li><li data-list-text=""><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p></li><li data-list-text=""><p class="s26" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">Failback Cluster</p></li><li data-list-text=""><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">Forking Cluster</p></li><li data-list-text=""><p class="s27" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。</p></li><li data-list-text=""><p class="s26" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">Broadcast Cluster</p></li><li data-list-text=""><p class="s27" style="padding-top: 6pt;padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: left;">广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><p class="s26" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 的默认集群容错方案？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Failover Cluster</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 支持哪些序列化方式？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;line-height: 125%;text-align: left;">默认使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。</p><p class="s26" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 超时时间怎样设置？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 超时时间设置有两种方式：</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s27" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: justify;">服务提供者端设置超时时间，在 Dubbo 的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。</p></li><li data-list-text=""><p class="s27" style="padding-left: 23pt;text-indent: -18pt;line-height: 125%;text-align: justify;">服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。</p></li></ul><p class="s26" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">服务调用超时问题怎么解决？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">dubbo 在调用服务不成功时，默认是会重试两次的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 在安全机制方面是如何解决？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;line-height: 125%;text-align: left;">Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo 还提供服务黑白名单，来控制服务所允许的调用方。</p><p class="s26" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 和 Dubbox 之间的区别？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;line-height: 125%;text-align: left;">dubbox 基于 dubbo 上做了一些扩展，如加了服务可 restful 调用，更新了开源组件等。</p><p class="s26" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 和 Spring Cloud 的关系？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 23pt;text-indent: 0pt;line-height: 125%;text-align: left;">Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spirng、 Spirng Boot 的优势之上，两个框架在开始目标就不一致，Dubbo定位服务治理、Spirng Cloud 是一个生态。</p><p class="s26" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Dubbo 和 Spring Cloud 的区别？</p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 125%;text-align: left;">最大的区别：Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于 TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。</p><p class="s27" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;line-height: 125%;text-align: left;">而 SpringCloud 是基于 Http 协议+Rest 接口调用远程过程的通信，相对来说，Http 请求会有更大的报文，占的带宽也会更多。但是 REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="83" height="33" alt="image" src="整合_files/Image_043.png"/></span></p><p class="s29" style="padding-top: 1pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">java</p><p style="text-indent: 0pt;text-align: left;"/><h2 style="padding-bottom: 1pt;padding-left: 68pt;text-indent: 0pt;line-height: 39pt;text-align: left;"><a name="bookmark0">后端面试题答案</a><span class="s30">&lt;1&gt;</span></h2><p style="padding-left: 6pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="654" height="1" alt="image" src="整合_files/Image_044.png"/></span></p><p class="s31" style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">说明：以下所有答案均为个人的理解和网上的一些资料的整合</p><p style="text-indent: 0pt;text-align: left;"><span><img width="58" height="23" alt="image" src="整合_files/Image_045.png"/></span></p><p class="s32" style="padding-left: 3pt;text-indent: 0pt;line-height: 15pt;text-align: left;">List</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="46" height="23" alt="image" src="整合_files/Image_046.png"/></span></p><p class="s32" style="padding-left: 3pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Set</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: center;"><a name="bookmark1">和</a></p><p style="text-indent: 0pt;text-align: left;"><span><img width="72" height="15" alt="image" src="整合_files/Image_047.png"/></span></p><p class="s34" style="padding-top: 1pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">List <span class="s35">, </span>Set</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="81" height="15" alt="image" src="整合_files/Image_048.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">Collection</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 6pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">都是继承自</p><p class="s33" style="padding-top: 5pt;text-indent: 0pt;text-align: left;">的区别</p><p class="s36" style="padding-top: 6pt;text-indent: 0pt;text-align: right;">接口</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_049.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">List</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">特点：元素有放入顺序，元素可重复 ，</p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_050.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_051.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">Object</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_052.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">equals</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 10pt;text-indent: 0pt;text-align: left;"><span class="s34">Set </span>特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是元素在<span class="s35">set</span>中的位</p><p style="text-indent: 0pt;text-align: left;"><span><img width="66" height="15" alt="image" src="整合_files/Image_053.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">HashCode</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">置是有该元素的</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">决定的，其位置其实是固定的，加入<span class="s35">Set </span>的</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">必须定义</p><p class="s35" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">()<span class="s36">方法 ，另外</span>list</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: left;">支持<span class="s35">for</span>循环，也就是通过下标来遍历，也可以用迭代器，但是<span class="s35">set</span>只能用迭代，因为他无序，无法用下标来取得想要的值。）  <span class="s37">Set</span><span style=" color: #008000;">和</span><span class="s37">List</span><span style=" color: #008000;">对比  </span><span class="s35">Set</span>：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。  <span class="s35">List</span>：和数组类似，<span class="s35">List</span>可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</p><p style="text-indent: 0pt;text-align: left;"><span><img width="95" height="23" alt="image" src="整合_files/Image_054.png"/></span></p><p class="s32" style="padding-left: 3pt;text-indent: 0pt;line-height: 15pt;text-align: left;">HashSet</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="53" height="15" alt="image" src="整合_files/Image_055.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">equles</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 5pt;padding-left: 81pt;text-indent: 0pt;text-align: left;"><a name="bookmark2">是如何保证不重复的</a></p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_056.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_057.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_058.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">add</p><p class="s34" style="padding-top: 7pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">add</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_059.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">add</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_060.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">HashSet</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">向 <span class="s34">HashSet </span>中</p><p class="s35" style="padding-top: 6pt;text-indent: 0pt;text-align: left;">()<span class="s36">元素时，判断元素是否存在的依据，不仅要比较</span>hash<span class="s36">值，同时还要结合</span></p><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">方法比较。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_061.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">HashSet</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_062.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">HashMap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 50pt;text-indent: 0pt;line-height: 16pt;text-align: left;">中的  <span class="s35">()</span>方法会使用</p><p class="s36" style="padding-left: 42pt;text-indent: 0pt;line-height: 16pt;text-align: left;">的  <span class="s35">()</span>方法。以下是</p><p class="s36" style="padding-left: 42pt;text-indent: 0pt;line-height: 16pt;text-align: left;">部分源码：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="159" alt="image" src="整合_files/Image_063.png"/></span></p><p class="s41" style="padding-top: 7pt;padding-left: 13pt;text-indent: 0pt;line-height: 159%;text-align: left;"><span style=" color: #770087;">private static final </span><span style=" color: #008754;">Object </span>PRESENT <span style=" color: #971A1A;">= </span><span style=" color: #770087;">new </span><span style=" color: #008754;">Object</span><span style=" color: #333;">(); </span><span style=" color: #770087;">private transient </span>HashMap<span style=" color: #971A1A;">&lt;</span>E<span style=" color: #333;">,</span><span style=" color: #008754;">Object</span><span style=" color: #971A1A;">&gt; </span>map<span style=" color: #333;">;</span></p><p class="s39" style="padding-left: 13pt;text-indent: 0pt;line-height: 9pt;text-align: left;">public <span style=" color: #000;">HashSet</span><span style=" color: #333;">() {</span></p><p class="s41" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">map <span style=" color: #971A1A;">= </span><span style=" color: #770087;">new </span>HashMap<span style=" color: #971A1A;">&lt;&gt;</span><span style=" color: #333;">();</span></p><p class="s34" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">}</p><p class="s34" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;"><span style=" color: #770087;">public </span><span style=" color: #008754;">boolean </span><span style=" color: #00F;">add</span>(<span style=" color: #000;">E e</span>) {</p><p class="s34" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;text-align: left;"><span style=" color: #770087;">return </span><span style=" color: #000;">map</span>.<span style=" color: #000;">put</span>(<span style=" color: #000;">e</span>, <span style=" color: #000;">PRESENT</span>)<span style=" color: #971A1A;">==</span><span style=" color: #211199;">null</span>;</p><p class="s34" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_064.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_065.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="60" height="15" alt="image" src="整合_files/Image_066.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_067.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">HashMap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="67" height="15" alt="image" src="整合_files/Image_068.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">hashcode</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_069.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">equals</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 2pt;padding-left: 10pt;text-indent: 0pt;text-align: left;"><span class="s34">HashMap </span>的 <span class="s34">key </span>是唯一的，由上面的代码可以看出 <span class="s34">HashSet </span>添加进去的值就是作为      的<span class="s35">key</span>。所以不会</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_070.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">HashMap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">重复（</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">比较<span class="s35">key</span>是否相等是先比较</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">在比较    ）。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="95" height="23" alt="image" src="整合_files/Image_071.png"/></span></p><p class="s32" style="padding-left: 3pt;text-indent: 0pt;line-height: 15pt;text-align: left;">HashMap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 9pt;padding-left: 6pt;text-indent: 75pt;line-height: 81%;text-align: left;"><a name="bookmark3">是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）</a><span class="s45">?</span></p><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">不是线程安全的；</p><p style="text-indent: 0pt;text-align: left;"><span><img width="32" height="15" alt="image" src="整合_files/Image_072.png"/></span></p><p class="s36" style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;line-height: 87%;text-align: left;">如果有两个线程<span class="s35">A</span>和<span class="s35">B</span>，都进行插入数据，刚好这两条不同的数据经过哈希计算后得到的哈希码是一样的，且该位置还没有其他的数据。所以这两个线程都会进入我在上面标记为<span class="s35">1</span>的代码中。假设一种情况，线程<span class="s35">A</span>通过<span class="s35">if</span>判断，该位置没有哈希冲突，进入了<span class="s35">if</span>语句，还没有进行数据插入，这时候    <span class="s34">CPU   </span>就把资源让给了线程<span class="s35">B</span>，线程<span class="s35">A</span>停在了<span class="s35">if</span>语句里面，线程<span class="s35">B</span>判断该位置没有哈希冲突（线程<span class="s35">A</span>的数据还没插入），也进入了<span class="s35">if</span>语句，线程<span class="s35">B</span>执行完后，轮到线程<span class="s35">A</span>执行，现在线程<span class="s35">A</span>直接在该位置插入而不用再判断。这时候，你会发现线程<span class="s35">A</span>把线程<span class="s35">B</span>插入的数据给覆盖了。发生了线</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_073.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">HashMap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">程不安全情况。本来在</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 17pt;text-align: left;">就直接给覆盖了。</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">中，发生哈希冲突是可以用链表法或者红黑树来解决的，但是在多线程中，可能</p><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: left;">上面所说的是一个图来解释可能更加直观。如下面所示，两个线程在同一个位置添加数据，后面添加的数据就覆盖住了前面添加的。</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><span></span></p><p class="s36" style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: left;">如果上述插入是插入到链表上，如两个线程都在遍历到最后一个节点，都要在最后添加一个数据，那么后面添加数据的线程就会把前面添加的数据给覆盖住。则</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 9pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s36" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">在扩容的时候也可能会导致数据不一致，因为扩容是从一个数组拷贝到另外一个数组。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="95" height="23" alt="image" src="整合_files/Image_076.png"/></span></p><p class="s32" style="padding-left: 3pt;text-indent: 0pt;line-height: 15pt;text-align: left;">HashMap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 5pt;padding-left: 81pt;text-indent: 0pt;text-align: left;"><a name="bookmark4">的扩容过程</a></p><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_077.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">fa</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值<span class="s35">(</span>知道这个阈字怎么念吗？不念  值，</p><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_078.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">yu</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">念 值四声<span class="s35">)---</span>即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_079.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">resize</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">扩容<span class="s35">(</span></p><p class="s35" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">)<span class="s36">就是重新计算容量，向</span></p><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">对象里不停的添加元素，而 <span class="s34">HashMap </span>对象内部的数组无法装载更</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_080.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">HashMap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_081.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_082.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="33" alt="image" src="整合_files/Image_083.png"/></span></p><p class="s41" style="padding-top: 7pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">HashMap hashMap<span style=" color: #971A1A;">=</span><span style=" color: #770087;">new </span>HashMap<span style=" color: #333;">(</span>cap<span style=" color: #333;">);</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 90%;text-align: left;">多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然  <span class="s34">Java </span>里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_084.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">cap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_085.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">hashMap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s35" style="padding-top: 2pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">=3<span class="s36">，</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_086.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">cap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_087.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">hashMap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s35" style="padding-top: 5pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">=4<span class="s36">，</span></p><p class="s36" style="padding-top: 2pt;padding-left: 29pt;text-indent: 0pt;line-height: 133%;text-align: left;">的容量为<span class="s35">4</span>；的容量为<span class="s35">4</span>；</p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_088.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">cap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_089.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">hashMap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s35" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">=5<span class="s36">，</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_090.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">cap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_091.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">hashMap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="32" height="15" alt="image" src="整合_files/Image_092.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">cap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s35" style="padding-top: 5pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">=9<span class="s36">，</span></p><p class="s36" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 133%;text-align: left;">的容量为<span class="s35">8</span>；的容量为<span class="s35">16</span>；</p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_093.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">cap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_094.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">cap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">如果   是<span class="s35">2</span>的<span class="s35">n</span>次方，则容量为</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">，否则为大于</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">的第一个<span class="s35">2</span>的<span class="s35">n</span>次方的数。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="95" height="23" alt="image" src="整合_files/Image_095.png"/></span></p><p class="s32" style="padding-left: 3pt;text-indent: 0pt;line-height: 15pt;text-align: left;">HashMap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s35" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark5">HashMap</a><span class="s36">结构图</span></p><ol id="l17"><ol id="l18"><li data-list-text="1.7"><p class="s33" style="padding-top: 5pt;padding-left: 25pt;text-indent: -24pt;text-align: left;">与 <span class="s45">1.8 </span>的 区别，说明 <span class="s45">1.8 </span>做了哪些优化，如何优化的？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 27pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_097.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">JDK1.7</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_098.png"/></span></p><p class="s36" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">在  及之前的版本中， <span class="s34">HashMap </span>又叫散列链表：基于一个数组以及多个链表的实现，<span class="s35">hash</span>值冲突的时候，</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">就将对应节点以链表的形式存储。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_099.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">JDK1.8</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="46" height="15" alt="image" src="整合_files/Image_100.png"/></span></p><p class="s36" style="padding-top: 5pt;padding-left: 45pt;text-indent: 0pt;text-align: left;">中，当同一个<span class="s35">hash</span>值（ <span class="s34">Table </span>上元素）的链表节点数不小于<span class="s35">8</span>时，将不再以单链表的形式存储了，会被</p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_101.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">JDK7</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_102.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">JDK8</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="60" height="15" alt="image" src="整合_files/Image_103.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">HashMap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">调整成一颗红黑树。这就是    与    中 实现的最大区别。</p><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">其下基于 <span class="s35">JDK1.7.0_80 </span>与 <span class="s35">JDK1.8.0_66 </span>做的分析</p><p class="s46" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">JDK1.7<span class="s47">中</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_104.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">Entry</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="66" height="15" alt="image" src="整合_files/Image_105.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">hashcode</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="109" height="15" alt="image" src="整合_files/Image_106.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">hash collision</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_107.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">key</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_108.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">Entry</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">使用一个</p><p class="s36" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">数组来存储数据，用<span class="s35">key</span>的</p><p class="s36" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">取模来决定<span class="s35">key</span>会被放到数组里的位置，如果      相</p><p style="text-indent: 0pt;text-align: left;"><span><img width="67" height="15" alt="image" src="整合_files/Image_109.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">hashcode</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="66" height="15" alt="image" src="整合_files/Image_110.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">hashcode</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">同，或者</p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_111.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">key</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 17pt;text-align: left;">格子里，这些</p><p class="s36" style="padding-left: 6pt;text-indent: 6pt;line-height: 90%;text-align: left;">取模后的结果相同（会形成一个链表。</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">），那么这些</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">会被定位到</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">数组的同一个</p><p style="text-indent: 0pt;text-align: left;"><span><img width="66" height="15" alt="image" src="整合_files/Image_112.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">hashcode</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="67" height="15" alt="image" src="整合_files/Image_113.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_114.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">put/get</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">在 特别差的情况下，比方说所有<span class="s35">key</span>的 <span class="s34">hashcode </span>都相同，这个链表可能会很长，那么 操作</p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_115.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">O(n)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">都可能需要遍历这个链表，也就是说时间复杂度在最差情况下会退化到</p><p class="s46" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">JDK1.8<span class="s47">中</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_116.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">Node</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">使用一个</p><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">数组来存储数据，但这个</p><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">可能是链表结构，也可能是红黑树结构</p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_117.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">Node</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="5" height="5" alt="image" src="整合_files/Image_118.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_119.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">key</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="66" height="15" alt="image" src="整合_files/Image_120.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">hashcode</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 6pt;padding-left: 28pt;text-indent: 0pt;text-align: left;">如果插入的  的</p><p class="s36" style="padding-top: 6pt;padding-left: 17pt;text-indent: 0pt;text-align: left;">相同，那么这些<span class="s35">key</span>也会被定位到</p><p class="s36" style="padding-top: 6pt;padding-left: 17pt;text-indent: 0pt;text-align: left;">数组的同一个格子里。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="39" height="15" alt="image" src="整合_files/Image_121.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">Node</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="5" height="5" alt="image" src="整合_files/Image_122.png"/></span></p><p class="s36" style="padding-left: 28pt;text-indent: 0pt;line-height: 15pt;text-align: left;">如果同一个格子里的<span class="s35">key</span>不超过<span class="s35">8</span>个，使用链表结构存储。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="5" height="5" alt="image" src="整合_files/Image_123.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="81" height="15" alt="image" src="整合_files/Image_124.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">treeifyBin</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 28pt;text-indent: 0pt;line-height: 15pt;text-align: left;">如果超过了<span class="s35">8</span>个，那么会调用 函数，将链表转换为红黑树。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="66" height="15" alt="image" src="整合_files/Image_125.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">hashcode</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">那么即使 完全相同，由于红黑树的特点，查找某个特定元素，也只需要<span class="s35">O(log n)</span>的开销</p><p style="text-indent: 0pt;text-align: left;"><span><img width="66" height="15" alt="image" src="整合_files/Image_126.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">O(log n)</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">也就是说<span class="s35">put/get</span>的操作的时间复杂度最差只有</p><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_127.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">JDK1.8</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">听起来挺不错，但是真正想要利用</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_128.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">Compare</p><p style="text-indent: 0pt;text-align: left;"/><p class="s35" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">key<span class="s36">的对象，必须正确的实现了</span></p><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 8pt;line-height: 133%;text-align: left;">的好处，有一个限制：接口</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_129.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">Compare</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">如果没有实现</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">接口，或者实现得不正确（比方说所有</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">方法都返回<span class="s35">0</span>）</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_130.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">Compare</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_131.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">JDK1.8</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_132.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">HashMap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="53" height="15" alt="image" src="整合_files/Image_133.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">JDK1.7</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">那     的 其实还是慢于     的</p><p class="s31" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">简单的测试数据如下：</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_134.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">HashMap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="81" height="15" alt="image" src="整合_files/Image_135.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">put/get 1w</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="136" height="15" alt="image" src="整合_files/Image_136.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">JDK1.7: put 0.26s</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">向     中</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_137.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">JDK1.8</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_138.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">Compare</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 45pt;text-indent: 0pt;text-align: left;">（未实现</p><p class="s36" style="padding-top: 5pt;text-indent: 0pt;text-align: center;">条</p><p style="text-indent: 0pt;text-align: left;"><span><img width="66" height="15" alt="image" src="整合_files/Image_139.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">hashcode</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="73" height="15" alt="image" src="整合_files/Image_140.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">get 0.55s</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;text-indent: 0pt;text-align: center;">，</p><p style="text-indent: 0pt;text-align: left;"><span><img width="74" height="15" alt="image" src="整合_files/Image_141.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">put 0.92s</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 103pt;text-indent: 0pt;text-align: center;">接口）：</p><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">相同的对象</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="66" height="15" alt="image" src="整合_files/Image_142.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">get 2.1s</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_143.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">JDK1.8</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="60" height="15" alt="image" src="整合_files/Image_144.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">HashMap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_145.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">put/get</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 39pt;text-indent: 0pt;text-align: left;">，</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_146.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">Compare</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 6pt;text-indent: 0pt;line-height: 17pt;text-align: right;">但是如果正确的实现了</p><p style="text-indent: 0pt;text-align: left;"><span><img width="66" height="15" alt="image" src="整合_files/Image_147.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">hashcode</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="60" height="15" alt="image" src="整合_files/Image_148.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">put/get</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_149.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">ms</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="text-indent: 0pt;line-height: 17pt;text-align: right;">相同的对象</p><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">接口，那么 中的</p><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">的性能有巨大提升，这次</p><p class="s35" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">100W<span class="s36">条</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_150.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">JDK1.8</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_151.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">Compare</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 45pt;text-indent: 0pt;text-align: left;">（正确实现</p><p class="s36" style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">接口，）：</p><p class="s36" style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">大概开销都在<span class="s35">320 </span>左右</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="276" height="23" alt="image" src="整合_files/Image_152.png"/></span></p><p class="s32" style="padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">final finally finalize</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="5" height="5" alt="image" src="整合_files/Image_153.png"/></span></p><p class="s35" style="padding-top: 4pt;padding-left: 28pt;text-indent: 0pt;line-height: 86%;text-align: left;"><a name="bookmark6">ﬁnal</a><span class="s36">可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="5" height="5" alt="image" src="整合_files/Image_154.png"/></span></p><p class="s35" style="padding-left: 28pt;text-indent: 0pt;line-height: 86%;text-align: left;">ﬁnally<span class="s36">一般作用在</span>try-catch<span class="s36">代码块中，在处理异常的时候，通常我们将一定要执行的代码方法</span>ﬁnally<span class="s36">代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="5" height="5" alt="image" src="整合_files/Image_155.png"/></span></p><p class="s35" style="padding-left: 28pt;text-indent: 0pt;line-height: 15pt;text-align: left;">ﬁnalize<span class="s36">是一个方法，属于</span>Object<span class="s36">类的一个方法，而</span>Object<span class="s36">类是所有类的父类，该方法一般由垃圾回收器来调</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="87" height="15" alt="image" src="整合_files/Image_156.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">System.gc()</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 28pt;text-indent: 0pt;line-height: 14pt;text-align: left;">用，当我们调用</p><p class="s36" style="padding-left: 28pt;text-indent: 0pt;line-height: 17pt;text-align: left;">最后判断。</p><p class="s33" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark7">对象的四种引用</a></p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">方法的时候，由垃圾回收器调用<span class="s35">ﬁnalize()</span>，回收垃圾，一个对象是否可回收的</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="51" alt="image" src="整合_files/Image_157.png"/></span></p><p class="s41" style="padding-top: 7pt;padding-left: 13pt;text-indent: 0pt;line-height: 159%;text-align: left;"><span style=" color: #008754;">Object </span>obj <span style=" color: #971A1A;">= </span><span style=" color: #770087;">new </span><span style=" color: #008754;">Object</span><span style=" color: #333;">(); </span>User user<span style=" color: #971A1A;">=</span><span style=" color: #770087;">new </span>User<span style=" color: #333;">();</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="183" height="15" alt="image" src="整合_files/Image_158.png"/></span></p><p class="s34" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">obj.equels(new Object())<span class="s48">;</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">可直接通过<span class="s35">obj</span>取得对应的对象 如</p><p class="s36" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">而这样</p><p class="s36" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">对象对后面</p><p class="s36" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">的一个强</p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_159.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">obj</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="81" height="15" alt="image" src="整合_files/Image_160.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">new Object</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_161.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">obj</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">引用，只有当 这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="87" alt="image" src="整合_files/Image_162.png"/></span></p><p class="s40" style="padding-top: 7pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">Object <span style=" color: #000;">obj </span><span style=" color: #971A1A;">= </span><span style=" color: #770087;">new </span>Object<span style=" color: #333;">();</span></p><p class="s42" style="padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: #000;">SoftReference</span>&lt;<span style=" color: #008754;">Object</span>&gt; <span style=" color: #000;">sf </span>= <span style=" color: #770087;">new </span><span style=" color: #000;">SoftReference</span>&lt;<span style=" color: #008754;">Object</span>&gt;<span style=" color: #333;">(</span><span style=" color: #000;">obj</span><span style=" color: #333;">); </span><span style=" color: #000;">obj </span>= <span style=" color: #211199;">null</span><span style=" color: #333;">;</span></p><p class="s41" style="padding-left: 13pt;text-indent: 0pt;text-align: left;">sf<span style=" color: #333;">.</span>get<span style=" color: #333;">();</span><span style=" color: #AA5400;">//</span><span class="s50">有时候会返回</span><span style=" color: #AA5400;">null</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">软引用 <span class="s31">非必须引用，内存溢出之前进行回收</span><span class="s36">，可以通过以下代码实现</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s36" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: left;">这时候<span class="s35">sf</span>是对<span class="s35">obj</span>的一个软引用，通过<span class="s35">sf.get()</span>方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回<span class="s35">null</span>；    软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="105" alt="image" src="整合_files/Image_163.png"/></span></p><p class="s40" style="padding-top: 7pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">Object <span style=" color: #000;">obj </span><span style=" color: #971A1A;">= </span><span style=" color: #770087;">new </span>Object<span style=" color: #333;">();</span></p><p class="s42" style="padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: #000;">WeakReference</span>&lt;<span style=" color: #008754;">Object</span>&gt; <span style=" color: #000;">wf </span>= <span style=" color: #770087;">new </span><span style=" color: #000;">WeakReference</span>&lt;<span style=" color: #008754;">Object</span>&gt;<span style=" color: #333;">(</span><span style=" color: #000;">obj</span><span style=" color: #333;">); </span><span style=" color: #000;">obj </span>= <span style=" color: #211199;">null</span><span style=" color: #333;">;</span></p><p class="s41" style="padding-left: 13pt;text-indent: 0pt;line-height: 15pt;text-align: left;">wf<span style=" color: #333;">.</span>get<span style=" color: #333;">();</span><span style=" color: #AA5400;">//</span><span class="s50">有时候会返回</span><span style=" color: #AA5400;">null</span></p><p class="s41" style="padding-left: 13pt;text-indent: 0pt;line-height: 15pt;text-align: left;">wf<span style=" color: #333;">.</span>isEnQueued<span style=" color: #333;">();</span><span style=" color: #AA5400;">//</span><span class="s50">返回是否被垃圾回收器标记为即将回收的垃圾</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s47" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">弱引用 <span class="s31">第二次垃圾回收时回收</span><span class="s36">，可以通过如下代码实现</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s36" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: left;">弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回<span class="s35">null</span>。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的</p><p style="text-indent: 0pt;text-align: left;"><span><img width="80" height="15" alt="image" src="整合_files/Image_164.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">isEnQueued</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 66pt;text-indent: 0pt;line-height: 16pt;text-align: left;">方法返回对象是否被垃圾回收器标记。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="87" height="15" alt="image" src="整合_files/Image_165.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">ThreadLocal</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="285" alt="image" src="整合_files/Image_166.png"/></span></p><p class="s42" style="padding-top: 7pt;padding-left: 19pt;text-indent: -5pt;line-height: 159%;text-align: left;"><span style=" color: #770087;">public class </span><span style=" color: #00F;">ThreadLocal</span>&lt;<span style=" color: #000;">T</span>&gt; <span style=" color: #333;">{ </span><span style=" color: #770087;">static class </span><span style=" color: #00F;">ThreadLocalMap </span><span style=" color: #333;">{</span></p><p class="s39" style="padding-left: 56pt;text-indent: 0pt;line-height: 9pt;text-align: left;">static class <span style=" color: #00F;">Entry </span>extends <span style=" color: #000;">WeakReference</span><span style=" color: #971A1A;">&lt;</span><span style=" color: #000;">ThreadLocal</span><span style=" color: #971A1A;">&lt;?&gt;&gt; </span><span style=" color: #333;">{</span></p><p class="s49" style="padding-top: 5pt;padding-left: 77pt;text-indent: 0pt;line-height: 159%;text-align: left;">/** The value associated with this ThreadLocal. */ <span style=" color: #008754;">Object </span><span style=" color: #000;">value</span><span style=" color: #333;">;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-left: 98pt;text-indent: -21pt;line-height: 159%;text-align: left;">Entry<span style=" color: #333;">(</span>ThreadLocal<span style=" color: #971A1A;">&lt;?&gt; </span>k<span style=" color: #333;">, </span><span style=" color: #008754;">Object </span>v<span style=" color: #333;">) { </span><span style=" color: #770087;">super</span><span style=" color: #333;">(</span>k<span style=" color: #333;">);</span></p><p class="s41" style="padding-left: 98pt;text-indent: 0pt;line-height: 9pt;text-align: left;">value <span style=" color: #971A1A;">= </span>v<span style=" color: #333;">;</span></p><p class="s34" style="padding-top: 5pt;padding-left: 77pt;text-indent: 0pt;text-align: left;">}</p><p class="s34" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">}</p><p class="s49" style="padding-top: 5pt;text-indent: 0pt;text-align: right;">//....</p><p class="s34" style="padding-top: 5pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">}</p><p class="s49" style="padding-top: 5pt;text-indent: 0pt;text-align: right;">//.....</p><p class="s34" style="padding-top: 5pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">中有使用到弱引用，</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="105" alt="image" src="整合_files/Image_167.png"/></span></p><p class="s40" style="padding-top: 7pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">Object <span style=" color: #000;">obj </span><span style=" color: #971A1A;">= </span><span style=" color: #770087;">new </span>Object<span style=" color: #333;">();</span></p><p class="s42" style="padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: #000;">PhantomReference</span>&lt;<span style=" color: #008754;">Object</span>&gt; <span style=" color: #000;">pf </span>= <span style=" color: #770087;">new </span><span style=" color: #000;">PhantomReference</span>&lt;<span style=" color: #008754;">Object</span>&gt;<span style=" color: #333;">(</span><span style=" color: #000;">obj</span><span style=" color: #333;">); </span><span style=" color: #000;">obj</span>=<span style=" color: #211199;">null</span><span style=" color: #333;">;</span></p><p class="s41" style="padding-top: 2pt;padding-left: 13pt;text-indent: 0pt;line-height: 86%;text-align: left;">pf<span style=" color: #333;">.</span>get<span style=" color: #333;">();</span><span style=" color: #AA5400;">//</span><span class="s50">永远返回</span><span style=" color: #AA5400;">null </span>pf<span style=" color: #333;">.</span>isEnQueued<span style=" color: #333;">();</span><span style=" color: #AA5400;">//</span><span class="s50">返回是否从内存中已经删除</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: left;">虚引用是每次垃圾回收的时候都会被回收，通过虚引用的<span class="s35">get</span>方法永远获取到的数据为<span class="s35">null</span>，因此也被成为幽灵引用。虚引用主要用于检测对象是否已经从内存中删除。</p><p class="s45" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark8">Java</a><span class="s33">获取反射的三种方法</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="141" alt="image" src="整合_files/Image_168.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s34" style="padding-left: 35pt;text-indent: -21pt;line-height: 159%;text-align: left;"><span style=" color: #770087;">public class </span><span style=" color: #00F;">Student </span>{ <span style=" color: #770087;">private </span><span style=" color: #008754;">int </span><span style=" color: #000;">id</span>; <span style=" color: #008754;">String </span><span style=" color: #000;">name</span>; <span style=" color: #770087;">protected </span><span style=" color: #008754;">boolean </span><span style=" color: #000;">sex</span>; <span style=" color: #770087;">public float </span><span style=" color: #000;">score</span>;</p><p class="s34" style="padding-left: 13pt;text-indent: 0pt;line-height: 8pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><ol id="l19"><li data-list-text="1."><p class="s36" style="padding-top: 5pt;padding-left: 14pt;text-indent: -8pt;text-align: left;">通过<span class="s35">new</span>对象实现反射机制 <span class="s35">2.</span>通过路径实现反射机制 <span class="s35">3.</span>通过类名实现反射机制</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="285" alt="image" src="整合_files/Image_169.png"/></span></p><p class="s39" style="padding-top: 7pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">public class <span style=" color: #00F;">Get </span><span style=" color: #333;">{</span></p><p class="s49" style="padding-left: 35pt;text-indent: 0pt;text-align: left;">//<span class="s50">获取反射机制三种方式</span></p><p class="s34" style="padding-top: 2pt;padding-left: 35pt;text-indent: 0pt;text-align: left;"><span style=" color: #770087;">public static </span><span style=" color: #008754;">void </span><span style=" color: #000;">main</span>(<span style=" color: #008754;">String</span>[] <span style=" color: #000;">args</span>) <span style=" color: #770087;">throws </span><span style=" color: #000;">ClassNotFoundException </span>{</p><p class="s49" style="padding-left: 56pt;text-indent: 0pt;text-align: left;">//<span class="s50">方式一</span>(<span class="s50">通过建立对象</span>)</p><p class="s41" style="padding-top: 2pt;padding-left: 56pt;text-indent: 0pt;line-height: 159%;text-align: left;">Student stu <span style=" color: #971A1A;">= </span><span style=" color: #770087;">new </span>Student<span style=" color: #333;">(); </span>Class classobj1 <span style=" color: #971A1A;">= </span>stu<span style=" color: #333;">.</span>getClass<span style=" color: #333;">();</span></p><p class="s41" style="padding-left: 56pt;text-indent: 0pt;line-height: 9pt;text-align: left;">System<span style=" color: #333;">.</span>out<span style=" color: #333;">.</span>println<span style=" color: #333;">(</span>classobj1<span style=" color: #333;">.</span>getName<span style=" color: #333;">());</span></p><p class="s49" style="padding-left: 56pt;text-indent: 0pt;text-align: left;">//<span class="s50">方式二（所在通过路径</span>-<span class="s50">相对路径）</span></p><p class="s41" style="padding-top: 2pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">Class classobj2 <span style=" color: #971A1A;">= </span>Class<span style=" color: #333;">.</span>forName<span style=" color: #333;">(</span><span style=" color: #A11;">&quot;fanshe.Student&quot;</span><span style=" color: #333;">);</span></p><p class="s41" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">System<span style=" color: #333;">.</span>out<span style=" color: #333;">.</span>println<span style=" color: #333;">(</span>classobj2<span style=" color: #333;">.</span>getName<span style=" color: #333;">());</span></p><p class="s49" style="padding-left: 56pt;text-indent: 0pt;text-align: left;">//<span class="s50">方式三（通过类名）</span></p><p class="s41" style="padding-top: 2pt;padding-left: 56pt;text-indent: 0pt;line-height: 159%;text-align: left;">Class classobj3 <span style=" color: #971A1A;">= </span>Student<span style=" color: #333;">.</span><span style=" color: #770087;">class</span><span style=" color: #333;">; </span>System<span style=" color: #333;">.</span>out<span style=" color: #333;">.</span>println<span style=" color: #333;">(</span>classobj3<span style=" color: #333;">.</span>getName<span style=" color: #333;">());</span></p><p class="s34" style="padding-left: 35pt;text-indent: 0pt;line-height: 9pt;text-align: left;">}</p><p class="s34" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><p class="s45" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark9">Java</a><span class="s33">反射机制</span></p><p class="s36" style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: left;"><span class="s35">Java </span>反射机制是在<span style=" color: #F00;">运行状态中</span>，对于任意一个类，都能够获得这个类的所有属性和方法，对于任意一个对象都能够调用它的任意一个属性和方法。这种在运行时动态的获取信息以及动态调用对象的方法的功能称为 <span class="s35">Java </span>的反射机制。</p><p class="s35" style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: left;">Class <span class="s36">类与 </span>java.lang.reﬂect <span class="s36">类库一起对反射的概念进行了支持，该类库包含了 </span>Field,Method,Constructor <span class="s36">类 </span>(<span class="s36">每个类都实现了 </span>Member <span class="s36">接口</span>)<span class="s36">。这些类型的对象时由 </span>JVM <span class="s36">在运行时创建的，用以表示未知类里对应的成员。</span></p><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;line-height: 17pt;text-align: left;">这样你就可以使用 <span class="s35">Constructor </span>创建新的对象，用 <span class="s35">get() </span>和 <span class="s35">set() </span>方法读取和修改与 <span class="s35">Field </span>对象关联的字段，用</p><p style="text-indent: 0pt;text-align: left;"><span><img width="180" height="15" alt="image" src="整合_files/Image_170.png"/></span></p><p class="s34" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">getFields() getMethods()</p><p style="text-indent: 0pt;text-align: left;"/><p class="s35" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">invoke() <span class="s36">方法调用与 </span>Method <span class="s36">对象关联的方法。另外，还可以调用                和</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="130" height="15" alt="image" src="整合_files/Image_171.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">getConstructors()</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 99pt;line-height: 90%;text-align: left;">等很便利的方法，以返回表示字段，方法，以及构造器的对象的数组。这样匿名对象的信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 5pt;text-align: left;"><span><img width="654" height="7" alt="image" src="整合_files/Image_172.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="654" height="425" alt="image" src="整合_files/Image_173.png"/></span></p><p class="s34" style="padding-top: 4pt;padding-left: 13pt;text-indent: 0pt;line-height: 159%;text-align: left;"><span style=" color: #770087;">import </span><span style=" color: #000;">java</span>.<span style=" color: #000;">lang</span>.<span style=" color: #000;">reflect</span>.<span style=" color: #000;">Constructor</span>; <span style=" color: #770087;">public class </span><span style=" color: #00F;">ReflectTest </span>{</p><p class="s34" style="padding-left: 35pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span style=" color: #770087;">public static </span><span style=" color: #008754;">void </span><span style=" color: #000;">main</span>(<span style=" color: #008754;">String</span>[] <span style=" color: #000;">args</span>) <span style=" color: #770087;">throws </span><span style=" color: #000;">Exception </span>{</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-left: 56pt;text-indent: 0pt;text-align: left;">Class clazz <span style=" color: #971A1A;">= </span><span style=" color: #211199;">null</span><span style=" color: #333;">;</span></p><p class="s41" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;line-height: 159%;text-align: left;">clazz <span style=" color: #971A1A;">= </span>Class<span style=" color: #333;">.</span>forName<span style=" color: #333;">(</span><span style=" color: #A11;">&quot;com.jas.reflect.Fruit&quot;</span><span style=" color: #333;">); </span>Constructor<span style=" color: #971A1A;">&lt;</span>Fruit<span style=" color: #971A1A;">&gt; </span>constructor1 <span style=" color: #971A1A;">= </span>clazz<span style=" color: #333;">.</span>getConstructor<span style=" color: #333;">();</span></p><p class="s41" style="padding-left: 56pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Constructor<span style=" color: #971A1A;">&lt;</span>Fruit<span style=" color: #971A1A;">&gt; </span>constructor2 <span style=" color: #971A1A;">= </span>clazz<span style=" color: #333;">.</span>getConstructor<span style=" color: #333;">(</span><span style=" color: #008754;">String</span><span style=" color: #333;">.</span><span style=" color: #770087;">class</span><span style=" color: #333;">);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-left: 56pt;text-indent: 0pt;text-align: left;">Fruit fruit1 <span style=" color: #971A1A;">= </span>constructor1<span style=" color: #333;">.</span>newInstance<span style=" color: #333;">();</span></p><p class="s41" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">Fruit fruit2 <span style=" color: #971A1A;">= </span>constructor2<span style=" color: #333;">.</span>newInstance<span style=" color: #333;">(</span><span style=" color: #A11;">&quot;Apple&quot;</span><span style=" color: #333;">);</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s34" style="padding-left: 35pt;text-indent: 0pt;text-align: left;">}</p><p class="s34" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">}</p><p class="s39" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">class <span style=" color: #00F;">Fruit</span><span style=" color: #333;">{</span></p><p class="s39" style="padding-top: 5pt;padding-left: 35pt;text-indent: 0pt;text-align: left;">public <span style=" color: #000;">Fruit</span><span style=" color: #333;">(){</span></p><p class="s34" style="padding-left: 56pt;text-indent: 0pt;text-align: left;"><span style=" color: #000;">System</span>.<span style=" color: #000;">out</span>.<span style=" color: #000;">println</span>(<span style=" color: #A11;">&quot;</span><span class="s52">无参构造器 </span><span style=" color: #A11;">Run</span><span class="s53">      </span><span style=" color: #A11;">&quot;</span>);</p><p class="s34" style="padding-top: 2pt;padding-left: 35pt;text-indent: 0pt;text-align: left;">}</p><p class="s41" style="padding-top: 5pt;padding-left: 35pt;text-indent: 0pt;text-align: left;"><span style=" color: #770087;">public </span>Fruit<span style=" color: #333;">(</span><span style=" color: #008754;">String </span>type<span style=" color: #333;">){</span></p><p class="s41" style="padding-left: 56pt;text-indent: 0pt;text-align: left;">System<span style=" color: #333;">.</span>out<span style=" color: #333;">.</span>println<span style=" color: #333;">(</span><span style=" color: #A11;">&quot;</span><span class="s52">有参构造器 </span><span style=" color: #A11;">Run...........&quot; </span><span style=" color: #971A1A;">+ </span>type<span style=" color: #333;">);</span></p><p class="s34" style="padding-top: 2pt;padding-left: 35pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s34" style="padding-left: 13pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><p class="s56" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><span><img width="4" height="20" alt="image" src="整合_files/Image_174.png"/></span><span class="s54"> </span><span class="s55">运行结果： 无参构造器 </span>Run……….. <span class="s55">有参构造器 </span>Run…<span class="s57">  </span>Apple</p><p class="s45" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark10">Arrays.sort </a><span class="s33">和 </span>Collections.sort <span class="s33">实现原理 和区别</span></p><p class="s58" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Collection<span class="s31">和</span>Collections<span class="s31">区别</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="151" height="15" alt="image" src="整合_files/Image_175.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">java.util.Collection</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 122pt;text-indent: 0pt;line-height: 17pt;text-align: left;">是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="158" height="15" alt="image" src="整合_files/Image_176.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">java.util.Collections</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="137" height="15" alt="image" src="整合_files/Image_177.png"/></span></p><p class="s36" style="padding-left: 6pt;text-indent: 121pt;line-height: 87%;text-align: left;">是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全等操作。  然后还有混排（<span class="s35">Shuﬄing</span>）、反转（<span class="s35">Reverse</span>）、替换所有的元素（<span class="s35">ﬁll</span>）、拷贝（<span class="s35">copy</span>）、返回<span class="s35">Collections</span>中最小元素（<span class="s35">min</span>）、返回<span class="s35">Collections</span>中最大元素（<span class="s35">max</span>）、返回指定源列表中最后一次出现指定目标列表的起始位置（   <span class="s34">lastIndexOfSubList  </span>）、返回指定源列表中第一次出现指定目标列表的起始位置</p><p style="text-indent: 0pt;text-align: left;"><span><img width="108" height="15" alt="image" src="整合_files/Image_178.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">IndexOfSubList</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 17pt;text-align: left;">（          ）、根据指定的距离循环移动指定列表中的元素（<span class="s35">Rotate</span>）<span class="s35">;</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="654" height="260" alt="image" src="整合_files/Image_179.png"/></span></p><p class="s34" style="padding-top: 7pt;padding-left: 13pt;text-indent: 0pt;text-align: left;"><span style=" color: #770087;">public static </span><span style=" color: #008754;">void </span><span style=" color: #00F;">sort</span>(<span style=" color: #008754;">Object</span>[] <span style=" color: #000;">a</span>) {</p><p class="s34" style="padding-top: 5pt;padding-left: 77pt;text-indent: -21pt;line-height: 159%;text-align: left;"><span style=" color: #770087;">if </span>(<span style=" color: #000;">LegacyMergeSort</span>.<span style=" color: #000;">userRequested</span>) <span style=" color: #000;">legacyMergeSort</span>(<span style=" color: #000;">a</span>);</p><p class="s39" style="padding-left: 56pt;text-indent: 0pt;line-height: 9pt;text-align: left;">else</p><p class="s34" style="padding-top: 5pt;padding-left: 77pt;text-indent: 0pt;text-align: left;"><span style=" color: #000;">ComparableTimSort</span>.<span style=" color: #000;">sort</span>(<span style=" color: #000;">a</span>, <span style=" color: #164;">0</span>, <span style=" color: #000;">a</span>.<span style=" color: #000;">length</span>, <span style=" color: #211199;">null</span>, <span style=" color: #164;">0</span>, <span style=" color: #164;">0</span>);</p><p class="s34" style="padding-top: 5pt;padding-left: 35pt;text-indent: 0pt;text-align: left;">}</p><p class="s49" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">//void java.util.ComparableTimSort.sort()</p><p class="s34" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;"><span style=" color: #770087;">static </span><span style=" color: #008754;">void </span><span style=" color: #00F;">sort</span>(<span style=" color: #008754;">Object</span>[] <span style=" color: #000;">a</span>, <span style=" color: #008754;">int </span><span style=" color: #000;">lo</span>, <span style=" color: #008754;">int </span><span style=" color: #000;">hi</span>, <span style=" color: #008754;">Object</span>[] <span style=" color: #000;">work</span>, <span style=" color: #008754;">int </span><span style=" color: #000;">workBase</span>, <span style=" color: #008754;">int </span><span style=" color: #000;">workLen</span>)</p><p class="s34" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">{</p><p class="s41" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;line-height: 159%;text-align: left;"><span style=" color: #770087;">assert </span>a <span style=" color: #971A1A;">!= </span><span style=" color: #211199;">null </span><span style=" color: #971A1A;">&amp;&amp; </span>lo <span style=" color: #971A1A;">&gt;= </span><span style=" color: #164;">0 </span><span style=" color: #971A1A;">&amp;&amp; </span>lo <span style=" color: #971A1A;">&lt;= </span>hi <span style=" color: #971A1A;">&amp;&amp; </span>hi <span style=" color: #971A1A;">&lt;= </span>a<span style=" color: #333;">.</span>length<span style=" color: #333;">; </span><span style=" color: #008754;">int </span>nRemaining <span style=" color: #971A1A;">= </span>hi <span style=" color: #971A1A;">- </span>lo<span style=" color: #333;">;</span></p><p class="s34" style="padding-left: 56pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span style=" color: #770087;">if </span>(<span style=" color: #000;">nRemaining </span><span style=" color: #971A1A;">&lt; </span><span style=" color: #164;">2</span>)</p><p class="s39" style="padding-top: 5pt;padding-left: 77pt;text-indent: 0pt;text-align: left;">return<span style=" color: #333;">; </span><span style=" color: #AA5400;">// Arrays of size 0 and 1 are always sorted</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">事实上<span class="s35">Collections.sort</span>方法底层就是调用的<span class="s35">array.sort</span>方法，</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="654" height="134" alt="image" src="整合_files/Image_180.png"/></span></p><p class="s41" style="padding-top: 2pt;padding-left: 56pt;text-indent: 0pt;line-height: 159%;text-align: left;"><span style=" color: #AA5400;">// If array is small, do a &quot;mini-TimSort&quot; with no merges </span><span style=" color: #770087;">if </span><span style=" color: #333;">(</span>nRemaining <span style=" color: #971A1A;">&lt; </span>MIN_MERGE<span style=" color: #333;">) {</span></p><p class="s41" style="padding-left: 77pt;text-indent: 0pt;line-height: 159%;text-align: left;"><span style=" color: #008754;">int </span>initRunLen <span style=" color: #971A1A;">= </span>countRunAndMakeAscending<span style=" color: #333;">(</span>a<span style=" color: #333;">, </span>lo<span style=" color: #333;">, </span>hi<span style=" color: #333;">); </span>binarySort<span style=" color: #333;">(</span>a<span style=" color: #333;">, </span>lo<span style=" color: #333;">, </span>hi<span style=" color: #333;">, </span>lo <span style=" color: #971A1A;">+ </span>initRunLen<span style=" color: #333;">);</span></p><p class="s39" style="padding-left: 77pt;text-indent: 0pt;line-height: 9pt;text-align: left;">return<span style=" color: #333;">;</span></p><p class="s34" style="padding-top: 4pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">}</p><p class="s34" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="116" height="15" alt="image" src="整合_files/Image_181.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">legacyMergeSort</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="179" height="15" alt="image" src="整合_files/Image_182.png"/></span></p><p class="s34" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">ComparableTimSort.sort()</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_183.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">Timsort</p><p style="text-indent: 0pt;text-align: left;"/><ol id="l20"><li data-list-text="(a)"><p class="s36" style="padding-top: 2pt;padding-left: 104pt;text-indent: -11pt;text-align: left;">：归并排序                ： 排序</p></li></ol></li></ol></li></ol></ol><p style="text-indent: 0pt;text-align: left;"><span><img width="4" height="100" alt="image" src="整合_files/Image_184.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_185.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">Timsort</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 44pt;line-height: 137%;text-align: left;">排序是结合了合并排序（<span class="s35">merge sort</span>）和插入排序（<span class="s35">insertion sort</span>）而得出的排序算法 <span class="s35">Timsort</span>的核心过程</p><p class="s56" style="padding-left: 20pt;text-indent: 0pt;line-height: 86%;text-align: left;">TimSort <span class="s55">算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分 区。排序的输入的单位不是一个个单独的数字，而是一个个的块</span>-<span class="s55">分区。其中每一个分区叫一个</span>run<span class="s55">。针对这些 </span>run <span class="s55">序列，每次拿一个 </span>run <span class="s55">出来按规则进行合并。每次合并会将两个 </span>run<span class="s55">合并成一个 </span>run<span class="s55">。合并的结果保存到栈中。合并直到消耗掉所有的 </span>run<span class="s55">，这时将栈上剩余的 </span>run<span class="s55">合并到只剩一个 </span>run <span class="s55">为止。这时这个仅剩的 </span>run <span class="s55">便是排好序的结果。</span></p><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">综上述过程，<span class="s35">Timsort</span>算法的过程包括</p><ol id="l21"><li data-list-text="（0）"><p class="s36" style="padding-top: 5pt;padding-left: 31pt;text-indent: -25pt;text-align: left;">如何数组长度小于某个值，直接用二分插入排序算法</p></li><li data-list-text="（1）"><p class="s36" style="padding-top: 5pt;padding-left: 31pt;text-indent: -25pt;text-align: left;">找到各个<span class="s35">run</span>，并入栈</p></li><li data-list-text="（2）"><p class="s36" style="padding-top: 5pt;padding-left: 31pt;text-indent: -25pt;text-align: left;">按规则合并<span class="s35">run</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><span><img width="168" height="23" alt="image" src="整合_files/Image_186.png"/></span></p><p class="s32" style="padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">LinkedHashMap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 5pt;padding-left: 132pt;text-indent: 0pt;text-align: left;"><a name="bookmark11">的应用</a></p><p style="text-indent: 0pt;text-align: left;"><span><img width="101" height="15" alt="image" src="整合_files/Image_187.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">LinkedHashMap</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="189" height="15" alt="image" src="整合_files/Image_188.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="31" height="15" alt="image" src="整合_files/Image_189.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">LRU</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="102" height="15" alt="image" src="整合_files/Image_190.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">LinkedHashMap</p><p style="text-indent: 0pt;text-align: left;"/><p class="s34" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">LRU<span class="s60">（</span>Least Recently Used<span class="s60">）</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">基于 的访问顺序的特点，可构造一个</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">最近最少使用简单缓存。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_191.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">ehcache</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">也有一些开源的缓存产品如</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">的淘汰策略（</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">）就是在</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">上扩展的。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="119" height="23" alt="image" src="整合_files/Image_192.png"/></span></p><p class="s32" style="padding-left: 3pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Cloneable</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 5pt;padding-left: 95pt;text-indent: 0pt;text-align: left;"><a name="bookmark12">接口实现原理</a></p><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="87" alt="image" src="整合_files/Image_193.png"/></span></p><p class="s61" style="padding-top: 4pt;padding-left: 13pt;text-indent: 15pt;line-height: 86%;text-align: justify;">在开发过程中，拷贝实例是常见的一种操作，如果一个类中的字段较多，而我们又采用在客户端中逐字段复制的方法进行拷贝操作的话，将不可避免的造成客户端代码繁杂冗长，而且也无法对类中的私有成员进行复制，而如果让需要具备拷贝功能的类实现<span class="s41">Cloneable</span>接口，并重写<span class="s41">clone</span><span class="s34">()</span>方法，就可以通过调用<span class="s41">clone</span><span class="s34">()</span>方法的方式简洁地实现实例拷贝功能</p><p style="text-indent: 0pt;text-align: left;"/><p class="s35" style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: left;">Cloneable<span class="s36">接口是</span>Java<span class="s36">开发中常用的一个接口，  它的作用是使一个类的实例能够将自身拷贝到另一个新的实例中，注意，这里所说的</span>“<span class="s36">拷贝</span>”<span class="s36">拷的是对象实例，而不是类的定义，进一步说，拷贝的是一个类的实例中各字段的值。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s36" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: justify;">深拷贝<span class="s35">(</span>深复制<span class="s35">)</span>和浅拷贝<span class="s35">(</span>浅复制<span class="s35">)</span>是两个比较通用的概念，尤其在<span class="s35">C++</span>语言中，若不弄懂，则会在<span class="s35">delete</span>的时候出问题，但是我们在这幸好用的是<span class="s35">Java</span>。虽然<span class="s35">Java</span>自动管理对象的回收，但对于深拷贝<span class="s35">(</span>深复制<span class="s35">)</span>和浅拷贝<span class="s35">(</span>浅复制<span class="s35">)</span>，我们还是要给予足够的重视，因为有时这两个概念往往会给我们带来不小的困惑。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_194.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">B1</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;line-height: 17pt;text-align: left;">浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。深拷</p><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_195.png"/></span></p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。举例来说更加清楚：对象 <span class="s34">A1 </span>中包含对  的引</p><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_196.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_197.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_198.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">A1</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_199.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">A2</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_200.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">A2</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_201.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_202.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_203.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">C1</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_204.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">B2</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_205.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">B1</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_206.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">copy</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="25" height="15" alt="image" src="整合_files/Image_207.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">B2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">用， <span class="s34">B1 </span>中包含对 <span class="s34">C1 </span>的引用。浅拷贝 得到   ， 中依然包含对 <span class="s34">B1 </span>的引用， <span class="s34">B1 </span>中依然包含对 的引</p><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_208.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">A1</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_209.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">A2</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_210.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">A2</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">用。深拷贝则是对浅拷贝的递归，深拷贝 得到  ，</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">中包含对  （  的</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">）的引用，</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">中包含</p><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_211.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">C2</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="24" height="15" alt="image" src="整合_files/Image_212.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">C1</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_213.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">copy</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">对  （  的    ）的引用。</p><p class="s36" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">若不对<span class="s35">clone()</span>方法进行改写，则调用此方法得到的对象即为浅拷贝</p><p class="s33" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark13">异常分类以及处理机制</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><span></span></p><p class="s35" style="padding-top: 10pt;padding-left: 6pt;text-indent: 0pt;line-height: 129%;text-align: left;">Java<span class="s36">标准库内建了一些通用的异常，这些类以</span>Throwable<span class="s36">为顶层父类。 </span>Throwable<span class="s36">又派生出</span>Error<span class="s36">类和</span>Exception<span class="s36">类。</span></p><p class="s36" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: left;">错误：<span class="s35">Error</span>类以及他的子类的实例，代表了<span class="s35">JVM</span>本身的错误。错误不能被程序员通过代码处理，<span class="s35">Error</span>很少出现。因此，程序员应该关注<span class="s35">Exception</span>为父类的分支下的各种异常类。</p><p class="s36" style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: left;">异常：<span class="s35">Exception</span>以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被<span class="s35">Java</span>异常处理机制使用，是异常处理的核心。</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_216.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">Javac</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">总体上我们根据 对异常的处理要求，将异常类分为二类。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="144" height="15" alt="image" src="整合_files/Image_217.png"/></span></p><p class="s62" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">unckecked exception</p><p style="text-indent: 0pt;text-align: left;"/><p class="s31" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">非检查异常（</p><p class="s31" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">）<span style=" color: #333;">：    和</span></p><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">以及他们的子类。</p><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">在编译时，</p><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_218.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">Error</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="122" height="15" alt="image" src="整合_files/Image_219.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">RuntimeException</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_220.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">javac</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="33" height="15" alt="image" src="整合_files/Image_221.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">try…</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用</p><p style="text-indent: 0pt;text-align: left;"><span><img width="96" height="15" alt="image" src="整合_files/Image_222.png"/></span></p><p class="s34" style="text-indent: 0pt;text-align: left;">catch…finally</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 78pt;text-indent: 0pt;line-height: 17pt;text-align: left;">）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处</p><p style="text-indent: 0pt;text-align: left;"><span><img width="144" height="15" alt="image" src="整合_files/Image_223.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">ArithmeticException</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">理 。这样的异常发生的原因多半是代码写的有问题。如除<span class="s35">0</span>错误              ，错误的强制类型转换错</p><p style="text-indent: 0pt;text-align: left;"><span><img width="137" height="15" alt="image" src="整合_files/Image_224.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">ClassCastException</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="151" height="15" alt="image" src="整合_files/Image_225.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">NullPointerException</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">误</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="130" height="15" alt="image" src="整合_files/Image_226.png"/></span></p><p class="s62" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">checked exception</p><p style="text-indent: 0pt;text-align: left;"/><p class="s31" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">检查异常（</p><p class="s36" style="padding-left: 7pt;text-indent: 0pt;line-height: 90%;text-align: left;">，数组索引越界等等。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="221" height="15" alt="image" src="整合_files/Image_227.png"/></span></p><p class="s34" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">ArrayIndexOutOfBoundsException</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_228.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">Error</p><p style="text-indent: 0pt;text-align: left;"/><p class="s31" style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">）<span style=" color: #333;">：除了    和</span></p><p class="s36" style="padding-left: 27pt;text-indent: 0pt;line-height: 16pt;text-align: left;">，使用了空对象</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="122" height="15" alt="image" src="整合_files/Image_229.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">RuntimeException</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="46" height="15" alt="image" src="整合_files/Image_230.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="70" height="15" alt="image" src="整合_files/Image_231.png"/></span></p><p class="s34" style="padding-top: 1pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">try<span class="s48">-</span>catch</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">的其它异常。 <span class="s34">javac </span>强制要求程序员</p><p style="text-indent: 0pt;text-align: left;"><span><img width="130" height="15" alt="image" src="整合_files/Image_232.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">try…catch…finally</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">为这样的异常做预备处理工作（使用</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">或者 <span class="s34">throws </span>）。在方法中要么用</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">语句捕</p><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_233.png"/></span></p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 86%;text-align: left;">获它并处理，要么用<span class="s35">throws</span>子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样</p><p style="text-indent: 0pt;text-align: left;"><span><img width="94" height="15" alt="image" src="整合_files/Image_234.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">SQLException</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">的异常时刻准备着。如         <span class="s35">,</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_235.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">javac</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">需要明确的是：检查和非检查是对于</p><p class="s36" style="padding-left: 103pt;text-indent: 0pt;line-height: 16pt;text-align: center;">等。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="256" height="15" alt="image" src="整合_files/Image_236.png"/></span></p><p class="s34" style="padding-top: 1pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">IOException <span class="s35">,</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s34" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">ClassNotFoundException</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 6pt;padding-left: 57pt;text-indent: 0pt;text-align: center;">来说的，这样就很好理解和区分了。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="58" height="23" alt="image" src="整合_files/Image_237.png"/></span></p><p class="s32" style="padding-left: 3pt;text-indent: 0pt;line-height: 15pt;text-align: left;">wait</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="71" height="23" alt="image" src="整合_files/Image_238.png"/></span></p><p class="s32" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">sleep</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 5pt;text-indent: 0pt;text-align: right;"><a name="bookmark14">和</a></p><p style="text-indent: 0pt;text-align: left;"><span><img width="654" height="147" alt="image" src="整合_files/Image_239.png"/></span></p><p class="s39" style="padding-top: 7pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">public class <span style=" color: #00F;">Thread </span>implements <span style=" color: #000;">Runnable </span><span style=" color: #333;">{</span></p><p class="s41" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;"><span style=" color: #770087;">public static native </span><span style=" color: #008754;">void </span>sleep<span style=" color: #333;">(</span><span style=" color: #008754;">long </span>millis<span style=" color: #333;">) </span><span style=" color: #770087;">throws </span>InterruptedException<span style=" color: #333;">;</span></p><p class="s34" style="padding-top: 5pt;padding-left: 56pt;text-indent: -15pt;line-height: 159%;text-align: left;"><span style=" color: #770087;">public static </span><span style=" color: #008754;">void </span><span style=" color: #000;">sleep</span>(<span style=" color: #008754;">long </span><span style=" color: #000;">millis</span>, <span style=" color: #008754;">int </span><span style=" color: #000;">nanos</span>) <span style=" color: #770087;">throws </span><span style=" color: #000;">InterruptedException </span>{ <span style=" color: #770087;">if </span>(<span style=" color: #000;">millis </span><span style=" color: #971A1A;">&lt; </span><span style=" color: #164;">0</span>) {</p><p class="s34" style="padding-left: 77pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span style=" color: #770087;">throw new </span><span style=" color: #000;">IllegalArgumentException</span>(<span style=" color: #A11;">&quot;timeout value is negative&quot;</span>);</p><p class="s34" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">}</p><p class="s42" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;text-align: left;"><span style=" color: #770087;">if </span><span style=" color: #333;">(</span><span style=" color: #000;">nanos </span>&lt; <span style=" color: #164;">0 </span>|| <span style=" color: #000;">nanos </span>&gt; <span style=" color: #164;">999999</span><span style=" color: #333;">) {</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">源码如下</p><p class="s33" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">的区别</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="654" height="188" alt="image" src="整合_files/Image_240.png"/></span></p><p class="s39" style="padding-top: 2pt;padding-left: 77pt;text-indent: 0pt;text-align: left;">throw new <span style=" color: #000;">IllegalArgumentException</span><span style=" color: #333;">(</span></p><p class="s51" style="padding-top: 5pt;padding-left: 183pt;text-indent: 0pt;text-align: left;">&quot;nanosecond timeout value out of range&quot;<span style=" color: #333;">);</span></p><p class="s34" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">}</p><p class="s42" style="padding-top: 5pt;padding-left: 77pt;text-indent: -21pt;line-height: 159%;text-align: left;"><span style=" color: #770087;">if </span><span style=" color: #333;">(</span><span style=" color: #000;">nanos </span>&gt;= <span style=" color: #164;">500000 </span>|| <span style=" color: #333;">(</span><span style=" color: #000;">nanos </span>!= <span style=" color: #164;">0 </span>&amp;&amp; <span style=" color: #000;">millis </span>== <span style=" color: #164;">0</span><span style=" color: #333;">)) { </span><span style=" color: #000;">millis</span>++<span style=" color: #333;">;</span></p><p class="s34" style="padding-left: 56pt;text-indent: 0pt;line-height: 9pt;text-align: left;">}</p><p class="s41" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">sleep<span style=" color: #333;">(</span>millis<span style=" color: #333;">);</span></p><p class="s34" style="padding-top: 5pt;padding-left: 35pt;text-indent: 0pt;text-align: left;">}</p><p class="s49" style="padding-top: 5pt;padding-left: 35pt;text-indent: 0pt;text-align: left;">//...</p><p class="s34" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="321" alt="image" src="整合_files/Image_241.png"/></span></p><p class="s39" style="padding-top: 7pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">public class <span style=" color: #008754;">Object </span><span style=" color: #333;">{</span></p><p class="s41" style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 159%;text-align: left;"><span style=" color: #770087;">public final native </span><span style=" color: #008754;">void </span>wait<span style=" color: #333;">(</span><span style=" color: #008754;">long </span>timeout<span style=" color: #333;">) </span><span style=" color: #770087;">throws </span>InterruptedException<span style=" color: #333;">; </span><span style=" color: #770087;">public final </span><span style=" color: #008754;">void </span>wait<span style=" color: #333;">(</span><span style=" color: #008754;">long </span>timeout<span style=" color: #333;">, </span><span style=" color: #008754;">int </span>nanos<span style=" color: #333;">) </span><span style=" color: #770087;">throws </span>InterruptedException <span style=" color: #333;">{</span></p><p class="s34" style="padding-left: 56pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span style=" color: #770087;">if </span>(<span style=" color: #000;">timeout </span><span style=" color: #971A1A;">&lt; </span><span style=" color: #164;">0</span>) {</p><p class="s34" style="padding-top: 5pt;padding-left: 73pt;text-indent: 0pt;text-align: center;"><span style=" color: #770087;">throw new </span><span style=" color: #000;">IllegalArgumentException</span>(<span style=" color: #A11;">&quot;timeout value is negative&quot;</span>);</p><p class="s34" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">}</p><p class="s42" style="padding-top: 5pt;padding-left: 77pt;text-indent: -21pt;line-height: 159%;text-align: left;"><span style=" color: #770087;">if </span><span style=" color: #333;">(</span><span style=" color: #000;">nanos </span>&lt; <span style=" color: #164;">0 </span>|| <span style=" color: #000;">nanos </span>&gt; <span style=" color: #164;">999999</span><span style=" color: #333;">) { </span><span style=" color: #770087;">throw new </span><span style=" color: #000;">IllegalArgumentException</span><span style=" color: #333;">(</span></p><p class="s51" style="padding-left: 183pt;text-indent: 0pt;line-height: 9pt;text-align: left;">&quot;nanosecond timeout value out of range&quot;<span style=" color: #333;">);</span></p><p class="s34" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">}</p><p class="s34" style="padding-top: 5pt;padding-left: 77pt;text-indent: -21pt;line-height: 159%;text-align: left;"><span style=" color: #770087;">if </span>(<span style=" color: #000;">nanos </span><span style=" color: #971A1A;">&gt; </span><span style=" color: #164;">0</span>) { <span style=" color: #000;">timeout</span><span style=" color: #971A1A;">++</span>;</p><p class="s34" style="padding-left: 56pt;text-indent: 0pt;line-height: 9pt;text-align: left;">}</p><p class="s41" style="padding-top: 5pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">wait<span style=" color: #333;">(</span>timeout<span style=" color: #333;">);</span></p><p class="s34" style="padding-top: 5pt;padding-left: 35pt;text-indent: 0pt;text-align: left;">}</p><p class="s49" style="padding-top: 5pt;padding-left: 35pt;text-indent: 0pt;text-align: left;">//...</p><p class="s34" style="padding-top: 5pt;padding-left: 13pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_242.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">sleep</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="53" height="15" alt="image" src="整合_files/Image_243.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">Thread</p><p style="text-indent: 0pt;text-align: left;"/><p class="s35" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">1<span class="s36">、 来自</span></p><p class="s36" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">类，和 来自</p><p class="s36" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">类。 <span class="s35">2</span>、最主要是<span class="s35">sleep</span>方法没有释放锁，而<span class="s35">wait</span>方法释放了</p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_244.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">wait</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_245.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">Object</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_246.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">sleep</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">锁，使得其他线程可以使用同步控制块或者方法。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="74" height="15" alt="image" src="整合_files/Image_247.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">notifyAll</p><p style="text-indent: 0pt;text-align: left;"/><p class="s35" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">3<span class="s36">、</span>wait<span class="s36">，</span>notify<span class="s36">和</span></p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 17pt;text-align: left;">用范围<span class="s35">)</span></p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">只能在同步控制方法或者同步控制块里面使用，而</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 15pt;text-align: left;">可以在任何地方使用<span class="s35">(</span>使</p><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_248.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">sleep</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="39" height="15" alt="image" src="整合_files/Image_249.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">wait</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_250.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">notify</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="73" height="15" alt="image" src="整合_files/Image_251.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">notifyAll</p><p style="text-indent: 0pt;text-align: left;"/><p class="s35" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">4<span class="s36">、 必须捕获异常，而    ，     和 不需要捕获异常</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="46" height="15" alt="image" src="整合_files/Image_252.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">sleep</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_253.png"/></span></p><ol id="l22"><li data-list-text="(1)"><p class="s36" style="padding-top: 6pt;padding-left: 54pt;text-indent: -47pt;text-align: left;">方法属于 <span class="s34">Thread </span>类中方法，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可</p><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_254.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">sleep</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">运行状态，不会马上进入运行状态，因为线程调度机制恢复线程的运行也需要时间，一个线程对象调用了</p><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_255.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">sleep</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="151" height="15" alt="image" src="整合_files/Image_256.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">InterruptedException</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">方法之后，并不会释放他所持有的所有对象锁，所以也就不会影响其他进程对象的运行。但在  的过程中过</p><p style="text-indent: 0pt;text-align: left;"><span><img width="87" height="15" alt="image" src="整合_files/Image_257.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">interrupt()</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">程中有可能被其他对象调用它的</p><p class="s35" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">,<span class="s36">产生</span></p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">异常，如果你的程序不捕获这个异</p><p style="text-indent: 0pt;text-align: left;"><span><img width="80" height="15" alt="image" src="整合_files/Image_258.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">TERMINATED</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">常，线程就会异常终止，进入 状态，如果你的程序捕获了这个异常，那么程序就会继续执行<span class="s35">catch</span>语</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">句块<span class="s35">(</span>可能还有</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_259.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">sleep()</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">注意</p><p class="s36" style="padding-left: 42pt;text-indent: 0pt;line-height: 16pt;text-align: left;">语句块<span class="s35">)</span>以及以后的代码。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="15" alt="image" src="整合_files/Image_260.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">finally</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="74" height="15" alt="image" src="整合_files/Image_261.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">t.sleep()</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;text-indent: 0pt;text-align: left;">方法是一个静态方法，也就是说他只对当前对象有效，通过</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_262.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">sleep</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">让<span class="s35">t</span>对象进入</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">，这样</p><p style="text-indent: 0pt;text-align: left;"><span><img width="45" height="15" alt="image" src="整合_files/Image_263.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">sleep</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="17" height="15" alt="image" src="整合_files/Image_264.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">t</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">的做法是错误的，它只会是使当前线程被 而不是 线程</p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_265.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">wait</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="53" height="15" alt="image" src="整合_files/Image_266.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="66" height="15" alt="image" src="整合_files/Image_267.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">notify()</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="88" height="15" alt="image" src="整合_files/Image_268.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">notifyAll()</p><p style="text-indent: 0pt;text-align: left;"/></li><li data-list-text="(2)"><p class="s36" style="padding-top: 6pt;padding-left: 48pt;text-indent: -42pt;text-align: left;">属于 <span class="s34">Object </span>的成员方法，一旦一个对象调用了<span class="s35">wait</span>方法，必须要采用      和 方法</p><p style="text-indent: 0pt;text-align: left;"><span><img width="53" height="15" alt="image" src="整合_files/Image_269.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_270.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">wait()</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="39" height="15" alt="image" src="整合_files/Image_271.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">wait</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">唤醒该进程<span class="s35">;</span>如果线程拥有某个或某些对象的同步锁，那么在调用了 <span class="s34">wait() </span>后，这个线程就会释放它持有的所有</p><p style="text-indent: 0pt;text-align: left;"><span><img width="52" height="15" alt="image" src="整合_files/Image_272.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">wait()</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">同步资源，而不限于这个被调用了</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">方法的对象。</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">方法也同样会在</p><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">的过程中有可能被其他对</p><p style="text-indent: 0pt;text-align: left;"><span><img width="87" height="15" alt="image" src="整合_files/Image_273.png"/></span></p><p class="s34" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">interrupt()</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">象调用 方法而产生 。</p><p class="s33" style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark15">数组在内存中如何分配</a></p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_274.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">Java</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">对于 数组的初始化，有以下两种方式，这也是面试中经常考到的经典题目：</p><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="87" alt="image" src="整合_files/Image_275.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 13pt;text-indent: 0pt;line-height: 108%;text-align: left;"><span style=" color: #AA5400;">//</span><span class="s50">只是指定初始值，并没有指定数组的长度，但是系统为自动决定该数组的长度为</span><span style=" color: #AA5400;">4 </span><span style=" color: #008754;">String</span>[] <span style=" color: #000;">computers </span><span style=" color: #971A1A;">= </span>{<span style=" color: #A11;">&quot;Dell&quot;</span>, <span style=" color: #A11;">&quot;Lenovo&quot;</span>, <span style=" color: #A11;">&quot;Apple&quot;</span>, <span style=" color: #A11;">&quot;Acer&quot;</span>}; <span style=" color: #AA5400;">//</span><span class="s63">①</span></p><p class="s51" style="padding-left: 13pt;text-indent: 0pt;line-height: 86%;text-align: left;"><span style=" color: #AA5400;">//</span><span class="s50">只是指定初始值，并没有指定数组的长度，但是系统为自动决定该数组的长度为</span><span style=" color: #AA5400;">3 </span><span style=" color: #008754;">String</span><span style=" color: #333;">[] </span><span style=" color: #000;">names </span><span style=" color: #971A1A;">= </span><span style=" color: #770087;">new </span><span style=" color: #008754;">String</span><span style=" color: #333;">[]{</span>&quot;<span class="s52">多啦</span>A<span class="s52">梦</span>&quot;<span style=" color: #333;">, </span>&quot;<span class="s52">大雄</span>&quot;<span style=" color: #333;">, </span>&quot;<span class="s52">静香</span>&quot;<span style=" color: #333;">};  </span><span style=" color: #AA5400;">//</span><span class="s63">②</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">静态初始化：初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组长度，如：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="653" height="51" alt="image" src="整合_files/Image_276.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 19pt;text-indent: -5pt;line-height: 108%;text-align: left;"><span style=" color: #AA5400;">//</span><span class="s50">只是指定了数组的长度，并没有显示的为数组指定初始值，但是系统会默认给数组数组元素分配初始值为</span><span style=" color: #AA5400;">null </span><span style=" color: #008754;">String</span>[] <span style=" color: #000;">cars </span><span style=" color: #971A1A;">= </span><span style=" color: #770087;">new </span><span style=" color: #008754;">String</span>[<span style=" color: #164;">4</span>];  <span style=" color: #AA5400;">//</span><span class="s63">③</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">动态初始化：初始化时由程序员显示的指定数组的长度，由系统为数据每个元素分配初始值，如：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_277.png"/></span></p><p class="s34" style="padding-top: 3pt;padding-left: 3pt;text-indent: 0pt;text-align: left;">Java</p><p style="text-indent: 0pt;text-align: left;"/><p class="s36" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 90%;text-align: left;">因为  数组变量是引用类型的变量，所以上述几行初始化语句执行后，三个数组在内存中的分配情况如下图所示：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 7pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_279.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="38" height="15" alt="image" src="整合_files/Image_280.png"/></span></p><p class="s36" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 89%;text-align: justify;">由上图可知，静态初始化方式，程序员虽然没有指定数组长度，但是系统已经自动帮我们给分配了，而动态初始化方式，程序员虽然没有显示的指定初始化值，但是因为  <span class="s34">Java </span>数组是引用类型的变量，所以系统也为每个元素分配了初始化值  <span class="s34">null </span>，当然不同类型的初始化值也是不一样的，假设是基本类型<span class="s35">int</span>类型，那么为系统分配的初始化值也是对应的默认值<span class="s35">0</span>。</p><ol id="l23"><li data-list-text="1."><h3 style="padding-bottom: 2pt;padding-left: 38pt;text-indent: -15pt;line-height: 32pt;text-align: left;">面向对象和面向过程的区别</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_281.png"/></span></p><p class="s64" style="padding-top: 18pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">面向过程</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 151%;text-align: justify;"><span class="s65">优点： </span>性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源<span class="s67">;</span>比如单片机、嵌入式开发、<span class="s67">Linux/Unix </span>等一般采用面向过程开发，性能是最重要的因素。</p><p class="s65" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">缺点： <span class="s66">没有面向对象易维护、易复用、易扩展</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s64" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">面向对象</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: justify;">优点： <span class="s66">易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">缺点： <span class="s66">性能比面向过程低</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s68" style="padding-bottom: 3pt;padding-left: 43pt;text-indent: -20pt;text-align: left;">Java <span class="h3">语言有哪些特点</span></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_282.png"/></span></p><ol id="l24"><li data-list-text="1."><p class="s66" style="padding-top: 13pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">简单易学；</p></li><li data-list-text="2."><p class="s66" style="padding-top: 2pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">面向对象（封装，继承，多态）；</p></li><li data-list-text="3."><p class="s66" style="padding-top: 10pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">平台无关性（ <span class="s67">Java </span>虚拟机实现平台无关性）；</p></li><li data-list-text="4."><p class="s66" style="padding-top: 9pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">可靠性；</p></li><li data-list-text="5."><p class="s66" style="padding-top: 2pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">安全性；</p></li><li data-list-text="6."><p class="s66" style="padding-top: 10pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">支持多线程（ <span class="s67">C++ </span>语言没有内置的多线程机制，因此必须调用操作系</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 59pt;text-indent: 0pt;line-height: 147%;text-align: left;">统的多线程功能来进行多线程程序设计，而 <span class="s67">Java </span>语言却提供了多线程支持）；</p></li><li data-list-text="7."><p class="s66" style="padding-top: 3pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">支持网络编程并且很方便（ <span class="s67">Java </span>语言诞生本身就是为简化网络编程设</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">计的，因此 <span class="s67">Java </span>语言不仅支持网络编程而且很方便）；</p></li><li data-list-text="8."><p class="s66" style="padding-top: 9pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">编译与解释并存；</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="3."><h3 style="padding-bottom: 2pt;padding-left: 47pt;text-indent: -24pt;text-align: left;">关于 <span class="s68">JVM JDK </span>和 <span class="s68">JRE </span>最详细通俗的解答</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_283.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">JVM</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Java <span class="s66">虚拟机（</span>JVM<span class="s66">）是运行 </span>Java <span class="s66">字节码的虚拟机。</span>JVM <span class="s66">有针对不同系统的特</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 147%;text-align: left;">定实现（<span class="s67">Windows</span>，<span class="s67">Linux</span>，<span class="s67">macOS</span>），目的是使用相同的字节码，它们都会给出相同的结果。</p><p class="s65" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是字节码<span class="s70">?</span>采用字节码的好处是什么<span class="s70">?</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s71" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">在 <span class="s72">Java </span>中，<span class="s72">JVM </span>可以理解的代码就叫做<span class="s73">字节码</span>（即扩展名为 <span class="s74">.class </span>的文</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s71" style="padding-left: 23pt;text-indent: 0pt;line-height: 148%;text-align: left;">件），它不面向任何特定的处理器，只面向虚拟机。<span class="s72">Java </span>语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 <span class="s72">Java </span>程序运行时比较高效，而且，由于字节码</p><p class="s71" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 147%;text-align: left;">并不专对一种特定的机器，因此，<span class="s72">Java </span>程序无须重新编译便可在多种不同的计算机上运行。</p><p class="s70" style="padding-left: 23pt;text-indent: 0pt;line-height: 20pt;text-align: left;">Java <span class="s65">程序从源代码到运行一般有下面 </span>3 <span class="s65">步：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">我们需要格外注意的是 <span class="s67">.class-&gt;</span>机器码 这一步。在这一步 <span class="s67">jvm </span>类加载器首先</p><p class="s66" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的，也就是所谓的热点代</p><p class="s66" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 148%;text-align: justify;">码，所以后面引进了 <span class="s67">JIT </span>编译器，<span class="s67">JIT </span>属于运行时编译。当 <span class="s67">JIT </span>编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 <span class="s67">Java </span>解释器的。这也解释了我们为什</p><p class="s66" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">么经常会说 <span class="s67">Java </span>是编译与解释共存的语言。</p><p class="s72" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">HotSpot <span class="s71">采用了惰性评估</span>(Lazy Evaluation)<span class="s71">的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 </span>JIT <span class="s71">所需要编译的部分。</span>JVM <span class="s71">会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。</span>JDK 9 <span class="s71">引入了一种新的编译模式 </span>AOT(Ahead of Time Compilation)<span class="s71">，它是直接将字节码编译成机器码，这样就避免了 </span>JIT <span class="s71">预热等各方面的开销。</span>JDK <span class="s71">支持分层编译和 </span>AOT <span class="s71">协作使用。但是 ， </span>AOT <span class="s71">编译器的编译质量是肯定比不上 </span>JIT <span class="s71">编译器的。</span></p><p class="s66" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">总结：<span class="s67">Java </span>虚拟机（<span class="s67">JVM</span>）是运行 <span class="s67">Java </span>字节码的虚拟机。<span class="s67">JVM </span>有针对不同系统的特定实现（<span class="s67">Windows</span>，<span class="s67">Linux</span>，<span class="s67">macOS</span>），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 <span class="s67">JVM </span>实现是 <span class="s67">Java </span>语言<span class="s67">“</span>一次编 译，随处可以运行<span class="s67">”</span>的关键所在。</p><p class="s69" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">JDK <span class="s64">和 </span>JRE</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">JDK <span class="s66">是 </span>Java Development Kit<span class="s66">，它是功能齐全的 </span>Java SDK<span class="s66">。它拥有 </span>JRE <span class="s66">所拥有</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 147%;text-align: left;">的一切，还有编译器（<span class="s67">javac</span>）和工具（如 <span class="s67">javadoc </span>和 <span class="s67">jdb</span>）。它能够创建和编译程序。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">JRE <span class="s66">是 </span>Java <span class="s66">运行时环境。它是运行已编译 </span>Java <span class="s66">程序所需的所有内容的集合，</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 147%;text-align: left;">包括 <span class="s67">Java </span>虚拟机（<span class="s67">JVM</span>），<span class="s67">Java </span>类库，<span class="s67">java </span>命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">如果你只是为了运行一下 <span class="s67">Java </span>程序的话，那么你只需要安装 <span class="s67">JRE </span>就可以了。如果你需要进行一些 <span class="s67">Java </span>编程方面的工作，那么你就需要安装 <span class="s67">JDK </span>了。但 是，这不是绝对的。有时，即使您不打算在计算机上进行任何 <span class="s67">Java </span>开发，仍然</p><p class="s66" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: justify;">需要安装 <span class="s67">JDK</span>。例如，如果要使用 <span class="s67">JSP </span>部署 <span class="s67">Web </span>应用程序，那么从技术上讲，您只是在应用程序服务器中运行 <span class="s67">Java </span>程序。那你为什么需要 <span class="s67">JDK </span>呢？因为应用程序服务器会将 <span class="s67">JSP </span>转换为 <span class="s67">Java servlet</span>，并且需要使用 <span class="s67">JDK </span>来编译</p><p class="s67" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">servlet<span class="s66">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s68" style="padding-bottom: 2pt;padding-left: 43pt;text-indent: -20pt;text-align: left;">Oracle JDK <span class="h3">和 </span>OpenJDK <span class="h3">的对比</span></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_284.png"/></span></p><p class="s66" style="padding-top: 19pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">可能在看这个问题之前很多人和我一样并没有接触和使用过 <span class="s67">OpenJDK </span>。那么</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;line-height: 146%;text-align: left;">Oracle <span class="s66">和 </span>OpenJDK <span class="s66">之间是否存在重大差异？下面通过我通过我收集到一些资料对你解答这个被很多人忽视的问题。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">对于 <span class="s67">Java 7</span>，没什么关键的地方。<span class="s67">OpenJDK </span>项目主要基于 <span class="s67">Sun </span>捐赠的 <span class="s67">HotSpot</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">源代码。此外，<span class="s67">OpenJDK </span>被选为 <span class="s67">Java 7 </span>的参考实现，由 <span class="s67">Oracle </span>工程师维护。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 147%;text-align: left;">关于 <span class="s67">JVM</span>，<span class="s67">JDK</span>，<span class="s67">JRE </span>和 <span class="s67">OpenJDK </span>之间的区别，<span class="s67">Oracle </span>博客帖子在 <span class="s67">2012 </span>年有一个更详细的答案：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s71" style="padding-left: 23pt;text-indent: 0pt;line-height: 147%;text-align: left;">问：<span class="s72">OpenJDK </span>存储库中的源代码与用于构建 <span class="s72">Oracle JDK </span>的代码之间有什么区别？</p><p class="s71" style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">答：非常接近 <span class="s72">- </span>我们的 <span class="s72">Oracle JDK </span>版本构建过程基于 <span class="s72">OpenJDK 7 </span>构建，只添加了几个部分，例如部署代码，其中包括 <span class="s72">Oracle </span>的 <span class="s72">Java </span>插件和 <span class="s72">Java WebStart</span></p><p class="s71" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 148%;text-align: left;">的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 <span class="s72">Rhino</span>，以及一些零碎的东西，如附加文档或第三方字体。展望未</p><p class="s71" style="padding-left: 23pt;text-indent: 0pt;line-height: 23pt;text-align: left;">来，我们的目的是开源 <span class="s72">Oracle JDK </span>的所有部分，除了我们考虑商业功能的部分。</p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">总结：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l25"><li data-list-text="1."><p class="s67" style="padding-left: 59pt;text-indent: -18pt;line-height: 146%;text-align: left;">Oracle JDK <span class="s66">版本将每三年发布一次，而 </span>OpenJDK <span class="s66">版本每三个月发布一次；</span></p></li><li data-list-text="2."><p class="s67" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;line-height: 191%;text-align: left;">OpenJDK <span class="s66">是一个参考模型并且是完全开源的，而 </span>Oracle JDK <span class="s66">是 </span>OpenJDK <span class="s66">的一个实现，并不是完全开源的；</span></p></li><li data-list-text="3."><p class="s67" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;line-height: 191%;text-align: left;">Oracle JDK <span class="s66">比 </span>OpenJDK <span class="s66">更稳定。</span>OpenJDK <span class="s66">和 </span>Oracle JDK <span class="s66">的代码几乎相同，但 </span>Oracle JDK <span class="s66">有更多的类和一些错误修复。因此，如果您想开发企业</span>/<span class="s66">商业软件，我建议您选择 </span>Oracle JDK<span class="s66">，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 </span>OpenJDK <span class="s66">可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 </span>Oracle JDK <span class="s66">就可以解决问题；</span></p></li><li data-list-text="4."><p class="s66" style="padding-top: 4pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">顶级公司正在使用 <span class="s67">Oracle JDK</span>，例如 <span class="s67">Android Studio</span>，<span class="s67">Minecraft </span>和</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">IntelliJ IDEA <span class="s66">开发工具，其中 </span>Open JDK <span class="s66">不太受欢迎；</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5."><p class="s66" style="padding-left: 59pt;text-indent: -18pt;line-height: 147%;text-align: left;">在响应性和 <span class="s67">JVM </span>性能方面，<span class="s67">Oracle JDK </span>与 <span class="s67">OpenJDK </span>相比提供了更好的性能；</p></li><li data-list-text="6."><p class="s67" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;line-height: 146%;text-align: left;">Oracle JDK <span class="s66">不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</span></p></li><li data-list-text="7."><p class="s67" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;line-height: 191%;text-align: left;">Oracle JDK <span class="s66">根据二进制代码许可协议获得许可，而 </span>OpenJDK <span class="s66">根据 </span>GPL v2 <span class="s66">许可获得许可。</span></p></li></ol></li><li data-list-text="5."><p class="s68" style="padding-top: 10pt;padding-bottom: 2pt;padding-left: 43pt;text-indent: -20pt;text-align: left;">Java <span class="h3">和 </span>C++<span class="h3">的区别</span></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_285.png"/></span></p><p class="s66" style="padding-top: 19pt;padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">我知道很多人没学过 <span class="s67">C++</span>，但是面试官就是没事喜欢拿咱们 <span class="s67">Java </span>和 <span class="s67">C++ </span>比呀！没办法！！！就算没学过 <span class="s67">C++</span>，也要记下来！</p><ul id="l26"><li data-list-text=""><p class="s66" style="padding-top: 7pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">都是面向对象的语言，都支持封装、继承和多态</p></li><li data-list-text=""><p class="s67" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">Java <span class="s66">不提供指针来直接访问内存，程序内存更加安全</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s67" style="padding-left: 59pt;text-indent: -18pt;line-height: 146%;text-align: left;">Java <span class="s66">的类是单继承的，</span>C++ <span class="s66">支持多重继承；虽然 </span>Java <span class="s66">的类不可以多继承，但是接口可以多继承。</span></p></li><li data-list-text=""><p class="s67" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">Java <span class="s66">有自动内存管理机制，不需要程序员手动释放无用内存</span></p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="6."><h3 style="padding-bottom: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 92%;text-align: left;">什么是 <span class="s68">Java </span>程序的主类 应用程序和小程序的主类有何不同</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_286.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">一个程序中可以有多个类，但只能有一个类是主类。在 <span class="s67">Java </span>应用程序中，这个主类是指包含 <span class="s67">main</span>（）方法的类。而在 <span class="s67">Java </span>小程序中，这个主类是一个继承自系统类 <span class="s67">JApplet </span>或 <span class="s67">Applet </span>的子类。应用程序的主类不一定要求是 <span class="s67">public</span>类，但小程序的主类要求必须是 <span class="s67">public </span>类。主类是 <span class="s67">Java </span>程序执行的入口点。</p></li><li data-list-text="7."><p class="s68" style="padding-top: 11pt;padding-bottom: 3pt;padding-left: 43pt;text-indent: -20pt;text-align: left;">Java <span class="h3">应用程序与小程序之间有那些差别</span></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_287.png"/></span></p><p class="s66" style="padding-top: 19pt;padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">简单说应用程序是从主线程启动<span class="s67">(</span>也就是 <span class="s67">main() </span>方法<span class="s67">)</span>。<span class="s67">applet </span>小程序没有 <span class="s67">main </span>方法，主要是嵌在浏览器页面上运行<span class="s67">(</span>调用 <span class="s67">init()</span>线程或者 <span class="s67">run()</span>来启动<span class="s67">)</span>，嵌入浏览器这点跟 <span class="s67">flash </span>的小游戏类似。</p></li><li data-list-text="8."><h3 style="padding-top: 10pt;padding-bottom: 3pt;padding-left: 47pt;text-indent: -24pt;text-align: left;">字符型常量和字符串常量的区别</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_288.png"/></span></p><ol id="l27"><li data-list-text="1."><p class="s66" style="padding-top: 21pt;padding-left: 59pt;text-indent: -18pt;line-height: 147%;text-align: left;">形式上<span class="s67">: </span>字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</p></li><li data-list-text="2."><p class="s66" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;line-height: 191%;text-align: left;">含义上<span class="s67">: </span>字符常量相当于一个整形值<span class="s67">( ASCII </span>值<span class="s67">),</span>可以参加表达式运算 字符串常量代表一个地址值<span class="s67">(</span>该字符串在内存中存放位置<span class="s67">)</span></p></li><li data-list-text="3."><p class="s67" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;line-height: 173%;text-align: left;"><span class="s66">占内存大小 字符常量只占 </span>2 <span class="s66">个字节 字符串常量占若干个字节</span>(<span class="s66">至少一个字符结束标志</span>) (<span class="s65">注意： </span><b>char </b><span class="s65">在 </span><b>Java </b><span class="s65">中占两个字节</span>)</p><p style="text-indent: 0pt;text-align: left;"><span><a href="https://camo.githubusercontent.com/d913ab9b3880feab7d326a0904caac5f5e285a56/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31352f38363733353531392e6a7067"></a></span></p><p class="s72" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">java <span class="s71">编程思想第四版：</span>2.2.2 <span class="s71">节</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="9."><h3 style="padding-top: 13pt;padding-bottom: 3pt;padding-left: 47pt;text-indent: -24pt;text-align: left;">构造器 <span class="s68">Constructor </span>是否可被 <span class="s68">override</span></h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_290.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 148%;text-align: left;">在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以 <span class="s67">Constructor </span>也就不能被 <span class="s67">override</span>（重写）<span class="s67">,</span>但是可以 <span class="s67">overload</span>（重载）<span class="s67">,</span>所以你可以看到一个类中有多个构造函数的情况。</p></li><li data-list-text="10."><h3 style="padding-top: 9pt;padding-bottom: 3pt;padding-left: 57pt;text-indent: -34pt;text-align: left;">重载和重写的区别</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_291.png"/></span></p><p class="s65" style="padding-top: 16pt;padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">重载： <span class="s66">发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">重写： <span class="s66">发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类</span></p><p class="s66" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">方法访问修饰符为 <span class="s67">private </span>则子类就不能重写该方法。</p></li><li data-list-text="11."><p class="s68" style="padding-bottom: 2pt;padding-left: 53pt;text-indent: -30pt;line-height: 32pt;text-align: left;">Java <span class="h3">面向对象编程三大特性</span>: <span class="h3">封装 继承 多态</span></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_292.png"/></span></p><p class="s64" style="padding-top: 18pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">封装</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s64" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">继承</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">关于继承如下 <span class="s70">3 </span>点请记住：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l28"><li data-list-text="1."><p class="s66" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">子类拥有父类非 <span class="s67">private </span>的属性和方法。</p></li><li data-list-text="2."><p class="s66" style="padding-top: 9pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p></li><li data-list-text="3."><p class="s66" style="padding-top: 2pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">子类可以用自己的方式实现父类的方法。（以后介绍）。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s64" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">多态</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 147%;text-align: justify;">在 <span class="s67">Java </span>中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="12."><p class="s68" style="padding-bottom: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 93%;text-align: left;">String StringBuffer <span class="h3">和 </span>StringBuilder <span class="h3">的区别是什么 </span>String <span class="h3">为什么是不可变的</span></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_293.png"/></span></p><p class="s65" style="padding-top: 16pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">可变性</p><p class="s66" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 192%;text-align: left;">简单的来说：<span class="s67">String </span>类中使用 <span class="s67">final </span>关键字字符数组保存字符串，<span class="s75">private final char value[]</span>，所以 <span class="s67">String </span>对象是不可变的。而 <span class="s67">StringBuilder </span>与 <span class="s67">StringBuffer </span>都继承自 <span class="s67">AbstractStringBuilder </span>类，在 <span class="s67">AbstractStringBuilder </span>中</p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 147%;text-align: left;">也是使用字符数组保存字符串 <span class="s75">char[]value </span>但是没有用 <span class="s67">final </span>关键字修饰，所以这两种对象都是可变的。</p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">StringBuilder <span class="s66">与 </span>StringBuffer <span class="s66">的构造方法都是调用父类构造方法也就是</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">AbstractStringBuilder <span class="s66">实现的，大家可以自行查阅源码。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">AbstractStringBuilder.java</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s77" style="padding-top: 1pt;padding-left: 21pt;text-indent: -20pt;line-height: 133%;text-align: left;"><span style=" color: #D73949;">abstract class </span>AbstractStringBuilder <span style=" color: #D73949;">implements </span>Appendable<span style=" color: #24292E;">, </span>CharSequence <span style=" color: #24292E;">{ </span><span style=" color: #D73949;">char</span><span style=" color: #24292E;">[] value;</span></p><p class="s75" style="padding-left: 21pt;text-indent: 0pt;line-height: 133%;text-align: left;"><span style=" color: #D73949;">int </span>count; <span style=" color: #6F42C1;">AbstractStringBuilder</span>() {</p><p class="s75" style="padding-left: 21pt;text-indent: 0pt;text-align: left;">}</p><p class="s75" style="padding-top: 3pt;padding-left: 41pt;text-indent: -20pt;line-height: 133%;text-align: left;"><span style=" color: #6F42C1;">AbstractStringBuilder</span>(<span style=" color: #D73949;">int </span><span style=" color: #E36209;">capacity</span>) { value <span style=" color: #D73949;">= new </span>char[capacity];</p><p class="s75" style="padding-left: 21pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-left: 23pt;text-indent: 0pt;line-height: 17pt;text-align: left;">线程安全性</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">String <span class="s66">中的对象是不可变的，也就可以理解为常量，线程安全。 </span>AbstractStringBuilder <span class="s66">是 </span>StringBuilder <span class="s66">与 </span>StringBuffer <span class="s66">的公共父类，定义了一些字符串的基本操作，如 </span>expandCapacity<span class="s66">、</span>append<span class="s66">、</span>insert<span class="s66">、</span>indexOf <span class="s66">等公共方法。</span>StringBuffer <span class="s66">对方法加了同步锁或者对调用的方法加了同步锁，所以</span></p><p class="s66" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 147%;text-align: left;">是线程安全的。<span class="s67">StringBuilder </span>并没有对方法进行加同步锁，所以是非线程安全的。</p><p class="s65" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">性能</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">每次对 <span class="s67">String </span>类型进行改变的时候，都会生成一个新的 <span class="s67">String </span>对象，然后将指针指向新的 <span class="s67">String </span>对象。<span class="s67">StringBuffer </span>每次都会对 <span class="s67">StringBuffer </span>对象本身</p><p class="s66" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 148%;text-align: left;">进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <span class="s67">StringBuilder </span>相比使用 <span class="s67">StringBuffer </span>仅能获得 <span class="s67">10%~15% </span>左右的性能提升，但却要冒多线程不安全的风险。</p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">对于三者使用的总结：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l29"><li data-list-text="1."><p class="s66" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">操作少量的数据 <span class="s67">= String</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s66" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">单线程操作字符串缓冲区下操作大量数据 <span class="s67">= StringBuilder</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s66" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">多线程操作字符串缓冲区下操作大量数据 <span class="s67">= StringBuffer</span></p></li></ol></li></ol></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l30"><li data-list-text="13."><h3 style="padding-bottom: 3pt;padding-left: 57pt;text-indent: -34pt;text-align: left;">自动装箱与拆箱</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_294.png"/></span></p><p class="s65" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 125%;text-align: left;">装箱<span class="s66">：将基本类型用它们对应的引用类型包装起来；</span>拆箱<span class="s66">：将包装类型转换为基本数据类型；</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="14."><h3 style="padding-bottom: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 92%;text-align: left;">在一个静态方法内调用一个非静态成员为什么是非法的</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_295.png"/></span></p><p class="s66" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="15."><h3 style="padding-bottom: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 92%;text-align: left;">在 <span class="s68">Java </span>中定义一个不做事且没有参数的构造方法的作用</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_296.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 12pt;line-height: 191%;text-align: left;">Java <span class="s66">程序在执行子类的构造方法之前，如果没有用 </span>super() <span class="s66">来调用父类特定的构造方法，则会调用父类中</span>“<span class="s66">没有参数的构造方法</span>”<span class="s66">。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 </span>super() <span class="s66">来调用父类</span></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">中特定的构造方法，则编译时将发生错误，因为 <span class="s67">Java </span>程序在父类中找不到没</p><p class="s66" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p></li><li data-list-text="16."><p class="s68" style="padding-bottom: 2pt;padding-left: 53pt;text-indent: -30pt;line-height: 32pt;text-align: left;">import java <span class="h3">和 </span>javax <span class="h3">有什么区别</span></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_297.png"/></span></p><p class="s66" style="padding-top: 19pt;padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">刚开始的时候 <span class="s67">JavaAPI </span>所必需的包是 <span class="s67">java </span>开头的包，<span class="s67">javax </span>当时只是扩展 <span class="s67">API </span>包来说使用。然而随着时间的推移，<span class="s67">javax </span>逐渐的扩展成为 <span class="s67">Java API </span>的组成部分。但是，将扩展从 <span class="s67">javax </span>包移动到 <span class="s67">java </span>包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 <span class="s67">javax </span>包将成为标准 <span class="s67">API </span>的一部分。</p><p class="s66" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">所以，实际上 <span class="s67">java </span>和 <span class="s67">javax </span>没有区别。这都是一个名字。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="17."><h3 style="padding-bottom: 2pt;padding-left: 57pt;text-indent: -34pt;text-align: left;">接口和抽象类的区别是什么</h3></li></ol><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_298.png"/></span></p><ol id="l31"><li data-list-text="1."><p class="s66" style="padding-top: 21pt;padding-left: 59pt;text-indent: -18pt;line-height: 147%;text-align: left;">接口的方法默认是 <span class="s67">public</span>，所有方法在接口中不能有实现<span class="s67">(Java 8 </span>开始接口方法可以有默认实现），抽象类可以有非抽象的方法</p></li><li data-list-text="2."><p class="s66" style="padding-top: 3pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">接口中的实例变量默认是 <span class="s67">final </span>类型的，而抽象类中则不一定</p></li><li data-list-text="3."><p class="s66" style="padding-top: 9pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">一个类可以实现多个接口，但最多只能实现一个抽象类</p></li><li data-list-text="4."><p class="s66" style="padding-top: 2pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">一个类实现接口的话要实现接口的所有方法，而抽象类不一定</p></li><li data-list-text="5."><p class="s66" style="padding-top: 10pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">接口不能用 <span class="s67">new </span>实例化，但可以声明，但是必须引用一个实现该接口</p></li></ol><p class="s66" style="padding-top: 7pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l32"><li data-list-text="18."><h3 style="padding-bottom: 3pt;padding-left: 57pt;text-indent: -34pt;text-align: left;">成员变量与局部变量的区别有那些</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_299.png"/></span></p><ol id="l33"><li data-list-text="1."><p class="s66" style="padding-top: 13pt;padding-left: 59pt;text-indent: -18pt;line-height: 146%;text-align: left;">从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 <span class="s67">public,private,static </span>等修饰符所</p><p class="s66" style="padding-top: 7pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">修饰，而局部变量不能被访问控制修饰符及 <span class="s67">static </span>所修饰；但是，成员</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">变量和局部变量都能被 <span class="s67">final </span>所修饰；</p></li><li data-list-text="2."><p class="s66" style="padding-top: 9pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存</p></li><li data-list-text="3."><p class="s66" style="padding-top: 4pt;padding-left: 59pt;text-indent: -18pt;text-align: justify;">从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p></li><li data-list-text="4."><p class="s66" style="padding-top: 2pt;padding-left: 59pt;text-indent: -18pt;line-height: 146%;text-align: justify;">成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 <span class="s67">final </span>修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="19."><h3 style="padding-bottom: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 93%;text-align: left;">创建一个对象用什么运算符<span class="s68">?</span>对象实体与对象引用有何不同<span class="s68">?</span></h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_300.png"/></span></p><p class="s67" style="padding-top: 19pt;padding-left: 23pt;text-indent: 0pt;line-height: 190%;text-align: justify;">new <span class="s66">运算符，</span>new <span class="s66">创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 </span>0 <span class="s66">个或 </span>1 <span class="s66">个对象</span></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: justify;">（一根绳子可以不系气球，也可以系一个气球）<span class="s67">;</span>一个对象可以有 <span class="s67">n </span>个引用指向它（可以用 <span class="s67">n </span>条绳子系住一个气球）。</p></li><li data-list-text="20."><h3 style="padding-top: 12pt;padding-bottom: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 93%;text-align: left;">什么是方法的返回值<span class="s68">?</span>返回值在类的方法里的作用是什么<span class="s68">?</span></h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_301.png"/></span></p><p class="s66" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;line-height: 148%;text-align: justify;">方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用<span class="s67">:</span>接收出结果，使得它可以用于其他的操作！</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="21."><h3 style="padding-bottom: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 93%;text-align: left;">一个类的构造方法的作用是什么 若一个类没有声明构造方法<span class="s68">,</span>该程序能正确执行吗 <span class="s68">?</span>为什么<span class="s68">?</span></h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_302.png"/></span></p><p class="s66" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="22."><h3 style="padding-bottom: 2pt;padding-left: 57pt;text-indent: -34pt;text-align: left;">构造方法有哪些特性</h3></li></ol><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_303.png"/></span></p><ol id="l34"><li data-list-text="1."><p class="s66" style="padding-top: 13pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">名字与类名相同；</p></li><li data-list-text="2."><p class="s66" style="padding-top: 3pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">没有返回值，但不能用 <span class="s67">void </span>声明构造函数；</p></li><li data-list-text="3."><p class="s66" style="padding-top: 9pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">生成类的对象时自动执行，无需调用。</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-bottom: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">23. <span class="h3">静态方法和实例方法有何不同</span></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_304.png"/></span></p><ol id="l35"><li data-list-text="1."><p class="s66" style="padding-top: 19pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">在外部调用静态方法时，可以使用<span class="s67">&quot;</span>类名<span class="s67">.</span>方法名<span class="s67">&quot;</span>的方式，也可以使用<span class="s67">&quot;</span>对</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 59pt;text-indent: 0pt;line-height: 147%;text-align: left;">象名<span class="s67">.</span>方法名<span class="s67">&quot;</span>的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p></li><li data-list-text="2."><p class="s66" style="padding-top: 4pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无</p></li></ol><p class="s66" style="padding-top: 7pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">此限制<span class="s67">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l36"><li data-list-text="24."><h3 style="padding-bottom: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 92%;text-align: left;">对象的相等与指向他们的引用相等，两者有什么不同？</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_305.png"/></span></p><p class="s66" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="25."><h3 style="padding-bottom: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 93%;text-align: left;">在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是<span class="s68">?</span></h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_306.png"/></span></p><p class="s66" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">帮助子类做初始化工作。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s68" style="padding-bottom: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">26. == <span class="h3">与 </span>equals(<span class="h3">重要</span>)</p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_307.png"/></span></p><p class="s67" style="padding-top: 19pt;padding-left: 23pt;text-indent: 0pt;line-height: 190%;text-align: left;"><b>== </b>: <span class="s66">它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。</span>(<span class="s66">基本数据类型</span>==<span class="s66">比较的是值，引用数据类型</span>==<span class="s66">比较的是内存地址</span>)</p><p class="s70" style="padding-top: 13pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">equals() <span class="s67">: </span><span class="s66">它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</span></p><ul id="l37"><li data-list-text=""><p class="s66" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;line-height: 191%;text-align: justify;">情况 <span class="s67">1</span>：类没有覆盖 <span class="s67">equals() </span>方法。则通过 <span class="s67">equals() </span>比较该类的两个对象时，等价于通过<span class="s67">“==”</span>比较这两个对象。</p></li><li data-list-text=""><p class="s66" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;line-height: 191%;text-align: justify;">情况 <span class="s67">2</span>：类覆盖了 <span class="s67">equals() </span>方法。一般，我们都覆盖 <span class="s67">equals() </span>方法来两个对象的内容相等；若它们的内容相等，则返回 <span class="s67">true (</span>即，认为这两个对象相等<span class="s67">)</span>。</p><p class="s65" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">举个例子：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s76" style="padding-top: 1pt;padding-left: 1pt;text-indent: 0pt;text-align: left;">public class <span style=" color: #6F42C1;">test1 </span><span style=" color: #24292E;">{</span></p><p class="s75" style="padding-top: 3pt;padding-left: 41pt;text-indent: -20pt;line-height: 129%;text-align: left;"><span style=" color: #D73949;">public static void </span><span style=" color: #6F42C1;">main</span>(<span style=" color: #D73949;">String</span>[] <span style=" color: #E36209;">args</span>) { String a <span style=" color: #D73949;">= new </span>String(<span style=" color: #032F62;">&quot;ab&quot;</span>); <span style=" color: #6A737D;">// a </span><span class="s80">为一个引用</span></p><p class="s75" style="padding-left: 41pt;text-indent: 0pt;line-height: 12pt;text-align: left;">String b <span style=" color: #D73949;">= new </span>String(<span style=" color: #032F62;">&quot;ab&quot;</span>); <span style=" color: #6A737D;">// b </span><span class="s80">为另一个引用</span><span style=" color: #6A737D;">,</span><span class="s80">对象的内容一样</span></p><p class="s75" style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;line-height: 124%;text-align: left;">String aa <span style=" color: #D73949;">= </span><span style=" color: #032F62;">&quot;ab&quot;</span>; <span style=" color: #6A737D;">// </span><span class="s80">放在常量池中 </span>String bb <span style=" color: #D73949;">= </span><span style=" color: #032F62;">&quot;ab&quot;</span>; <span style=" color: #6A737D;">// </span><span class="s80">从常量池中查找 </span><span style=" color: #D73949;">if </span>(aa <span style=" color: #D73949;">== </span>bb) <span style=" color: #6A737D;">// true</span></p><p class="s75" style="padding-top: 1pt;padding-left: 41pt;text-indent: 20pt;line-height: 129%;text-align: left;">System<span style=" color: #D73949;">.</span>out<span style=" color: #D73949;">.</span>println(<span style=" color: #032F62;">&quot;aa==bb&quot;</span>); <span style=" color: #D73949;">if </span>(a <span style=" color: #D73949;">== </span>b) <span style=" color: #6A737D;">// false</span><span class="s80">，非同一对象</span></p><p class="s75" style="padding-left: 41pt;text-indent: 20pt;line-height: 133%;text-align: left;">System<span style=" color: #D73949;">.</span>out<span style=" color: #D73949;">.</span>println(<span style=" color: #032F62;">&quot;a==b&quot;</span>); <span style=" color: #D73949;">if </span>(a<span style=" color: #D73949;">.</span>equals(b)) <span style=" color: #6A737D;">// true</span></p><p class="s75" style="padding-left: 41pt;text-indent: 20pt;line-height: 133%;text-align: left;">System<span style=" color: #D73949;">.</span>out<span style=" color: #D73949;">.</span>println(<span style=" color: #032F62;">&quot;aEQb&quot;</span>); <span style=" color: #D73949;">if </span>(<span style=" color: #005CC5;">42 </span><span style=" color: #D73949;">== </span><span style=" color: #005CC5;">42.0</span>) { <span style=" color: #6A737D;">// true</span></p><p class="s75" style="padding-left: 61pt;text-indent: 0pt;text-align: left;">System<span style=" color: #D73949;">.</span>out<span style=" color: #D73949;">.</span>println(<span style=" color: #032F62;">&quot;true&quot;</span>);</p><p class="s75" style="padding-top: 3pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p class="s75" style="padding-top: 3pt;padding-left: 21pt;text-indent: 0pt;text-align: left;">}</p><p class="s75" style="padding-top: 3pt;padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s65" style="padding-left: 23pt;text-indent: 0pt;line-height: 17pt;text-align: left;">说明：</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s67" style="padding-left: 59pt;text-indent: -18pt;line-height: 190%;text-align: left;">String <span class="s66">中的 </span>equals <span class="s66">方法是被重写过的，因为 </span>object <span class="s66">的 </span>equals <span class="s66">方法是比较的对象的内存地址，而 </span>String <span class="s66">的 </span>equals <span class="s66">方法比较的是对象的值。</span></p></li><li data-list-text=""><p class="s66" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;line-height: 148%;text-align: left;">当创建 <span class="s67">String </span>类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <span class="s67">String </span>对象。</p></li></ul></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l38"><li data-list-text="27."><p class="s68" style="padding-bottom: 2pt;padding-left: 53pt;text-indent: -30pt;text-align: left;">hashCode <span class="h3">与 </span>equals<span class="h3">（重要）</span></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_308.png"/></span></p><p class="s66" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">面试官可能会问你：<span class="s67">“</span>你重写过 <span class="s67">hashcode </span>和 <span class="s67">equals </span>么，为什么重写 <span class="s67">equals</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">时必须重写 <span class="s67">hashCode </span>方法？<span class="s67">”</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">hashCode<span class="s64">（）介绍</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;line-height: 190%;text-align: left;">hashCode() <span class="s66">的作用是获取哈希码，也称为散列码；它实际上是返回一个 </span>int <span class="s66">整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。</span>hashCode() <span class="s66">定义</span></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 147%;text-align: left;">在 <span class="s67">JDK </span>的 <span class="s67">Object.java </span>中，这就意味着 <span class="s67">Java </span>中的任何类都包含有 <span class="s67">hashCode() </span>函数。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">散列表存储的是键值对<span class="s67">(key-value)</span>，它的特点是：能根据<span class="s67">“</span>键<span class="s67">”</span>快速的检索出对应的<span class="s67">“</span>值<span class="s67">”</span>。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p class="s64" style="padding-top: 12pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">为什么要有 <span class="s69">hashCode</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">我们以<span class="s70">“HashSet </span>如何检查重复<span class="s70">”</span>为例子来说明为什么要有 <span class="s70">hashCode</span>：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">当你把对象加入 <span class="s67">HashSet </span>时，<span class="s67">HashSet </span>会先计算对象的 <span class="s67">hashcode </span>值来判断对象加入的位置，同时也会与其他已经加入的对象的 <span class="s67">hashcode </span>值作比较，如果没有相符的 <span class="s67">hashcode</span>，<span class="s67">HashSet </span>会假设对象没有重复出现。但是如果发现有相同 <span class="s67">hashcode </span>值的对象，这时会调用 <span class="s67">equals</span>（）方法来检查 <span class="s67">hashcode </span>相等的对象是否真的相同。如果两者相同，<span class="s67">HashSet </span>就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 <span class="s67">Java </span>启蒙书《<span class="s67">Head</span></p><p class="s67" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 146%;text-align: left;">first java<span class="s66">》第二版）。这样我们就大大减少了 </span>equals <span class="s66">的次数，相应就大大提高了执行速度。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">hashCode<span class="s64">（）与 </span>equals<span class="s64">（）的相关规定</span></p><ol id="l39"><li data-list-text="1."><p class="s66" style="padding-top: 3pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">如果两个对象相等，则 <span class="s67">hashcode </span>一定也是相同的</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s66" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">两个对象相等<span class="s67">,</span>对两个对象分别调用 <span class="s67">equals </span>方法都返回 <span class="s67">true</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s66" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">两个对象有相同的 <span class="s67">hashcode </span>值，它们也不一定是相等的</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s65" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">因此，<span class="s70">equals </span>方法被覆盖过，则 <span class="s70">hashCode </span>方法也必须被覆盖</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5."><p class="s67" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">hashCode() <span class="s66">的默认行为是对堆上的对象产生独特值。如果没有重写</span></p></li></ol></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 59pt;text-indent: 0pt;line-height: 146%;text-align: left;">hashCode()<span class="s66">，则该 </span>class <span class="s66">的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</span></p><ol id="l40"><li data-list-text="28."><h3 style="padding-top: 10pt;padding-bottom: 3pt;padding-left: 57pt;text-indent: -34pt;text-align: left;">为什么 <span class="s68">Java </span>中只有值传递</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_309.png"/></span></p><p style="padding-top: 19pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;"><a href="https://github.com/Snailclimb/Java-Guide/blob/master/%25E9%259D%25A2%25E8%25AF%2595%25E5%25BF%2585%25E5%25A4%2587/%25E6%259C%2580%25E6%259C%2580%25E6%259C%2580%25E5%25B8%25B8%25E8%25A7%2581%25E7%259A%2584Java%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598%25E6%2580%25BB%25E7%25BB%2593/%25E7%25AC%25AC%25E4%25B8%2580%25E5%2591%25A8%25EF%25BC%25882018-8-7%25EF%25BC%2589.md" class="s82" target="_blank">为什么 </a><a href="https://github.com/Snailclimb/Java-Guide/blob/master/%25E9%259D%25A2%25E8%25AF%2595%25E5%25BF%2585%25E5%25A4%2587/%25E6%259C%2580%25E6%259C%2580%25E6%259C%2580%25E5%25B8%25B8%25E8%25A7%2581%25E7%259A%2584Java%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598%25E6%2580%25BB%25E7%25BB%2593/%25E7%25AC%25AC%25E4%25B8%2580%25E5%2591%25A8%25EF%25BC%25882018-8-7%25EF%25BC%2589.md" class="s83" target="_blank">Java </a><a href="https://github.com/Snailclimb/Java-Guide/blob/master/%25E9%259D%25A2%25E8%25AF%2595%25E5%25BF%2585%25E5%25A4%2587/%25E6%259C%2580%25E6%259C%2580%25E6%259C%2580%25E5%25B8%25B8%25E8%25A7%2581%25E7%259A%2584Java%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598%25E6%2580%25BB%25E7%25BB%2593/%25E7%25AC%25AC%25E4%25B8%2580%25E5%2591%25A8%25EF%25BC%25882018-8-7%25EF%25BC%2589.md" class="s82" target="_blank">中只有值传递？</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="29."><h3 style="padding-bottom: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 92%;text-align: left;">简述线程，程序、进程的基本概念。以及他们之间关系是什么</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_310.png"/></span></p><p class="s65" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;line-height: 93%;text-align: justify;">线程<span class="s66">与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工</span></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p class="s65" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;line-height: 86%;text-align: left;">程序<span class="s66">是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</span></p><p class="s65" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;line-height: 93%;text-align: left;">进程<span class="s66">是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态 的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行</span></p><p class="s66" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">着，同时，每个进程还占有某些系统资源如 <span class="s67">CPU </span>时间，内存空间，文件，文</p><p class="s66" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段</p><p class="s66" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="30."><h3 style="padding-bottom: 2pt;padding-left: 57pt;text-indent: -34pt;text-align: left;">线程有哪些基本状态<span class="s68">?</span></h3></li></ol><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_311.png"/></span></p><p class="s66" style="padding-top: 19pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">参考《<span class="s67">Java </span>并发编程艺术》<span class="s67">4.1.4 </span>节。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;line-height: 146%;text-align: left;">Java <span class="s66">线程在运行的生命周期中的指定时刻只可能处于下面 </span>6 <span class="s66">种不同状态的其中一个状态。</span></p><p class="s66" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 148%;text-align: left;">线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。<span class="s67">Java </span>线程状态变迁如下图所示：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l41"><li data-list-text="31"><h3 style="padding-bottom: 3pt;padding-left: 52pt;text-indent: -29pt;text-align: left;">关于 <span class="s68">final </span>关键字的一些总结</h3><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_312.png"/></span></p><p class="s67" style="padding-top: 19pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">final <span class="s66">关键字主要用在三个地方：变量、方法、类。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l42"><li data-list-text="1."><p class="s66" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">对于一个 <span class="s67">final </span>变量，如果是基本数据类型的变量，则其数值一旦在初始</p><p class="s66" style="padding-top: 7pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p></li><li data-list-text="2."><p class="s66" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;line-height: 191%;text-align: left;">当用 <span class="s67">final </span>修饰一个类时，表明这个类不能被继承。<span class="s67">final </span>类中的所有成员方法都会被隐式地指定为 <span class="s67">final </span>方法。</p></li><li data-list-text="3."><p class="s66" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;line-height: 191%;text-align: left;">使用 <span class="s67">final </span>方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 <span class="s67">Java </span>实现版本中，会将 <span class="s67">final </span>方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 <span class="s67">Java </span>版本已经不需要使用 <span class="s67">final </span>方法进行这些优化了）。类中所有的 <span class="s67">private </span>方法都隐式地指定为 <span class="s67">final</span>。</p></li></ol></li><li data-list-text="32"><p class="s68" style="padding-top: 11pt;padding-bottom: 3pt;padding-left: 48pt;text-indent: -25pt;text-align: left;">Java <span class="h3">中的异常处理</span></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_313.png"/></span></p><p class="s69" style="padding-left: 23pt;text-indent: 0pt;line-height: 28pt;text-align: left;">Java <span class="s64">异常类层次结构图</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span><a href="https://camo.githubusercontent.com/e6b358c7ceca03c7128d52004c45a746728c76f4/687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3634313030332f3230313630372f3634313030332d32303136303730363233323034343238302d3335353335343739302e706e67"></a></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-top: 5pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">在 <span class="s67">Java </span>中，所有的异常都有一个共同的祖先 <span class="s67">java.lang </span>包中的 <span class="s70">Throwable</span></p><p class="s66" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;"><span class="s65">类</span>。<span class="s67">Throwable</span>： 有两个重要的子类：<span class="s70">Exception</span><span class="s65">（异常） </span>和 <span class="s70">Error</span><span class="s65">（错误） </span>，二者都是 <span class="s67">Java </span>异常处理的重要子类，各自都包含大量子类。</p><p class="s66" style="padding-top: 12pt;padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;"><span class="s70">Error</span><span class="s65">（错误）</span><span class="s70">:</span><span class="s65">是程序无法处理的错误</span>，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 <span class="s67">JVM</span>（<span class="s67">Java </span>虚拟</p><p class="s66" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">机）出现的问题。例如，<span class="s67">Java </span>虚拟机运行错误（<span class="s67">Virtual MachineError</span>），当 <span class="s67">JVM </span>不再有继续执行操作所需的内存资源时，将出现 <span class="s67">OutOfMemoryError</span>。这些异常发生时，<span class="s67">Java </span>虚拟机（<span class="s67">JVM</span>）一般会选择线程终止。</p><p class="s66" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如</p><p class="s67" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Java <span class="s66">虚拟机运行错误（</span>Virtual MachineError<span class="s66">）、类定义错误</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">（<span class="s67">NoClassDefFoundError</span>）等。这些错误是不可查的，因为它们在应用程序的</p><p class="s66" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它</p><p class="s66" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">所引起的异常状况。在 <span class="s67">Java </span>中，错误通过 <span class="s67">Error </span>的子类描述。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;"><span class="s70">Exception</span><span class="s65">（异常）</span><span class="s70">:</span><span class="s65">是程序本身可以处理的异常</span>。<span class="s67">Exception </span>类有一个重要的子类 <span class="s70">RuntimeException</span>。<span class="s67">RuntimeException </span>异常由 <span class="s67">Java </span>虚拟机抛出。</p><p class="s66" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;"><span class="s70">NullPointerException</span>（要访问的变量没有引用任何对象时，抛出该异常）、 <span class="s70">ArithmeticException</span>（算术运算异常，一个整数除以 <span class="s67">0 </span>时，抛出该异常）和 <span class="s70">ArrayIndexOutOfBoundsException </span>（下标越界异常）。</p><p class="s65" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Throwable <span class="s64">类常用方法</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l43"><li data-list-text=""><p class="s70" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">public string getMessage()<span class="s67">:</span><span class="s66">返回异常发生时的详细信息</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s70" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">public string toString()<span class="s67">:</span><span class="s66">返回异常发生时的简要描述</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s67" style="padding-left: 59pt;text-indent: -18pt;line-height: 191%;text-align: justify;"><b>public string getLocalizedMessage()</b>:<span class="s66">返回异常对象的本地化信息。使用 </span>Throwable <span class="s66">的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 </span>getMessage<span class="s66">（）返回的结果相同</span></p></li><li data-list-text=""><p class="s67" style="padding-top: 4pt;padding-left: 59pt;text-indent: -18pt;line-height: 146%;text-align: left;"><b>public void printStackTrace()</b>:<span class="s66">在控制台上打印 </span>Throwable <span class="s66">对象封装的异常信息</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s64" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">异常处理总结</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s67" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">try <span class="s66">块：用于捕获异常。其后可接零个或多个 </span>catch <span class="s66">块，如果没有 </span>catch</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">块，则必须跟一个 <span class="s67">finally </span>块。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s67" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">catch <span class="s66">块：用于处理 </span>try <span class="s66">捕获到的异常。</span></p></li><li data-list-text=""><p class="s67" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">finally <span class="s66">块：无论是否捕获或处理异常，</span>finally <span class="s66">块里的语句都会被执行。</span></p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 59pt;text-indent: 0pt;line-height: 147%;text-align: left;">当在 <span class="s67">try </span>块或 <span class="s67">catch </span>块中遇到 <span class="s67">return </span>语句时，<span class="s67">finally </span>语句块将在方法返回之前被执行。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">在以下 <span class="s70">4 </span>种特殊情况下，<span class="s70">finally </span>块不会被执行：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l44"><li data-list-text="1."><p class="s66" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">在 <span class="s67">finally </span>语句块中发生了异常。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s66" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">在前面的代码中用了 <span class="s67">System.exit()</span>退出程序。</p></li><li data-list-text="3."><p class="s66" style="padding-top: 9pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">程序所在的线程死亡。</p></li><li data-list-text="4."><p class="s66" style="padding-top: 10pt;padding-left: 58pt;text-indent: -18pt;text-align: left;">关闭 <span class="s67">CPU</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="33"><p class="s68" style="padding-bottom: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 92%;text-align: left;">Java <span class="h3">序列化中如果有些字段不想进行序列化 怎么办</span></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_315.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">对于不想进行序列化的变量，使用 <span class="s67">transient </span>关键字修饰。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">transient <span class="s66">关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 </span>transient <span class="s66">修饰的变量值不会被持久化和恢复。 </span>transient <span class="s66">只能修饰变量，不能修饰类和方法。</span></p></li><li data-list-text="34"><h3 style="padding-top: 10pt;padding-bottom: 2pt;padding-left: 52pt;text-indent: -29pt;text-align: left;">获取用键盘输入常用的的两种方法</h3></li></ol><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="558" height="1" alt="image" src="整合_files/Image_316.png"/></span></p><p class="s66" style="padding-top: 19pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">方法 <span class="s67">1</span>：通过 <span class="s67">Scanner</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s75" style="padding-top: 1pt;padding-left: 1pt;text-indent: 0pt;line-height: 133%;text-align: left;">Scanner input <span style=" color: #D73949;">= new </span>Scanner(System<span style=" color: #D73949;">.</span>in); String s <span style=" color: #D73949;">= </span>input<span style=" color: #D73949;">.</span>nextLine();</p><p class="s75" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">input<span style=" color: #D73949;">.</span>close();</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s66" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">方法 <span class="s67">2</span>：通过 <span class="s67">BufferedReader</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="42" alt="image" src="整合_files/Image_317.png"/></span></p><p class="s75" style="padding-top: 1pt;padding-left: 1pt;text-indent: 0pt;text-align: left;">BufferedReader input <span style=" color: #D73949;">= new </span>BufferedReader(<span style=" color: #D73949;">new </span>InputStreamReader(System<span style=" color: #D73949;">.</span>in));</p><p class="s75" style="padding-top: 3pt;padding-left: 1pt;text-indent: 0pt;text-align: left;">String s <span style=" color: #D73949;">= </span>input<span style=" color: #D73949;">.</span>readLine();</p><p style="text-indent: 0pt;text-align: left;"/><ol id="l45"><li data-list-text="1."><p class="s84" style="padding-top: 2pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">Kafka <span class="p">的设计时什么样的呢？</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Kafka <span class="p">将消息以 </span>topic <span class="p">为单位进行归纳</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">将向 <span class="s84">Kafka topic </span>发布消息的程序成为 <span class="s84">producers.</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">将预订 <span class="s84">topics </span>并消费消息的程序成为 <span class="s84">consumer.</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Kafka <span class="p">以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个 </span>broker. producers <span class="p">通过网络将消息发送到 </span>Kafka <span class="p">集群，集群向消费者提供消息</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p style="padding-left: 31pt;text-indent: -8pt;text-align: left;">数据传输的事物定义有哪三种？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">数据传输的事务定义通常有以下三种级别：</p><ol id="l46"><li data-list-text="（1）"><p style="padding-top: 2pt;padding-left: 49pt;text-indent: -26pt;text-align: left;">最多一次<span class="s84">: </span>消息不会被重复发送，最多被传输一次，但也有可能一次不传输</p></li><li data-list-text="（2）"><p style="padding-top: 2pt;padding-left: 49pt;text-indent: -26pt;text-align: left;">最少一次<span class="s84">: </span>消息不会被漏发送，最少被传输一次，但也有可能被重复传输<span class="s84">.</span></p></li><li data-list-text="（3）"><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">精确的一次（<span class="s84">Exactly once</span>）<span class="s84">: </span>不会漏传输也不会重复传输<span class="s84">,</span>每个消息都传输被一次而且仅仅被传输一次，这是大家所期望的</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s84" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">Kafka <span class="p">判断一个节点是否还活着有那两个条件？</span></p><ol id="l47"><li data-list-text="（1）"><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">节点必须可以维护和 <span class="s84">ZooKeeper </span>的连接，<span class="s84">Zookeeper </span>通过心跳机制检查每个节点的连接</p></li><li data-list-text="（2）"><p style="padding-left: 49pt;text-indent: -26pt;line-height: 13pt;text-align: left;">如果节点是个 <span class="s84">follower,</span>他必须能及时的同步 <span class="s84">leader </span>的写操作，延时不能太久</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s84" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">producer <span class="p">是否直接将数据发送到 </span>broker <span class="p">的 </span>leader(<span class="p">主节点</span>)<span class="p">？</span></p></li></ol><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">producer <span class="p">直接将数据发送到 </span>broker <span class="p">的 </span>leader(<span class="p">主节点</span>)<span class="p">，不需要在多个节点进行分发，为了帮助 </span>producer <span class="p">做到这点，所有的 </span>Kafka <span class="p">节点都可以及时的告知</span>:<span class="p">哪些节点是活动的，目标 </span>topic <span class="p">目标分区的 </span>leader <span class="p">在哪。这样 </span>producer <span class="p">就可以直接将消息发送到目的地了</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">5<span class="p">、</span>Kafa consumer <span class="p">是否可以消费指定分区消息？</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Kafa  consumer <span class="p">消费消息时，向 </span>broker <span class="p">发出</span>&quot;fetch&quot;<span class="p">请求去消费特定分区的消息，</span>consumer<span class="p">指定消息在日志中的偏移量（</span>offset<span class="p">），就可以消费从这个位置开始的消息，</span>customer <span class="p">拥有了 </span>offset <span class="p">的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">6<span class="p">、</span>Kafka <span class="p">消息是采用 </span>Pull <span class="p">模式，还是 </span>Push <span class="p">模式？</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Kafka <span class="p">最初考虑的问题是，</span>customer <span class="p">应该从 </span>brokes <span class="p">拉取消息还是 </span>brokers <span class="p">将消息推送到 </span>consumer<span class="p">，也就是 </span>pull <span class="p">还 </span>push<span class="p">。在这方面，</span>Kafka <span class="p">遵循了一种大部分消息系统共同的传统的设计：</span>producer <span class="p">将消息推送到 </span>broker<span class="p">，</span>consumer <span class="p">从 </span>broker <span class="p">拉取消息</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">一些消息系统比如 <span class="s84">Scribe </span>和 <span class="s84">Apache     Flume </span>采用了 <span class="s84">push </span>模式，将消息推送到下游的 <span class="s84">consumer</span>。这样做有好处也有坏处：由 <span class="s84">broker </span>决定消息推送的速率，对于不同消费速率的 <span class="s84">consumer </span>就不太好处理了。消息系统都致力于让 <span class="s84">consumer </span>以最大的速率最快速的消费消息，但不幸的是，<span class="s84">push </span>模式下，当 <span class="s84">broker </span>推送的速率远大于 <span class="s84">consumer </span>消费的速率时， <span class="s84">consumer </span>恐怕就要崩溃了。最终 <span class="s84">Kafka </span>还是选取了传统的 <span class="s84">pull </span>模式</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Pull <span class="p">模式的另外一个好处是 </span>consumer <span class="p">可以自主决定是否批量的从 </span>broker <span class="p">拉取数据。</span>Push <span class="p">模式必须在不知道下游 </span>consumer <span class="p">消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。如果为了避免 </span>consumer <span class="p">崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。</span>Pull <span class="p">模式下，</span>consumer <span class="p">就可以根据自己的消费能力去决</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">定这些策略</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Pull <span class="p">有个缺点是，如果 </span>broker <span class="p">没有可供消费的消息，将导致 </span>consumer <span class="p">不断在循环中轮询，直到新消息到 </span>t <span class="p">达。为了避免这点，</span>Kafka <span class="p">有个参数可以让 </span>consumer <span class="p">阻塞知道新消息到达 </span>(<span class="p">当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l48"><li data-list-text="7."><p class="s84" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">Kafka <span class="p">存储在硬盘上的消息格式是什么？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">消息由一个固定长度的头部和可变长度的字节数组组成。头部包含了一个版本号和 <span class="s84">CRC32</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">校验码。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">消息长度</span>: 4 bytes (value: 1+4+n)</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">版本号</span>: 1 byte</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">CRC <span class="p">校验码</span>: 4 bytes</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">具体的消息</span>: n bytes</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="8."><p class="s84" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">Kafka <span class="p">高效文件存储设计特点：</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">(1).Kafka <span class="p">把 </span>topic <span class="p">中一个 </span>parition <span class="p">大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</span></p><ol id="l49"><li data-list-text="(2)."><p style="padding-left: 37pt;text-indent: -14pt;line-height: 13pt;text-align: left;">通过索引信息可以快速定位 <span class="s84">message </span>和确定 <span class="s84">response </span>的最大大小。</p></li><li data-list-text="(3)."><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">通过 <span class="s84">index </span>元数据全部映射到 <span class="s84">memory</span>，可以避免 <span class="s84">segment file </span>的 <span class="s84">IO </span>磁盘操作。 <span class="s84">(4).</span>通过索引文件稀疏存储，可以大幅降低 <span class="s84">index </span>文件元数据占用空间大小。</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="9."><p class="s84" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">Kafka <span class="p">与传统消息系统之间有三个关键区别</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">(1).Kafka <span class="p">持久化日志，这些日志可以被重复读取和无限期保留</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">(2).Kafka <span class="p">是一个分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过复制数据提升容错能力和高可用性</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">(3).Kafka <span class="p">支持实时的流式处理</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="10."><p class="s84" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">Kafka <span class="p">创建 </span>Topic <span class="p">时如何将分区放置到不同的 </span>Broker <span class="p">中</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">副本因子不能大于 </span>Broker <span class="p">的个数；</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">第一个分区（编号为 </span>0<span class="p">）的第一个副本放置位置是随机从 </span>brokerList <span class="p">选择的；</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="p">其他分区的第一个副本放置位置相对于第 </span>0 <span class="p">个分区依次往后移。也就是如果我们有 </span>5 <span class="p">个 </span>Broker<span class="p">，</span>5 <span class="p">个分区，假设第一个分区放在第四个 </span>Broker <span class="p">上，那么第二个分区将会放在第五个 </span>Broker <span class="p">上；第三个分区将会放在第一个 </span>Broker <span class="p">上；第四个分区将会放在第二个 </span>Broker <span class="p">上，依次类推；</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="p">剩余的副本相对于第一个副本放置位置其实是由 </span>nextReplicaShift <span class="p">决定的，而这个数也是随机产生的</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="11."><p class="s84" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">Kafka <span class="p">新建的分区会在哪个目录下创建</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">在启动 <span class="s84">Kafka </span>集群之前，我们需要配置好 <span class="s84">log.dirs </span>参数，其值是 <span class="s84">Kafka </span>数据的存放目录，这个参数可以配置多个目录，目录之间使用逗号分隔，通常这些目录是分布在不同的磁盘上用于提高读写性能。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">当然我们也可以配置 <span class="s84">log.dir </span>参数，含义一样。只需要设置其中一个即可。</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">如果 <span class="s84">log.dirs </span>参数只配置了一个目录，那么分配到各个 <span class="s84">Broker </span>上的分区肯定只能在这个目录下创建文件夹用于存放数据。</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">但是如果 <span class="s84">log.dirs </span>参数配置了多个目录，那么 <span class="s84">Kafka </span>会在哪个文件夹中创建分区目录呢？答案是：<span class="s84">Kafka </span>会在含有分区目录最少的文件夹中创建新的分区目录，分区目录名为 <span class="s84">Topic</span>名<span class="s84">+</span>分区 <span class="s84">ID</span>。注意，是分区文件夹总数最少的目录，而不是磁盘使用量最少的目录！也就 是说，如果你给 <span class="s84">log.dirs </span>参数新增了一个新的磁盘，新的分区目录肯定是先在这个新的磁盘上创建直到这个新的磁盘目录拥有的分区目录不是最少为止。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="12."><p class="s84" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">partition <span class="p">的数据如何保存到硬盘</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">topic <span class="p">中的多个 </span>partition <span class="p">以文件夹的形式保存到 </span>broker<span class="p">，每个分区序号从 </span>0 <span class="p">递增，且消息有序</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Partition <span class="p">文件下有多个 </span>segment<span class="p">（</span>xxx.index<span class="p">，</span>xxx.log<span class="p">）</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">segment <span class="p">文件里的 大小和配置文件大小一致可以根据要求修改 默认为 </span>1g</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">如果大小大于 <span class="s84">1g </span>时，会滚动一个新的 <span class="s84">segment </span>并且以上一个 <span class="s84">segment </span>最后一条消息的偏移量命名</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="13."><p class="s84" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">kafka <span class="p">的 </span>ack <span class="p">机制</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">request.required.acks <span class="p">有三个值 </span>0 1 -1</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">0:<span class="p">生产者不会等待 </span>broker <span class="p">的 </span>ack<span class="p">，这个延迟最低但是存储的保证最弱当 </span>server <span class="p">挂掉的时候就会丢数据</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">1<span class="p">：服务端会等待 </span>ack <span class="p">值 </span>leader <span class="p">副本确认接收到消息后发送 </span>ack <span class="p">但是如果 </span>leader <span class="p">挂掉后他不确保是否复制完成新 </span>leader <span class="p">也会导致数据丢失</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">-1<span class="p">：同样在 </span>1 <span class="p">的基础上 服务端会等所有的 </span>follower <span class="p">的副本受到数据后才会受到 </span>leader <span class="p">发出的 </span>ack<span class="p">，这样数据不会丢失</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="14."><p class="s84" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">Kafka <span class="p">的消费者如何消费数据</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">消费者每次消费数据的时候，消费者都会记录消费的物理偏移量（<span class="s84">offset</span>）的位置等到下次消费时，他会接着上次位置继续消费</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="15."><p style="padding-left: 36pt;text-indent: -13pt;text-align: left;">消费者负载均衡策略</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">一个消费者组中的一个分片对应一个消费者成员，他能保证每个消费者成员都能访问，如果组中成员太多会有空闲的成员</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="16."><p style="padding-left: 36pt;text-indent: -13pt;text-align: left;">数据有序</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">一个消费者组里它的内部是有序的消费者组与消费者组之间是无序的</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="17."><p class="s84" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">kafaka <span class="p">生产数据时数据的分组策略</span></p></li></ol><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">生产者决定数据产生到集群的哪个 <span class="s84">partition </span>中每一条消息都是以（<span class="s84">key</span>，<span class="s84">value</span>）格式</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Key <span class="p">是由生产者发送数据传入</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">所以生产者（<span class="s84">key</span>）决定了数据产生到集群的哪个 <span class="s84">partition</span></p><ul id="l50"><li data-list-text=""><p class="s85" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">1) Linux <span class="s86">中主要有哪几种内核锁</span>?</p><p class="s87" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: justify;">Linux <span class="s88">的同步机制从 </span>2.0 <span class="s88">到 </span>2.6 <span class="s88">以来不断发展完善。从最初的原子操作</span>,<span class="s88">到后来的信号量</span>,<span class="s88">从大内核锁到今天的自旋锁。这些同步机制的发展伴随 </span>Linux <span class="s88">从单处理器到对称多处理器的过渡</span>;</p><p class="s88" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">伴随着从非抢占内核到抢占内核的过度。<span class="s87">Linux </span>的锁机制越来越有效<span class="s87">,</span>也越来越复杂。</p><p class="s87" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Linux <span class="s88">的内核锁主要是自旋锁和信号量。</span></p><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">自旋锁最多只能被一个可执行线程持有<span class="s87">,</span>如果一个执行线程试图请求一个已被争用<span class="s87">(</span>已经被持有<span class="s87">)</span>的自旋锁<span class="s87">,</span>那么这个线程就会一直进行忙循环<span class="s87">——</span>旋转<span class="s87">——</span>等待锁重新可用。要是锁未被争用<span class="s87">,</span>请求它的执行线程便能立刻得到它并且继续进行。自旋锁可以在任何时刻防止多于一个的执行线程同时进入临界区。</p><p class="s87" style="padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">Linux <span class="s88">中的信号量是一种睡眠锁。如果有一个任务试图获得一个已被持有的信号量时</span>,<span class="s88">信号量会将其推入等待队列</span>,<span class="s88">然后让其睡眠。这时处理器获得自由去执行其它代码。当持有信号量的进程将信号量释放后</span>,<span class="s88">在等待队列中的一个任务将被唤醒</span>,<span class="s88">从而便可以获得这个信号</span></p><p class="s88" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">量。</p><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">信号量的睡眠特性<span class="s87">,</span>使得信号量适用于锁会被长时间持有的情况<span class="s87">;</span>只能在进程上下文中使用<span class="s87">,</span>因为中断上下文中是不能被调度的<span class="s87">;</span>另外当代码持有信号量时<span class="s87">,</span>不可以再持有自旋锁。 <span class="s87">Linux </span>内核中的同步机制<span class="s87">:</span>原子操作、信号量、读写信号量和自旋锁的 <span class="s87">API,</span>另外一些同步机制<span class="s87">,</span>包括大内核锁、读写锁、大读者锁、<span class="s87">RCU (Read-Copy Update,</span>顾名思义就是读<span class="s87">-</span>拷贝修改<span class="s87">),</span>和顺序锁。</p><ol id="l51"><li data-list-text="2)"><p class="s85" style="padding-left: 35pt;text-indent: -12pt;line-height: 16pt;text-align: left;">Linux <span class="s86">中的用户模式和内核模式是什么含意</span>?</p><p class="s87" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">MS-DOS <span class="s88">等操作系统在单一的 </span>CPU <span class="s88">模式下运行</span>,<span class="s88">但是一些类 </span>Unix <span class="s88">的操作系统则使用了双模式</span>,<span class="s88">可以有效地实现时间共享。在 </span>Linux <span class="s88">机器上</span>,CPU <span class="s88">要么处于受信任的内核模式</span>,<span class="s88">要么处于受限制的用户模式。除了内核本身处于内核模式以外</span>,<span class="s88">所有的用户进程都运行在用户模式之中。</span></p><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">内核模式的代码可以无限制地访问所有处理器指令集以及全部内存和 <span class="s87">I/O </span>空间。如果用户模式的进程要享有此特权<span class="s87">,</span>它必须通过系统调用向设备驱动程序或其他内核模式的代码发出请求。另外<span class="s87">,</span>用户模式的代码允许发生缺页<span class="s87">,</span>而内核模式的代码则不允许。</p><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">在 <span class="s87">2.4 </span>和更早的内核中<span class="s87">,</span>仅仅用户模式的进程可以被上下文切换出局<span class="s87">,</span>由其他进程抢占。除非发生以下两种情况<span class="s87">,</span>否则内核模式代码可以一直独占 <span class="s87">CPU:</span></p><ol id="l52"><li data-list-text="(1)"><p class="s88" style="padding-left: 41pt;text-indent: -18pt;text-align: left;">它自愿放弃 <span class="s87">CPU;</span></p></li><li data-list-text="(2)"><p class="s88" style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">发生中断或异常。</p></li></ol><p class="s87" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2.6 <span class="s88">内核引入了内核抢占</span>,<span class="s88">大多数内核模式的代码也可以被抢占。</span></p></li><li data-list-text="3)"><p class="s86" style="padding-top: 4pt;padding-left: 37pt;text-indent: -14pt;text-align: left;">怎样申请大块内核内存<span class="s85">?</span></p><p class="s88" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 158%;text-align: left;">在 <span class="s87">Linux </span>内核环境下<span class="s87">,</span>申请大块内存的成功率随着系统运行时间的增加而减少<span class="s87">,</span>虽然可以通过 <span class="s87">vmalloc </span>系列调用申请物理不连续但虚拟地址连续的内存<span class="s87">,</span>但毕竟其使用效率不高且在 <span class="s87">32 </span>位系统上 <span class="s87">vmalloc </span>的内存地址空间有限。所以<span class="s87">,</span>一般的建议是在系统启动阶段申请大块内存<span class="s87">,</span>但是其成功的概率也只是比较高而已<span class="s87">,</span>而不是 <span class="s87">100%</span>。如果程序真的比较在意这个申请的成功与否<span class="s87">,</span>只能退用<span class="s87">“</span>启动内存<span class="s87">”(Boot Memory)</span>。下面就是申请并导出启动内存的一段示例代码<span class="s87">: void* x_bootmem = NULL;</span></p><p class="s87" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 174%;text-align: left;">EXPORT_SYMBOL(x_bootmem); unsigned long x_bootmem_size = 0; EXPORT_SYMBOL(x_bootmem_size); static int <u>&nbsp; </u>init x_bootmem_setup(char *str)</p><p class="s87" style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">{</p><p class="s87" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 174%;text-align: left;">x_bootmem_size = memparse(str, &amp;str); x_bootmem = alloc_bootmem(x_bootmem_size);</p><p class="s87" style="padding-left: 23pt;text-indent: 0pt;line-height: 174%;text-align: left;">printk(“Reserved %lu bytes from %p for x\n”, x_bootmem_size, x_bootmem); return 1;</p><p class="s87" style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">}</p><p class="s89" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"> <span class="s87">setup(“x-bootmem=”, x_bootmem_setup);</span></p><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">可见其应用还是比较简单的<span class="s87">,</span>不过利弊总是共生的<span class="s87">,</span>它不可避免也有其自身的限制<span class="s87">:</span>内存申请代码只能连接进内核<span class="s87">,</span>不能在模块中使用。</p><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">被申请的内存不会被页分配器和 <span class="s87">slab </span>分配器所使用和统计<span class="s87">,</span>也就是说它处于系统的可见内存之外<span class="s87">,</span>即使在将来的某个地方你释放了它。</p><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">一般用户只会申请一大块内存<span class="s87">,</span>如果需要在其上实现复杂的内存管理则需要自己实现。在不允许内存分配失败的场合<span class="s87">,</span>通过启动内存预留内存空间将是我们唯一的选择。</p></li><li data-list-text="4)"><p class="s86" style="padding-left: 37pt;text-indent: -14pt;line-height: 16pt;text-align: left;">用户进程间通信主要哪几种方式<span class="s85">?</span></p><ol id="l53"><li data-list-text="(1)"><p class="s88" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">管道<span class="s87">(Pipe):</span>管道可用于具有亲缘关系进程间的通信<span class="s87">,</span>允许一个进程和另一个与它有共同祖先的进程之间进行通信。</p></li><li data-list-text="(2)"><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">命名管道<span class="s87">(named pipe):</span>命名管道克服了管道没有名字的限制<span class="s87">,</span>因此<span class="s87">,</span>除具有管道所具有的功能外<span class="s87">,</span>它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令 <span class="s87">mkfifo </span>或系统调用 <span class="s87">mkfifo </span>来创建。</p></li><li data-list-text="(3)"><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">信号<span class="s87">(Signal):</span>信号是比较复杂的通信方式<span class="s87">,</span>用于通知接受进程有某种事件发生<span class="s87">,</span>除了用于进程间通信外<span class="s87">,</span>进程还可以发送信号给进程本身<span class="s87">;linux </span>除了支持 <span class="s87">Unix </span>早期信号语义函数 <span class="s87">sigal</span>外<span class="s87">,</span>还支持语义符合 <span class="s87">Posix.1 </span>标准的信号函数 <span class="s87">sigaction(</span>实际上<span class="s87">,</span>该函数是基于 <span class="s87">BSD </span>的<span class="s87">,BSD</span>为了实现可靠信号机制<span class="s87">,</span>又能够统一对外接口<span class="s87">,</span>用 <span class="s87">sigaction </span>函数重新实现了 <span class="s87">signal </span>函数<span class="s87">)</span>。</p></li><li data-list-text="(4)"><p class="s88" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">消息<span class="s87">(Message)</span>队列<span class="s87">:</span>消息队列是消息的链接表<span class="s87">,</span>包括 <span class="s87">Posix </span>消息队列 <span class="s87">system V </span>消息队 列。有足够权限的进程可以向队列中添加消息<span class="s87">,</span>被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少<span class="s87">,</span>管道只能承载无格式字节流以及缓冲区大小受限等缺</p></li><li data-list-text="(5)"><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">共享内存<span class="s87">:</span>使得多个进程可以访问同一块内存空间<span class="s87">,</span>是最快的可用 <span class="s87">IPC </span>形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制<span class="s87">,</span>如信号量结合使用<span class="s87">,</span>来达到进程间的同步及互斥。</p></li><li data-list-text="(6)"><p class="s88" style="padding-left: 35pt;text-indent: -12pt;text-align: left;">信号量<span class="s87">(semaphore):</span>主要作为进程间以及同一进程不同线程之间的同步手段。</p></li><li data-list-text="(7)"><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">套接字<span class="s87">(Socket):</span>更为一般的进程间通信机制<span class="s87">,</span>可用于不同机器之间的进程间通信。起初是由 <span class="s87">Unix </span>系统的 <span class="s87">BSD </span>分支开发出来的<span class="s87">,</span>但现在一般可以移植到其它类 <span class="s87">Unix </span>系统上<span class="s87">:Linux </span>和 <span class="s87">System V </span>的变种都支持套接字。</p></li></ol></li><li data-list-text="5)"><p class="s86" style="padding-left: 37pt;text-indent: -14pt;line-height: 16pt;text-align: left;">通过伙伴系统申请内核内存的函数有哪些<span class="s85">?</span></p><p class="s88" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">在物理页面管理上实现了基于区的伙伴系统<span class="s87">(zone based buddy system)</span>。对不同区的内存使用单独的伙伴系统<span class="s87">(buddy system)</span>管理<span class="s87">,</span>而且独立地监控空闲页。相应接口 <span class="s87">alloc_pages(gfp_mask, order),_ _get_free_pages(gfp_mask, order)</span>等。</p></li><li data-list-text="6)"><p class="s87" style="padding-left: 23pt;text-indent: 0pt;line-height: 166%;text-align: left;">Linux <span class="s88">虚拟文件系统的关键数据结构有哪些</span>?(<span class="s88">至少写出四个</span>) struct super_block,struct inode,struct file,struct dentry;</p></li><li data-list-text="7)"><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 166%;text-align: left;">对文件或设备的操作函数保存在那个数据结构中<span class="s87">? struct file_operations</span></p></li><li data-list-text="8)"><p class="s87" style="padding-left: 35pt;text-indent: -12pt;line-height: 13pt;text-align: left;">Linux <span class="s88">中的文件包括哪些</span>?</p><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">执行文件<span class="s87">,</span>普通文件<span class="s87">,</span>目录文件<span class="s87">,</span>链接文件和设备文件<span class="s87">,</span>管道文件。</p></li><li data-list-text="9)"><p class="s88" style="padding-top: 7pt;padding-left: 37pt;text-indent: -14pt;text-align: left;">创建进程的系统调用有那些<span class="s87">?</span></p><p class="s87" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">clone(),fork(),vfork();<span class="s88">系统调用服务例程</span>:sys_clone,sys_fork,sys_vfork;</p></li><li data-list-text="10)"><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">调用 <span class="s87">schedule()</span>进行进程切换的方式有几种<span class="s87">? 1.</span>系统调用 <span class="s87">do_fork();</span></p><ol id="l54"><li data-list-text="2."><p class="s88" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">定时中断 <span class="s87">do_timer();</span></p></li><li data-list-text="3."><p class="s88" style="padding-top: 7pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">唤醒进程 <span class="s87">wake_up_process</span></p></li><li data-list-text="4."><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">改变进程的调度策略 <span class="s87">setscheduler(); 5.</span>系统调用礼让 <span class="s87">sys_sched_yield();</span></p></li></ol></li><li data-list-text="11)"><p class="s87" style="padding-left: 41pt;text-indent: -18pt;text-align: left;">Linux <span class="s88">调度程序是根据进程的动态优先级还是静态优先级来调度进程的</span>?</p><p class="s87" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">Liunx <span class="s88">调度程序是根据根据进程的动态优先级来调度进程的</span>,<span class="s88">但是动态优先级又是根据静态优先级根据算法计算出来的</span>,<span class="s88">两者是两个相关联的值。因为高优先级的进程总是比低优先级</span></p><p class="s88" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">的进程先被调度<span class="s87">,</span>为防止多个高优先级的进程占用 <span class="s87">CPU </span>资源<span class="s87">,</span>导致其他进程不能占有 <span class="s87">CPU,</span></p><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">所以引用动态优先级概念</p></li><li data-list-text="12)"><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 166%;text-align: left;">进程调度的核心数据结构是哪个<span class="s87">? struct runqueue</span></p></li><li data-list-text="13)"><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">如何加载、卸载一个模块<span class="s87">? insmod </span>加载<span class="s87">,rmmod </span>卸载</p></li><li data-list-text="14)"><p class="s88" style="padding-left: 43pt;text-indent: -20pt;text-align: left;">模块和应用程序分别运行在什么空间<span class="s87">?</span></p><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">模块运行在内核空间<span class="s87">,</span>应用程序运行在用户空间</p></li><li data-list-text="15)"><p class="s87" style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">Linux <span class="s88">中的浮点运算由应用程序实现还是内核实现</span>?</p><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">应用程序实现<span class="s87">,Linux </span>中的浮点运算是利用数学库函数实现的<span class="s87">,</span>库函数能够被应用程序链接后调用<span class="s87">,</span>不能被内核链接调用。这些运算是在应用程序中运行的<span class="s87">,</span>然后再把结果反馈给系统。 <span class="s87">Linux </span>内核如果一定要进行浮点运算<span class="s87">,</span>需要在建立内核时选上 <span class="s87">math-emu,</span>使用软件模拟计算浮点运算<span class="s87">,</span>据说这样做的代价有两个<span class="s87">:</span>用户在安装驱动时需要重建内核<span class="s87">,</span>可能会影响到其他的应用程序<span class="s87">,</span>使得这些应用程序在做浮点运算的时候也使用 <span class="s87">math-emu,</span>大大的降低了效率。</p></li><li data-list-text="16)"><p class="s88" style="padding-left: 43pt;text-indent: -20pt;text-align: left;">模块程序能否使用可链接的库函数<span class="s87">?</span></p><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">模块程序运行在内核空间<span class="s87">,</span>不能链接库函数。</p></li><li data-list-text="17)"><p class="s87" style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">TLB <span class="s88">中缓存的是什么内容</span>?</p><p class="s87" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">TLB,<span class="s88">页表缓存</span>,<span class="s88">当线性地址被第一次转换成物理地址的时候</span>,<span class="s88">将线性地址和物理地址的对应放到 </span>TLB <span class="s88">中</span>,<span class="s88">用于下次访问这个线性地址时</span>,<span class="s88">加快转换速度。</span></p></li><li data-list-text="18)"><p class="s87" style="padding-left: 41pt;text-indent: -18pt;text-align: left;">Linux <span class="s88">中有哪几种设备</span>?</p><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">字符设备和块设备。网卡是例外<span class="s87">,</span>他不直接与设备文件对应<span class="s87">,mknod </span>系统调用用来创建设备文件。</p></li><li data-list-text="19)"><p class="s88" style="padding-left: 43pt;text-indent: -20pt;text-align: left;">字符设备驱动程序的关键数据结构是哪个<span class="s87">?</span></p><p class="s88" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">字符设备描述符 <span class="s87">struct cdev,cdev_alloc()</span>用于动态的分配 <span class="s87">cdev </span>描述符<span class="s87">,cdev_add()</span>用于注册一个 <span class="s87">cdev </span>描述符<span class="s87">,cdev </span>包含一个 <span class="s87">struct kobject </span>类型的数据结构它是核心的数据结构</p></li><li data-list-text="20)"><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 166%;text-align: left;">设备驱动程序包括哪些功能函数<span class="s87">? open(),read(),write(),llseek(),realse();</span></p></li><li data-list-text="21)"><p class="s88" style="padding-left: 43pt;text-indent: -20pt;line-height: 13pt;text-align: left;">如何唯一标识一个设备<span class="s87">?</span></p><p class="s87" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">Linux <span class="s88">使用一个设备编号来唯一的标示一个设备</span>,<span class="s88">设备编号分为</span>:<span class="s88">主设备号和次设备号</span>,<span class="s88">一般主设备号标示设备对应的驱动程序</span>,<span class="s88">次设备号对应设备文件指向的设备</span>,<span class="s88">在内核中使用 </span>dev_t <span class="s88">来表示设备编号</span>,<span class="s88">一般它是 </span>32 <span class="s88">位长度</span>,<span class="s88">其中 </span>12 <span class="s88">位用于表示主设备号</span>,20 <span class="s88">位用于表示次设备号</span>,<span class="s88">利用 </span>MKDEV(int major,int minor);<span class="s88">用于生成一个 </span>dev_t <span class="s88">类型的对象。</span></p></li><li data-list-text="22)"><p class="s87" style="padding-left: 41pt;text-indent: -18pt;text-align: left;">Linux <span class="s88">通过什么方式实现系统调用</span>?</p><p class="s88" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">靠软件中断实现的<span class="s87">,</span>首先<span class="s87">,</span>用户程序为系统调用设置参数<span class="s87">,</span>其中一个编号是系统调用编号<span class="s87">,</span>参数设置完成后<span class="s87">,</span>程序执行系统调用指令<span class="s87">,x86 </span>上的软中断是有 <span class="s87">int </span>产生的<span class="s87">,</span>这个指令会导致一个异常<span class="s87">,</span>产生一个事件<span class="s87">,</span>这个事件会导致处理器跳转到内核态并跳转到一个新的地址。并开始处理那里的异常处理程序<span class="s87">,</span>此时的异常处理就是系统调用程序。</p></li><li data-list-text="23)"><p class="s87" style="padding-left: 25pt;text-indent: -2pt;line-height: 156%;text-align: left;">Linux <span class="s88">软中断和工作队列的作用是什么</span>? Linux <span class="s88">中的软中断和工作队列是中断处理。</span></p></li></ol><ol id="l55"><li data-list-text="1."><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">软中断一般是<span class="s87">“</span>可延迟函数<span class="s87">”</span>的总称<span class="s87">,</span>它不能睡眠<span class="s87">,</span>不能阻塞<span class="s87">,</span>它处于中断上下文<span class="s87">,</span>不能进城切换<span class="s87">,</span>软中断不能被自己打断<span class="s87">,</span>只能被硬件中断打断<span class="s87">(</span>上半部<span class="s87">),</span>可以并发的运行在多个 <span class="s87">CPU </span>上。所以软中断必须设计成可重入的函数<span class="s87">,</span>因此也需要自旋锁来保护其数据结构。</p></li><li data-list-text="2."><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">工作队列中的函数处在进程上下文中<span class="s87">,</span>它可以睡眠<span class="s87">,</span>也能被阻塞<span class="s87">,</span>能够在不同的进程间切换。已完成不同的工作。</p></li></ol><p class="s88" style="padding-left: 23pt;text-indent: 0pt;line-height: 156%;text-align: left;">可延迟函数和工作队列都不能访问用户的进程空间<span class="s87">,</span>可延时函数在执行时不可能有任何正在运行的进程<span class="s87">,</span>工作队列的函数有内核进程执行<span class="s87">,</span>他不能访问用户空间地址。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 18pt;text-align: left;"><span class="s90" style=" background-color: #EFEFEF;">memcached</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">是怎么工作的？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="554" height="143" alt="image" src="整合_files/Image_318.png"/></span></p><p style="text-indent: 0pt;text-align: justify;">举个列子，假设有 <span class="s84">3 </span>个客户端 <span class="s84">1, 2, 3</span>，<span class="s84">3 </span>台 <span class="s84">memcached A, B, C</span>：</p><p class="s84" style="padding-top: 2pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Client 1 <span class="p">想把数据</span>”barbaz”<span class="p">以 </span>key “foo”<span class="p">存储。</span>Client 1 <span class="p">首先参考节点列表（</span>A, B, C<span class="p">），计算 </span>key “foo”<span class="p">的哈希值，假设 </span>memcached B <span class="p">被选中。接着，</span>Client 1 <span class="p">直接 </span>connect <span class="p">到 </span>memcached B<span class="p">，通过 </span>key “foo”<span class="p">把数据</span>”barbaz”<span class="p">存储进去。 </span>Client 2 <span class="p">使用与 </span>Client 1 <span class="p">相同的客户端库（意味着阶段一的哈希算法相同），也拥有同样的 </span>memcached <span class="p">列表（</span>A, B, C<span class="p">）。</span></p><p style="text-indent: 0pt;line-height: 13pt;text-align: justify;">于是，经过相同的哈希计算（阶段一），<span class="s84">Client 2 </span>计算出 <span class="s84">key “foo”</span>在 <span class="s84">memcached B </span>上，然后</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: justify;">它直接请求 <span class="s84">memcached B</span>，得到数据<span class="s84">”barbaz”</span>。</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;line-height: 115%;text-align: left;">客户端可以把数据存储在多台 <span class="s84">memcached </span>上。当查询数据时，客户端首先参考节点列表计算出 的哈希值（阶段一哈希），进而选中一个节点；客户端将请求发送给选中的节点，</p><p style="text-indent: 0pt;line-height: 13pt;text-align: left;">然后 <span class="s84">memcached </span>节点通过一个内部的哈希算法（阶段二哈希），查找真正的数据（<span class="s84">item</span>）。</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">key</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s93" style=" background-color: #EFEFEF;">Memcached</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">的神奇来自两阶段哈希（</span><span class="s93" style=" background-color: #EFEFEF;">two-stage hash</span><span class="s94" style=" background-color: #EFEFEF;">）。</span><span class="s93" style=" background-color: #EFEFEF;">Memcached</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">就像一个巨大的、存储                                                                    了很多</span><span class="s93" style=" background-color: #EFEFEF;">&lt;key,value&gt;</span><span class="s94" style=" background-color: #EFEFEF;">对的哈希表。通过</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">key</span><span class="s94" style=" background-color: #EFEFEF;">，可以存储或查询任意的数据。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;"><span><img width="3" height="17" alt="image" src="整合_files/Image_319.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:23pt" cellspacing="0"><tr style="height:14pt"><td style="width:415pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">各种客户端在 <span class="s96">memcached </span>中数据的存储形式是不同的（<span class="s96">perl Storable, php serialize, java</span></p></td></tr><tr style="height:14pt"><td style="width:415pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">hibernate, JSON <span class="s95">等）。一些客户端实现的哈希算法也不一样。但是，</span>memcached <span class="s95">服务器端的</span></p></td></tr><tr style="height:14pt"><td style="width:86pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">行为总是一致的。</p></td><td style="width:329pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="360" height="18" alt="image" src="整合_files/Image_320.png"/></span></p><p style="text-indent: 0pt;text-align: left;">可以很好地解决 <span class="s84">C10K problem </span>，并具有极佳的可扩展性。</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">最后，从实现的角度看，<span class="s84">memcached </span>是一个非阻塞的、基于事件的服务器程序。这种架构</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">可以参考</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">A Story of Caching </span><span class="s94" style=" background-color: #EFEFEF;">，这篇文章简单解释了客户端与</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">memcached</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">是如何交互的。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s90" style=" background-color: #EFEFEF;">memcached</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">最大的优势是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:23pt" cellspacing="0"><tr style="height:14pt"><td style="width:415pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">请仔细阅读上面的问题（即 <span class="s96">memcached </span>是如何工作的）。<span class="s96">Memcached </span>最大的好处就是它带</p></td></tr><tr style="height:14pt"><td style="width:415pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">来了极佳的水平可扩展性，特别是在一个巨大的系统中。由于客户端自己做了一次哈希，</p></td></tr><tr style="height:14pt"><td style="width:408pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">那么我们很容易增加大量 <span class="s96">memcached </span>到集群中。<span class="s96">memcached </span>之间没有相互通信，因此不</p></td><td style="width:7pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:415pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">会增加 <span class="s96">memcached </span>的负载；没有多播协议，不会网络通信量爆炸（<span class="s96">implode</span>）。<span class="s96">memcached</span></p></td></tr><tr style="height:14pt"><td style="width:415pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">的集群很好用。内存不够了？增加几台 <span class="s96">memcached </span>吧；<span class="s96">CPU </span>不够用了？再增加几台吧；</p></td></tr><tr style="height:14pt"><td style="width:212pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">有多余的内存？在增加几台吧，不要浪费了。</p></td><td style="width:203pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="265" height="18" alt="image" src="整合_files/Image_321.png"/></span></p><p class="s84" style="text-indent: 0pt;text-align: left;">FAQ<span class="p">，在其他地方很容易找到详细资料的。</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">基于 <span class="s84">memcached </span>的基本原则，可以相当轻松地构建出不同类型的缓存架构。除了这篇</p><p style="text-indent: 0pt;text-align: left;"/><table style="border-collapse:collapse" cellspacing="0"><tr style="height:14pt"><td style="width:330pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF;border-right-style:solid;border-right-width:3pt;border-right-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">看看下面的几个问题吧，它们在 <span class="s96">memcached</span>、服务器的 <span class="s96">local   cache</span></p></td></tr><tr style="height:14pt"><td style="width:271pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s96" style="padding-left: 1pt;text-indent: 0pt;line-height: 12pt;text-align: left;">cache <span class="s95">之间做了比较。这几个问题会让您有更全面的认识。</span></p></td><td style="width:59pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-right-style:solid;border-right-width:3pt;border-right-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 3pt;text-indent: 0pt;text-align: right;"><span class="s94" style=" background-color: #EFEFEF;">和</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">MySQL</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">的</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">query</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s90" style=" background-color: #EFEFEF;">memcached</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">和</span><span class="s97"> </span><span class="s90" style=" background-color: #EFEFEF;">MySQL</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">的</span><span class="s97"> </span><span class="s90" style=" background-color: #EFEFEF;">query cache</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">相比，有什么优缺点？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="text-indent: 0pt;text-align: left;">cache</p><p style="text-indent: 0pt;text-align: left;">的</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: black; font-family:&quot;Times New Roman&quot;, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -2pt;"> </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="text-indent: 0pt;text-align: left;">memcached item</p><p style="padding-left: 361pt;text-indent: 0pt;line-height: 14pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;">会经常让所有缓存数据</p><p style="padding-left: 265pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: black; font-style: normal; font-weight: normal; text-decoration: none; vertical-align: -2pt;">	</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;">的</p><p class="s84" style="text-indent: 0pt;text-align: left;">query cache</p><p style="text-indent: 0pt;text-align: left;">会遇到扩展问题（<span class="s84">scalability issues</span>）。在多核</p><p class="s84" style="text-indent: 0pt;text-align: left;">CPU</p><p style="padding-left: 143pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: black; font-family:&quot;Times New Roman&quot;, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -2pt;"> </span><span style=" color: black; font-family:&quot;Times New Roman&quot;, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -2pt;"> </span><span style=" color: black; font-family:&quot;Times New Roman&quot;, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -2pt;"> </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;">会增加一个全局锁（<span class="s84">global lock</span>）<span class="s84">, </span>由于需要刷新更多的缓存数据，速度会</p><p style="padding-left: 99pt;text-indent: 0pt;line-height: 14pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;">内存，都可以用来增加</p><p class="s84" style="text-indent: 0pt;text-align: left;">memcached</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 14pt;text-align: left;"><span style=" color: black; font-family:&quot;Times New Roman&quot;, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -2pt;"> </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="451" height="81" alt="image" src="整合_files/Image_322.png"/></span></p><p class="s84" style="text-indent: 0pt;line-height: 11pt;text-align: right;">query</p><p style="padding-top: 2pt;text-indent: 0pt;line-height: 12pt;text-align: left;">查询可以被反复地快速执行。</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;line-height: 11pt;text-align: left;">服务器都会受益。</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">MySQL</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">query</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 76pt;text-indent: 0pt;text-align: left;">是集中式的，连接到该</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;line-height: 11pt;text-align: left;">cache</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;line-height: 11pt;text-align: left;">query</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">与之相比，怎么样呢？<span class="s84">MySQL </span>的</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">Memcached</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: right;">SQL</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">SQL <span class="p">查询的结果，被缓存的</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">cache<span class="p">，可以自动地缓存</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">有个使用方便的</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">引入应用中，还是需要不少工作量的。<span class="s84">MySQL</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">memcached</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">把</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="87" height="18" alt="image" src="整合_files/Image_323.png"/></span></p><p style="text-indent: 0pt;text-align: left;">的 <span class="s84">query cache</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="59" height="18" alt="image" src="整合_files/Image_324.png"/></span></p><p style="text-indent: 0pt;text-align: left;">都失效。</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">只需要很少的时间，但是当写操作很频繁时，<span class="s84">MySQL</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">会立刻被刷新（<span class="s84">flush</span>）。存储一个</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">query cache</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">的</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">* <span class="p">当您修改表时，</span>MySQL</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="73" height="18" alt="image" src="整合_files/Image_325.png"/></span></p><p style="text-indent: 0pt;text-align: left;">变得更慢。</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">上，<span class="s84">query cache</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">上，<span class="s84">MySQL</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">CPU</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">* <span class="p">在多核</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="518" height="60" alt="image" src="整合_files/Image_326.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 169pt;text-indent: 0pt;text-align: center;">的弊将大于利。</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">但随着网站规模的增加，<span class="s84">query cache</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">会有所帮助，</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 18pt;text-indent: 0pt;text-align: left;">语句级别的，不可能做到这一点。在小的网站中，<span class="s84">query cache</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">是 <span class="s84">SQL</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">cache</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">query</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">memcached <span class="p">中。而</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;line-height: 12pt;text-align: left;">object<span class="p">），然后将用户对象缓存到</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;line-height: 12pt;text-align: left;">构建出一个用户对象（<span class="s84">user</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">memcached<span class="p">，我们可以搭建出各种高效的缓存。比如，可以执行多个独立的查询，</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">而利用</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">查询结果）。</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">SQL</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">中，我们是不能存储任意的数据的（只能是</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">query cache</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">的</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">* <span class="p">在 </span>MySQL</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="283" height="18" alt="image" src="整合_files/Image_327.png"/></span></p><p style="text-indent: 0pt;text-align: left;">集群的规模，然后您就可以缓存更多的数据。</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">memcached<span class="p">，只要您有空闲的</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">器增加更多的内存来缓存数据，固然是很好的。但是，有了</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">服务器空闲内存空间的限制。给数据库服务</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">MySQL</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">能够利用的内存容量受到</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">* query cache</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="533" height="39" alt="image" src="整合_files/Image_328.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 54pt;text-indent: 0pt;text-align: left;">都要好，那就是它不但可以存储任意的数据，而且没有网络存取的延迟。</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">query cache</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">有一点比 <span class="s84">memcached</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;line-height: 11pt;text-align: left;">cache</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;line-height: 12pt;text-align: left;">受到（单台）服务器空闲内存空间的限制。不过，<span class="s84">local</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">能够利用的内存容量</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">有许多与上面<span class="s84">(query cache)</span>相同的问题。<span class="s84">local cache</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">首先，<span class="s84">local cache</span></p><p style="text-indent: 0pt;text-align: left;"/><table style="border-collapse:collapse" cellspacing="0"><tr style="height:14pt"><td style="width:58pt" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">* local cache</p></td><td style="width:118pt" bgcolor="#EFEFEF"><p class="s95" style="padding-left: 1pt;text-indent: 0pt;line-height: 12pt;text-align: left;">的数据查询更快。考虑把</p></td><td style="width:69pt" bgcolor="#EFEFEF"><p class="s96" style="padding-left: 1pt;text-indent: 0pt;line-height: 12pt;text-align: left;">highly common</p></td><td style="width:56pt" bgcolor="#EFEFEF"><p class="s95" style="padding-left: 1pt;text-indent: 0pt;line-height: 12pt;text-align: left;">的数据放在</p></td><td style="width:50pt" bgcolor="#EFEFEF"><p class="s96" style="padding-left: 1pt;text-indent: 0pt;line-height: 12pt;text-align: left;">local cache</p></td></tr><tr style="height:14pt"><td style="width:264pt" colspan="4" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">个页面都需要加载一些数量较少的数据，考虑把它们放在</p></td><td style="width:55pt" bgcolor="#EFEFEF"><p class="s96" style="padding-left: 1pt;text-indent: 0pt;line-height: 12pt;text-align: left;">local cached</p></td><td style="width:32pt" bgcolor="#EFEFEF"><p class="s95" style="padding-left: 1pt;text-indent: 0pt;line-height: 12pt;text-align: left;">吧。</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 81%;text-align: left;"><span class="s90" style=" background-color: #EFEFEF;">memcached</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">和服务器的</span><span class="s97"> </span><span class="s90" style=" background-color: #EFEFEF;">local cache</span><span class="s92" style=" background-color: #EFEFEF;">（比如</span><span class="s97"> </span><span class="s90" style=" background-color: #EFEFEF;">PHP</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">的</span><span class="s97"> </span><span class="s90" style=" background-color: #EFEFEF;">APC</span><span class="s92" style=" background-color: #EFEFEF;">、</span><span class="s90" style=" background-color: #EFEFEF;">mmap</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">文件等）相比，有什么优缺                                                                                                      点？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;">和</p><p style="padding-left: 425pt;text-indent: 0pt;line-height: 14pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="425" height="18" alt="image" src="整合_files/Image_329.png"/></span></p><p style="text-indent: 0pt;text-align: left;">刷新 <span class="s84">cache</span>（很慢，不具扩展性），或者仅仅依赖缓存超时失效机制。</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">新一个 <span class="s84">key </span>会让所有的观察者觉察到。但是在 <span class="s84">local cache </span>中<span class="s84">, </span>我们只能通知所有的服务器</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">* local cache <span class="p">缺少集体失效（</span>group invalidation<span class="p">）的特性。在 </span>memcached <span class="p">集群中，删除或更</span></p><p style="text-indent: 0pt;text-align: left;"/><ul id="l56"><li data-list-text="*"><p style="padding-left: 30pt;text-indent: -7pt;text-align: left;"><span class="s93" style=" background-color: #EFEFEF;"> local cache</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">面临着严重的内存限制，这一点上面已经提到。</span></p><p style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">中吧。如果每</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="438" height="39" alt="image" src="整合_files/Image_330.png"/></span></p><p class="s84" style="padding-left: 96pt;text-indent: 0pt;text-align: left;">LRU<span class="p">（最近最少用）算法</span>+<span class="p">超时失效。当您存数据到</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">会优先被替换，接着就轮到最老的</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">slabs</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">的内存不够用了，过期的</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">memcached</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">future<span class="p">。如果</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">Which is forever, or some time in the</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">中，可以指定该数据在缓存中可以呆多久</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">memcached</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">机制是</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">cache</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">主要的</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">Memcached</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s90" style=" background-color: #EFEFEF;">memcached</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">的</span><span class="s97"> </span><span class="s90" style=" background-color: #EFEFEF;">cache</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">机制是怎样的？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="130" height="18" alt="image" src="整合_files/Image_331.png"/></span></p><p class="s97" style="text-indent: 0pt;line-height: 14pt;text-align: left;">如何实现冗余机制？</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">不实现！我们对这个问题感到很惊讶。<span class="s84">Memcached</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s91" style="text-indent: 0pt;text-align: left;">memcached</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="546" height="39" alt="image" src="整合_files/Image_332.png"/></span></p><p style="padding-left: 204pt;text-indent: 0pt;text-align: left;">节点失去了所有数据，您应该可以从数据源</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;">（比如数据库）再次获取到数据。您应该特别注意，您的应用应该可以容忍节点的失效。</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 1pt;text-indent: 0pt;text-align: left;">来保证一切！如果您担心节点失效会</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">不要写一些糟糕的查询代码，寄希望于 <span class="s84">memcached</span></p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">memcached</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">不带有任何冗余机制。如果一个</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">应该是应用的缓存层。它的设计本身就</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">未被使用的</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">slabs</span><span class="s94" style=" background-color: #EFEFEF;">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="546" height="39" alt="image" src="整合_files/Image_333.png"/></span></p><p style="text-indent: 0pt;text-align: left;">大大加重数据库的负担，那么您可以采取一些办法。比如您可以增加更多的节点（来减少</p><p class="s84" style="padding-top: 2pt;padding-left: 310pt;text-indent: 0pt;text-align: left;">IP<span class="p">），等等。</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">了的时候接管</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">down</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">丢失一个节点的影响），热备节点（在其他节点</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="521" height="60" alt="image" src="整合_files/Image_334.png"/></span></p><p class="s97" style="text-indent: 0pt;line-height: 11pt;text-align: left;">如何处理容错的？</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;line-height: 11pt;text-align: left;">节点失效，应对的措施完全取决于用户。节点失效时，下面列出几种方案供您选择：</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">节点失效的情况下，集群没有必要做任何容错处理。如果发生了</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">memcached</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">不处理！<span class="s84">:) </span>在</p><p style="text-indent: 0pt;text-align: left;"/><p class="s91" style="text-indent: 0pt;text-align: left;">memcached</p><p style="text-indent: 0pt;text-align: left;"/></li><li data-list-text="*"><p style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s93" style=" background-color: #EFEFEF;"> </span><span class="s94" style=" background-color: #EFEFEF;">忽略它！ 在失效节点被恢复或替换之前，还有很多其他节点可以应对节点失效带来的影响。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:23pt" cellspacing="0"><tr style="height:14pt"><td style="width:415pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="4" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">* <span class="s95">把失效的节点从节点列表中移除。做这个操作千万要小心！在默认情况下（余数式哈希</span></p></td></tr><tr style="height:14pt"><td style="width:415pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="4" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">算法），客户端添加或移除节点，会导致所有的缓存数据不可用！因为哈希参照的节点列表</p></td></tr><tr style="height:14pt"><td style="width:75pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-right-style:solid;border-right-width:3pt;border-right-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">变化了，大部分</p></td><td style="width:17pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-left-style:solid;border-left-width:3pt;border-left-color:#FFFFFF;border-right-style:solid;border-right-width:3pt;border-right-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">key</p></td><td style="width:277pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-left-style:solid;border-left-width:3pt;border-left-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">会因为哈希值的改变而被映射到（与原来）不同的节点上。</p></td><td style="width:46pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="*"><p style="padding-left: 33pt;text-indent: -10pt;text-align: left;"><span class="s93" style=" background-color: #EFEFEF;"> </span><span class="s94" style=" background-color: #EFEFEF;">启动热备节点，接管失效节点所占用的</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">IP</span><span class="s94" style=" background-color: #EFEFEF;">。这样可以防止哈希紊乱（</span><span class="s93" style=" background-color: #EFEFEF;">hashing chaos</span><span class="s94" style=" background-color: #EFEFEF;">）。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="*"><p style="padding-top: 3pt;padding-left: 70pt;text-indent: -47pt;text-align: left;"><span class="s93" style=" background-color: #EFEFEF;"> </span><span class="s94" style=" background-color: #EFEFEF;">如果希望添加和移除节点，而不影响原先的哈希结果，可以使用一致性哈希算法</span></p></li></ul><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">（</span><span class="s93" style=" background-color: #EFEFEF;">consistent hashing</span><span class="s94" style=" background-color: #EFEFEF;">）。您可以百度一下一致性哈希算法。支持一致性哈希的客户端已经很成熟，而且被广泛使用。去尝试一下吧！</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="547" height="60" alt="image" src="整合_files/Image_335.png"/></span></p><p style="text-indent: 0pt;text-align: left;">希（哈希算法与前一次不同），重新选择另一个节点（需要注意的时，客户端并没有把</p><p style="text-indent: 26pt;line-height: 16pt;text-align: left;">的节点从节点列表中移除，下次还是有可能先哈希到它）。如果某个节点时好时坏，两次哈希的方法就有风险了，好的节点和坏的节点上都可能存在脏数据（<span class="s84">stale data</span>）。</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">down</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">了，就再做一次哈</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">down</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">* <span class="p">两次哈希（</span>reshing<span class="p">）。当客户端存取数据时，如果发现一个节点</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s92" style=" background-color: #EFEFEF;">如何将</span><span class="s97"> </span><span class="s90" style=" background-color: #EFEFEF;">memcached</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">中</span><span class="s97"> </span><span class="s90" style=" background-color: #EFEFEF;">item</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">批量导入导出？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">您不应该这样做！</span><span class="s93" style=" background-color: #EFEFEF;">Memcached</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">是一个非阻塞的服务器。任何可能导致</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">memcached</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">暂停或                                                                     瞬时拒绝服务的操作都应该值得深思熟虑。向  </span><span class="s93" style=" background-color: #EFEFEF;">memcached</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">中批量导入数据往往不是您真正想要的！想象看，如果缓存数据在导出导入之间发生了变化，您就需要处理脏数据了；如果缓存数据在导出导入之间过期了，您又怎么处理这些数据呢？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">因此，批量导出导入数据并不像您想象中的那么有用。不过在一个场景倒是很有用。如果                                                                    您有大量的从不变化的数据，并且希望缓存很快热（</span><span class="s93" style=" background-color: #EFEFEF;">warm</span><span class="s94" style=" background-color: #EFEFEF;">）起来，批量导入缓存数据是很有帮助的。虽然这个场景并不典型，但却经常发生，因此我们会考虑在将来实现批量导出导入的功能。</span></p><p class="s84" style="text-indent: 0pt;text-align: left;">Steven          Grimm<span class="p">，一如既往地</span>,<span class="p">，在邮件列表中给出了另一个很好的例子：</span></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"/><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s93" style=" background-color: #EFEFEF;">http://lists.danga.com/pipermail/memcached/2007-July/004802.html </span><span class="s94" style=" background-color: #EFEFEF;">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s92" style=" background-color: #EFEFEF;">我需要把</span><span class="s97"> </span><span class="s90" style=" background-color: #EFEFEF;">memcached</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">中的</span><span class="s97"> </span><span class="s90" style=" background-color: #EFEFEF;">item</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">批量导出导入，怎么办？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="361" height="39" alt="image" src="整合_files/Image_336.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;">查询。记住，<span class="s84">Memcached </span>并不是您逃避优化查询的借口。</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">的其他提到过），或者优化不好的</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">FAQ</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">了，反复的查询让您的数据库不堪重负<span class="s84">…</span>这个问题在</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">节点都失效</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">太脆弱了。您需要做一些优化工作。比如处理<span class="s84">”</span>惊群<span class="s84">”</span>问题（比如 <span class="s84">memcached</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">了让您很痛苦，那么您还会陷入其他很多麻烦。您的系统</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">down</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">节点</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">memcached</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">如果一个</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">好吧好吧。如果您需要批量导出导入，最可能的原因一般是重新生成缓存数据需要消耗很                                                                   长的时间，或者数据库坏了让您饱受痛苦。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="554" height="185" alt="image" src="整合_files/Image_337.png"/></span></p><ul id="l57"><li data-list-text="*"><p style="text-indent: 0pt;line-height: 115%;text-align: justify;">使用 <span class="s84">MogileFS</span>（或者 <span class="s84">CouchDB </span>等类似的软件）在存储 <span class="s84">item</span>。把 <span class="s84">item </span>计算出来并 <span class="s84">dump </span>到磁盘上。<span class="s84">MogileFS </span>可以很方便地覆写 <span class="s84">item</span>，并提供快速地访问。您甚至可以把 <span class="s84">MogileFS</span>中的 <span class="s84">item </span>缓存在 <span class="s84">memcached </span>中，这样可以加快读取速度。 <span class="s84">MogileFS+Memcached </span>的组合可以加快缓存不命中时的响应速度，提高网站的可用性。</p></li><li data-list-text="*"><p style="text-indent: 0pt;line-height: 115%;text-align: justify;">重新使用 <span class="s84">MySQL</span>。<span class="s84">MySQL </span>的 <span class="s84">InnoDB </span>主键查询的速度非常快。如果大部分缓存数据都可以放到 <span class="s84">VARCHAR </span>字段中，那么主键查询的性能将更好。从 <span class="s84">memcached </span>中按 <span class="s84">key </span>查询几乎等价于 <span class="s84">MySQL </span>的主键查询：将 <span class="s84">key </span>哈希到 <span class="s84">64-bit </span>的整数，然后将数据存储到 <span class="s84">MySQL</span></p></li></ul><p style="text-indent: 0pt;line-height: 13pt;text-align: justify;">您可以把原始（不做哈希）的 <span class="s84">key </span>存储都普通的字段中，然后建立二级索引来加快查</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: justify;">询<span class="s84">…key </span>被动地失效，批量删除失效的 <span class="s84">key</span>，等等。</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;">中。</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">如果您的麻烦仅仅是重新生成缓存数据需要消耗很长时间（</span><span class="s93" style=" background-color: #EFEFEF;">15</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">秒到超过</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">5</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">分钟），您可以                                                                   考虑重新使用数据库。这里给出一些提示：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:23pt" cellspacing="0"><tr style="height:14pt"><td style="width:406pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">上面的方法都可以引入 <span class="s96">memcached</span>，在重启 <span class="s96">memcached </span>的时候仍然提供很好的性能。由</p></td><td style="width:9pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:415pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">于您不需要当心<span class="s96">”hot”</span>的 <span class="s96">item </span>被 <span class="s96">memcached LRU </span>算法突然淘汰，用户再也不用花几分钟来</p></td></tr><tr style="height:14pt"><td style="width:415pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">等待重新生成缓存数据（当缓存数据突然从内存中消失时），因此上面的方法可以全面提高</p></td></tr><tr style="height:14pt"><td style="width:34pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">性能。</p></td><td style="width:381pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://dormando.livejournal.com/495593.html" style=" color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt;" target="_blank">关于这些方法的细节，详见博客：</a><span class="s93" style=" background-color: #EFEFEF;">http://dormando.livejournal.com/495593.html </span><span class="s94" style=" background-color: #EFEFEF;">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:23pt" cellspacing="0"><tr style="height:14pt"><td style="width:164pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s99" style="text-indent: 0pt;line-height: 13pt;text-align: left;">memcached <span class="s100">是如何做身份验证的？</span></p></td><td style="width:245pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:409pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">没有身份认证机制！<span class="s96">memcached </span>是运行在应用下层的软件（身份验证应该是应用上层的职</p></td></tr><tr style="height:14pt"><td style="width:409pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">责）。<span class="s96">memcached </span>的客户端和服务器端之所以是轻量级的，部分原因就是完全没有实现身</p></td></tr><tr style="height:14pt"><td style="width:393pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">份验证机制。这样，<span class="s96">memcached </span>可以很快地创建新连接，服务器端也无需任何配置。</p></td><td style="width:16pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">如果您希望限制访问，您可以使用防火墙，或者让</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">memcached</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">监听</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">unix domain socket</span><span class="s94" style=" background-color: #EFEFEF;">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:23pt" cellspacing="0"><tr style="height:14pt"><td style="width:217pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s99" style="text-indent: 0pt;line-height: 13pt;text-align: left;">memcached <span class="s100">的多线程是什么？如何使用它们？</span></p></td><td style="width:196pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:413pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">线程就是定律（<span class="s96">threads rule</span>）！在 <span class="s96">Steven Grimm </span>和 <span class="s96">Facebook </span>的努力下，<span class="s96">memcached 1.2 </span>及</p></td></tr><tr style="height:14pt"><td style="width:404pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">更高版本拥有了多线程模式。多线程模式允许 <span class="s96">memcached </span>能够充分利用多个 <span class="s96">CPU</span>，并在</p></td><td style="width:9pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:413pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">CPU <span class="s95">之间共享所有的缓存数据。</span>memcached <span class="s95">使用一种简单的锁机制来保证数据更新操作的</span></p></td></tr></table><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">互斥。相比在同一个物理机器上运行多个</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">memcached</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">实例，这种方式能够更有效地处理</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">multi gets</span><span class="s94" style=" background-color: #EFEFEF;">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">如果您的系统负载并不重，也许您不需要启用多线程工作模式。如果您在运行一个拥有大规模硬件的、庞大的网站，您将会看到多线程的好处。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:23pt" cellspacing="0"><tr style="height:14pt"><td style="width:410pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">简单地总结一下：命令解析（<span class="s96">memcached </span>在这里花了大部分时间）可以运行在多线程模式</p></td></tr><tr style="height:14pt"><td style="width:391pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">下。<span class="s96">memcached </span>内部对数据的操作是基于很多全局锁的（因此这部分工作不是多线程</p></td><td style="width:19pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:410pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">的）。未来对多线程模式的改进，将移除大量的全局锁，提高 <span class="s96">memcached </span>在负载极高的场</p></td></tr><tr style="height:14pt"><td style="width:65pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">景下的性能。</p></td><td style="width:345pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:23pt" cellspacing="0"><tr style="height:14pt"><td style="width:216pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s99" style="text-indent: 0pt;line-height: 13pt;text-align: left;">memcached <span class="s100">能接受的 </span>key <span class="s100">的最大长度是多少？</span></p></td><td style="width:194pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:410pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">key <span class="s95">的最大长度是 </span>250 <span class="s95">个字符。需要注意的是，</span>250 <span class="s95">是 </span>memcached <span class="s95">服务器端内部的限制，</span></p></td></tr><tr style="height:14pt"><td style="width:410pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">如果您使用的客户端支持<span class="s96">”key </span>的前缀<span class="s96">”</span>或类似特性，那么 <span class="s96">key</span>（前缀<span class="s96">+</span>原始 <span class="s96">key</span>）的最大长度</p></td></tr><tr style="height:14pt"><td style="width:397pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">是可以超过 <span class="s96">250 </span>个字符的。我们推荐使用使用较短的 <span class="s96">key</span>，因为可以节省内存和带宽。</p></td><td style="width:13pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:18pt"><td style="width:410pt" colspan="2"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:210pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s99" style="text-indent: 0pt;line-height: 13pt;text-align: left;">memcached <span class="s100">对 </span>item <span class="s100">的过期时间有什么限制？</span></p></td><td style="width:200pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:397pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">过期时间最大可以达到 <span class="s96">30 </span>天。<span class="s96">memcached </span>把传入的过期时间（时间段）解释成时间点</p></td><td style="width:13pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:410pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">后，一旦到了这个时间点，<span class="s96">memcached </span>就把 <span class="s96">item </span>置为失效状态。这是一个简单但 <span class="s96">obscure</span></p></td></tr><tr style="height:14pt"><td style="width:44pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">的机制。</p></td><td style="width:366pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse" cellspacing="0"><tr style="height:14pt"><td style="width:197pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s99" style="padding-left: 1pt;text-indent: 0pt;line-height: 13pt;text-align: left;">memcached <span class="s100">最大能存储多大的单个 </span>item<span class="s100">？</span></p></td><td style="width:120pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF;border-right-style:solid;border-right-width:3pt;border-right-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:317pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-right-style:solid;border-right-width:3pt;border-right-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">1MB<span class="s95">。如果你的数据大于 </span>1MB<span class="s95">，可以考虑在客户端压缩或拆分到多个</span></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 8pt;padding-left: 341pt;text-indent: 0pt;text-align: left;"><span class="s93" style=" background-color: #EFEFEF;">key</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">中。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s92" style=" background-color: #EFEFEF;">为什么单个</span><span class="s97"> </span><span class="s90" style=" background-color: #EFEFEF;">item</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">的大小被限制在</span><span class="s97"> </span><span class="s90" style=" background-color: #EFEFEF;">1M byte</span><span class="s91"> </span><span class="s92" style=" background-color: #EFEFEF;">之内？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">简单的回答：因为内存分配器的算法就是这样的。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:23pt" cellspacing="0"><tr style="height:14pt"><td style="width:412pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">详细的回答：<span class="s96">Memcached </span>的内存存储引擎（引擎将来可插拔<span class="s96">…</span>），使用 <span class="s96">slabs </span>来管理内存。</p></td></tr><tr style="height:14pt"><td style="width:412pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">内存被分成大小不等的 <span class="s96">slabs  chunks</span>（先分成大小相等的 <span class="s96">slabs</span>，然后每个 <span class="s96">slab </span>被分成大小</p></td></tr><tr style="height:14pt"><td style="width:412pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">相等 <span class="s96">chunks</span>，不同 <span class="s96">slab </span>的 <span class="s96">chunk </span>大小是不相等的）。<span class="s96">chunk </span>的大小依次从一个最小数开始，</p></td></tr><tr style="height:14pt"><td style="width:202pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">按某个因子增长，直到达到最大的可能值。</p></td><td style="width:210pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="552" height="39" alt="image" src="整合_files/Image_338.png"/></span></p><p style="text-indent: 0pt;text-align: left;">越低。<span class="s84">Memcached </span>必须为每个 <span class="s84">slab </span>预先分配内存，因此如果设置了较小的因子和较大的最</p><p style="padding-top: 2pt;text-indent: 0pt;text-align: left;">大值，会需要更多的内存。</p><p style="text-indent: 0pt;text-align: left;"/><p class="s84" style="text-indent: 0pt;text-align: left;">slab <span class="p">中 </span>chunk <span class="p">越大，它和前面的 </span>slab <span class="p">之间的间隙就越大。因此，最大值越大，内存利用率</span></p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 23pt;text-indent: 0pt;line-height: 118%;text-align: left;"><span class="s94" style=" background-color: #EFEFEF;">如果最小值为</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">400B</span><span class="s94" style=" background-color: #EFEFEF;">，最大值是</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">1MB</span><span class="s94" style=" background-color: #EFEFEF;">，因子是</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">1.20</span><span class="s94" style=" background-color: #EFEFEF;">，各个</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">slab</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">的</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">chunk</span><span class="s84"> </span><span class="s94" style=" background-color: #EFEFEF;">的大小依次是：</span><span class="p"> </span><span class="s93" style=" background-color: #EFEFEF;">slab1 – 400B slab2 – 480B slab3 – 576B … </span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:23pt" cellspacing="0"><tr style="height:14pt"><td style="width:203pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF;border-right-style:solid;border-right-width:3pt;border-right-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">还有其他原因使得您不要这样向 <span class="s96">memcached</span></p></td><td style="width:208pt;border-left-style:solid;border-left-width:3pt;border-left-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="3" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">中存取很大的数据<span class="s96">…</span>不要尝试把巨大的网页放</p></td></tr><tr style="height:14pt"><td style="width:203pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF;border-right-style:solid;border-right-width:3pt;border-right-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">到 <span class="s96">mencached </span>中。把这样大的数据结构 <span class="s96">load</span></p></td><td style="width:13pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-left-style:solid;border-left-width:3pt;border-left-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF;border-right-style:solid;border-right-width:3pt;border-right-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">和</p></td><td style="width:34pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-left-style:solid;border-left-width:3pt;border-left-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF;border-right-style:solid;border-right-width:3pt;border-right-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">unpack</p></td><td style="width:161pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-left-style:solid;border-left-width:3pt;border-left-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">到内存中需要花费很长的时间，从</p></td></tr><tr style="height:14pt"><td style="width:149pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">而导致您的网站性能反而不好。</p></td><td style="width:54pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-right-style:solid;border-right-width:3pt;border-right-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:208pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-left-style:solid;border-left-width:3pt;border-left-color:#FFFFFF" colspan="2"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><table style="border-collapse:collapse;margin-left:23pt" cellspacing="0"><tr style="height:14pt"><td style="width:117pt" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">如果您确实需要存储大于</p></td><td style="width:22pt" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">1MB</p></td><td style="width:98pt" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">的数据，你可以修改</p></td><td style="width:99pt" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">slabs.c:POWER_BLOCK</p></td><td style="width:75pt" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">的值，然后重新</p></td></tr><tr style="height:14pt"><td style="width:22pt" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">编译</p></td><td style="width:139pt" colspan="2" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">memcached<span class="s95">；或者使用低效的</span></p></td><td style="width:217pt" colspan="2" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">malloc/free<span class="s95">。其他的建议包括数据库、</span>MogileFS</p></td><td style="width:33pt" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">等。</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:23pt" cellspacing="0"><tr style="height:14pt"><td style="width:414pt;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">我可以在不同的 <span class="s96">memcached </span>节点上使用大小不等的缓存空间吗？这么做之后，<span class="s96">memcached</span></p></td></tr><tr style="height:14pt"><td style="width:130pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">能够更有效地使用内存吗？</p></td><td style="width:284pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:406pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s96" style="text-indent: 0pt;line-height: 12pt;text-align: left;">Memcache <span class="s95">客户端仅根据哈希算法来决定将某个 </span>key <span class="s95">存储在哪个节点上，而不考虑节点的</span></p></td><td style="width:8pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:14pt"><td style="width:414pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">内存大小。因此，您可以在不同的节点上使用大小不等的缓存。但是一般都是这样做的：</p></td></tr><tr style="height:14pt"><td style="width:414pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF;border-bottom-style:solid;border-bottom-width:2pt;border-bottom-color:#FFFFFF" colspan="2" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">拥有较多内存的节点上可以运行多个 <span class="s96">memcached </span>实例，每个实例使用的内存跟其他节点上</p></td></tr><tr style="height:14pt"><td style="width:65pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF" bgcolor="#EFEFEF"><p class="s95" style="text-indent: 0pt;line-height: 12pt;text-align: left;">的实例相同。</p></td><td style="width:349pt;border-top-style:solid;border-top-width:2pt;border-top-color:#FFFFFF"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr></table><ol id="l58"><li data-list-text="1."><p class="s6" style="padding-top: 1pt;padding-left: 35pt;text-indent: -12pt;line-height: 16pt;text-align: left;">你说的 NoSQL 数据库是什么意思?NoSQL 与 RDBMS 直接有什么区别?为什么要使用和不使用</p><p class="s6" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">NoSQL 数据库?说一说 NoSQL 数据库的几个优点?</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">NoSQL 是非关系型数据库，NoSQL = Not Only SQL。</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">关系型数据库采用的结构化的数据，NoSQL 采用的是键值对的方式存储数据。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">在处理非结构化/半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用 NoSQL 数据库。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">在考虑数据库的成熟度；支持；分析和商业智能；管理及专业性等问题时，应优先考虑关系型数据库。</p></li><li data-list-text="2."><p class="s6" style="padding-top: 8pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">NoSQL 数据库有哪些类型?</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://theprofessionalspoint.blogspot.in/2014/01/types-and-examples-of-nosql-databases.html" class="s101" target="_blank">NoSQL 数据库的类型</a></p><p class="s102" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;"><a href="http://theprofessionalspoint.blogspot.in/2014/01/12-best-free-and-open-source-nosql.html" style=" color: #4F4F4F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;" target="_blank">例如：MongoDB, Cassandra, CouchDB, Hypertable, Redis, Riak, Neo4j, HBASE, Couchbase, MemcacheDB, RevenDB and Voldemort are the examples of NoSQL databases.</a>详细阅读<span style=" color: #4F4F4F;">。</span></p></li><li data-list-text="3."><p class="s6" style="padding-top: 8pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">MySQL 与 MongoDB 之间最基本的差别是什么?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">MySQL 和 MongoDB 两者都是免费开源的数据库。MySQL 和 MongoDB 有许多基本差别包括数据的表示(data representation)，查询，关系，事务，schema 的设计和定义，标准化(normalization)，速度和性能。</p><p style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;"><a href="http://theprofessionalspoint.blogspot.in/2013/12/mysql-vs-mongodb-basic-differences.html" style=" color: #4F4F4F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;" target="_blank">通过比较 MySQL 和 MongoDB，实际上我们是在比较关系型和非关系型数据库，即数据存储结构不同。</a><a href="http://theprofessionalspoint.blogspot.in/2013/12/mysql-vs-mongodb-basic-differences.html" class="s101" target="_blank">详细阅读</a></p></li><li data-list-text="4."><p class="s6" style="padding-top: 8pt;padding-left: 35pt;text-indent: -12pt;text-align: left;">你怎么比较 MongoDB、CouchDB 及 CouchBase?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">MongoDB 和 CouchDB 都是面向文档的数据库。MongoDB 和 CouchDB 都是开源 NoSQL 数据库的最典型代表。 除了都以文档形式存储外它们没有其他的共同点。MongoDB 和 CouchDB 在数据模型实</p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">现、接口、对象存储以及复制方法等方面有很多不同。</p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 148%;text-align: left;"><a href="http://theprofessionalspoint.blogspot.in/2014/01/couchdb-vs-couchbase-differences-and.html" style=" color: #4F4F4F; font-family:微软雅黑, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt;" target="_blank">细节可以参见下面的链接： </a><a href="http://theprofessionalspoint.blogspot.in/2014/01/couchdb-vs-couchbase-differences-and.html" class="s101" target="_blank">MongDB vs CouchDB CouchDB vs CouchBase</a></p></li><li data-list-text="5."><p class="s6" style="padding-left: 33pt;text-indent: -10pt;text-align: left;">MongoDB 成为最好 NoSQL 数据库的原因是什么?</p></li></ol><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">以下特点使得 MongoDB 成为最好的 NoSQL 数据库：</p><ul id="l59"><li data-list-text=""><p class="s10" style="padding-top: 8pt;padding-left: 40pt;text-indent: -18pt;text-align: left;">面向文件的</p></li><li data-list-text=""><p class="s10" style="padding-top: 7pt;padding-left: 40pt;text-indent: -18pt;text-align: left;">高性能</p></li><li data-list-text=""><p class="s10" style="padding-top: 7pt;padding-left: 40pt;text-indent: -18pt;text-align: left;">高可用性</p></li><li data-list-text=""><p class="s10" style="padding-top: 7pt;padding-left: 40pt;text-indent: -18pt;text-align: left;">易扩展性</p></li><li data-list-text=""><p class="s10" style="padding-top: 7pt;padding-left: 40pt;text-indent: -18pt;text-align: left;">丰富的查询语言</p><p class="s6" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">6.32 位系统上有什么细微差别?</p><p class="s7" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">journaling 会激活额外的内存映射文件。这将进一步抑制 32 位版本上的数据库大小。因此，现在</p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">journaling 在 32 位系统上默认是禁用的。</p><ol id="l60"><li data-list-text="7."><p class="s6" style="padding-top: 7pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">journal 回放在条目(entry)不完整时(比如恰巧有一个中途故障了)会遇到问题吗?</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">每个 journal (group)的写操作都是一致的，除非它是完整的否则在恢复过程中它不会回放。</p></li><li data-list-text="8."><p class="s6" style="padding-top: 7pt;padding-left: 35pt;text-indent: -12pt;text-align: left;">分析器在 MongoDB 中的作用是什么?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">MongoDB 中包括了一个可以显示数据库中每个操作性能特点的数据库分析器。通过这个分析器你可以找到比预期慢的查询(或写操作);利用这一信息，比如，可以确定是否需要添加索引。</p></li><li data-list-text="9."><p class="s6" style="padding-top: 8pt;padding-left: 35pt;text-indent: -12pt;text-align: left;">名字空间(namespace)是什么?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">MongoDB 存储 BSON 对象在丛集(collection)中。数据库名字和丛集名字以句点连结起来叫做名字空间 (namespace)。</p></li><li data-list-text="10."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">如果用户移除对象的属性，该属性是否从存储层中删除?</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">是的，用户移除属性然后对象会重新保存(re-save())。</p></li><li data-list-text="11."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">能否使用日志特征进行安全备份?</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">是的。</p></li><li data-list-text="12."><p class="s6" style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">允许空值 null 吗?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">对于对象成员而言，是的。然而用户不能够添加空值(null)到数据库丛集(collection)因为空值不是对象。然而用户能够添加空对象{}。</p></li><li data-list-text="13."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">更新操作立刻 fsync 到磁盘?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">不会，磁盘写操作默认是延迟执行的。写操作可能在两三秒(默认在 60 秒内)后到达磁盘。例如，如果一秒内数据库收到一千个对一个对象递增的操作，仅刷新磁盘一次。(注意，尽管 fsync 选项在命令行和经过 getLastError_old 是有效的)(译者：也许是坑人的面试题??)。</p></li><li data-list-text="14."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;">如何执行事务/加锁?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">MongoDB 没有使用传统的锁或者复杂的带回滚的事务，因为它设计的宗旨是轻量，快速以及可预计的高性能。可以把它类比成 MySQL MylSAM 的自动提交模式。通过精简对事务的支持，性能得到了提升，特别是在一个可能会穿过多个服务器的系统里。</p></li><li data-list-text="15."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">为什么我的数据文件如此庞大?</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">MongoDB 会积极的预分配预留空间来防止文件系统碎片。</p></li><li data-list-text="16."><p class="s6" style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">启用备份故障恢复需要多久?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">从备份数据库声明主数据库宕机到选出一个备份数据库作为新的主数据库将花费 10 到 30 秒时间。这期间在主数据库上的操作将会失败--包括写入和强一致性读取(strong consistent read)操作。然而，你还能在第二数据库上执行最终一致性查询(eventually consistent query)(在 slaveOk 模式下)，即使在这段时间里。</p></li><li data-list-text="17."><p class="s6" style="padding-top: 1pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">什么是 master 或 primary?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">它是当前备份集群(replica set)中负责处理所有写入操作的主要节点/成员。在一个备份集群中，当失效备援(failover)事件发生时，一个另外的成员会变成 primary。</p></li><li data-list-text="18."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">什么是 secondary 或 slave?</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Seconday 从当前的 primary 上复制相应的操作。它是通过跟踪复制 oplog(local.oplog.rs)做到的。</p></li><li data-list-text="19."><p class="s6" style="padding-top: 7pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">我必须调用 getLastError 来确保写操作生效了么?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">不用。不管你有没有调用 getLastError(又叫&quot;Safe Mode&quot;)服务器做的操作都一样。调用 getLastError 只是为了确认写操作成功提交了。当然，你经常想得到确认，但是写操作的安全性和是否生效不是由这个决定的。</p></li><li data-list-text="20."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;">我应该启动一个集群分片(sharded)还是一个非集群分片的 MongoDB 环境?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">为开发便捷起见，我们建议以非集群分片(unsharded)方式开始一个 MongoDB 环境，除非一台服务器不足以存放你的初始数据集。从非集群分片升级到集群分片(sharding)是无缝的，所以在你的数据集还不是很大的时候没必要考虑集群分片(sharding)。</p></li><li data-list-text="21."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;">分片(sharding)和复制(replication)是怎样工作的?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">每一个分片(shard)是一个分区数据的逻辑集合。分片可能由单一服务器或者集群组成，我们推荐为每一个分片(shard)使用集群。</p></li><li data-list-text="22."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">数据在什么时候才会扩展到多个分片(shard)里?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">MongoDB 分片是基于区域(range)的。所以一个集合(collection)中的所有的对象都被存放到一个块 (chunk)中。只有当存在多余一个块的时候，才会有多个分片获取数据的选项。现在，每个默认块的大小是 64Mb，所以你需要至少 64 Mb 空间才可以实施一个迁移。</p></li><li data-list-text="23."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">当我试图更新一个正在被迁移的块(chunk)上的文档时会发生什么?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">更新操作会立即发生在旧的分片(shard)上，然后更改才会在所有权转移(ownership transfers)前复制到新的分片上。</p></li><li data-list-text="24."><p class="s7" style="padding-top: 8pt;padding-left: 40pt;text-indent: -17pt;text-align: justify;">如果在一个分片(shard)停止或者很慢的时候，我发起一个查询会怎样?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">如果一个分片(shard)停止了，除非查询设置了“Partial”选项，否则查询会返回一个错误。如果一个分片(shard)响应很慢，MongoDB 则会等待它的响应。</p></li><li data-list-text="25."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;">我可以把 moveChunk 目录里的旧文件删除吗?</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">没问题，这些文件是在分片(shard)进行均衡操作(balancing)的时候产生的临时文件。一旦这些操作已经完成，相关的临时文件也应该被删除掉。但目前清理工作是需要手动的，所以请小心地考虑再释放这些文件的空间。</p></li><li data-list-text="26."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: justify;">我怎么查看 Mongo 正在使用的链接?</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">db._adminCommand(&quot;connPoolStats&quot;);</p></li><li data-list-text="27."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">如果块移动操作(moveChunk)失败了，我需要手动清除部分转移的文档吗?</p><p class="s7" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">不需要，移动操作是一致(consistent)并且是确定性的(deterministic);一次失败后，移动操作会不断重试;当完成后，数据只会出现在新的分片里(shard)。</p></li><li data-list-text="28."><p class="s6" style="padding-top: 8pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">如果我在使用复制技术(replication)，可以一部分使用日志(journaling)而其他部分则不使用吗?</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">可以。</p></li><li data-list-text="29."><p class="s6" style="padding-top: 7pt;padding-left: 36pt;text-indent: -13pt;text-align: left;">当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">更新操作会立即发生在旧的块（Chunk）上，然后更改才会在所有权转移前复制到新的分片上。</p></li><li data-list-text="30."><p class="s6" style="padding-top: 8pt;padding-left: 36pt;text-indent: -13pt;text-align: left;">MongoDB 在 A:{B,C}上建立索引，查询 A:{B,C}和 A:{C,B}都会使用索引吗？</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">不会，只会在 A:{B,C}上使用索引。</p></li><li data-list-text="31."><p class="s6" style="padding-top: 7pt;padding-left: 36pt;text-indent: -13pt;text-align: left;">如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">如果一个分片停止了，除非查询设置了“Partial”选项，否则查询会返回一个错误。如果一个分片响应很慢，MongoDB 会等待它的响应。</p></li><li data-list-text="32."><p class="s6" style="padding-top: 8pt;padding-left: 39pt;text-indent: -16pt;text-align: left;">MongoDB 支持存储过程吗？如果支持的话，怎么用？</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">MongoDB 支持存储过程，它是 javascript 写的，保存在 db.system.js 表中。</p></li><li data-list-text="33."><p class="s6" style="padding-top: 7pt;padding-left: 36pt;text-indent: -13pt;text-align: left;">如何理解 MongoDB 中的 GridFS 机制，MongoDB 为何使用 GridFS 来存储文件？</p></li></ol><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">GridFS 是一种将大型文件存储在 MongoDB 中的文件规范。使用 GridFS 可以将大文件分隔成多个小文档存放，这样我们能够有效的保存大文档，而且解决了 BSON 对象有限制的问题。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1<span class="p">、什么是 </span>MyBatis<span class="p">？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：<span class="s84">MyBatis </span>是一个可以自定义 <span class="s84">SQL</span>、存储过程和高级映射的持久层框架。 <span class="s84">2</span>、讲下 <span class="s84">MyBatis </span>的缓存</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：<span class="s84">MyBatis </span>的缓存分为一级缓存和二级缓存<span class="s84">,</span>一级缓存放在 <span class="s84">session </span>里面<span class="s84">,</span>默认就有<span class="s84">,</span>二级缓存放在它的命名空间里<span class="s84">,</span>默认是不打开的<span class="s84">,</span>使用二级缓存属性类需要实现 <span class="s84">Serializable </span>序列化接口<span class="s84">(</span>可用来保存对象的状态<span class="s84">),</span>可在它的映射文件中配置<span class="s84">&lt;cache/&gt;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">3<span class="p">、</span>Mybatis <span class="p">是如何进行分页的？分页插件的原理是什么？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l61"><li data-list-text="1）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mybatis <span class="p">使用 </span>RowBounds <span class="p">对象进行分页，也可以直接编写 </span>sql <span class="p">实现分页，也可以使用 </span>Mybatis <span class="p">的分页插件。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">分页插件的原理：实现 <span class="s84">Mybatis </span>提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的 <span class="s84">sql</span>，然后重写 <span class="s84">sql</span>。</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">举例：<span class="s84">select * from student</span>，拦截 <span class="s84">sql </span>后重写为：<span class="s84">select t.* from </span>（<span class="s84">select * from student</span>）<span class="s84">t limit 0</span>，<span class="s84">10</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">4<span class="p">、简述 </span>Mybatis <span class="p">的插件运行原理，以及如何编写一个插件？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l62"><li data-list-text="1）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mybatis <span class="p">仅可以编写针对 </span>ParameterHandler<span class="p">、</span>ResultSetHandler<span class="p">、</span>StatementHandler<span class="p">、 </span>Executor <span class="p">这 </span>4 <span class="p">种接口的插件，</span>Mybatis <span class="p">通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 </span>4 <span class="p">种接口对象的方法时，就会进入拦截方法，具体就是 </span>InvocationHandler <span class="p">的 </span>invoke()<span class="p">方法，当然，只会拦截那些你指定需要拦截的方法。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">实现 <span class="s84">Mybatis </span>的 <span class="s84">Interceptor </span>接口并复写 <span class="s84">intercept()</span>方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">5<span class="p">、</span>Mybatis <span class="p">动态 </span>sql <span class="p">是做什么的？都有哪些动态 </span>sql<span class="p">？能简述一下动态 </span>sql <span class="p">的执行原理不？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l63"><li data-list-text="1）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mybatis <span class="p">动态 </span>sql <span class="p">可以让我们在 </span>Xml <span class="p">映射文件内，以标签的形式编写动态 </span>sql<span class="p">，完成逻辑判断和动态拼接 </span>sql <span class="p">的功能。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mybatis <span class="p">提供了 </span>9 <span class="p">种动态 </span>sql <span class="p">标签： </span>trim|where|set|foreach|if|choose|when|otherwise|bind<span class="p">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3）"><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">其执行原理为，使用 <span class="s84">OGNL </span>从 <span class="s84">sql </span>参数对象中计算表达式的值，根据表达式的值动态拼接 <span class="s84">sql</span>，以此来完成动态 <span class="s84">sql </span>的功能。</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">6<span class="p">、</span>#{}<span class="p">和</span>${}<span class="p">的区别是什么？答：</span></p><ol id="l64"><li data-list-text="1）"><p class="s84" style="padding-top: 2pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">#{}<span class="p">是预编译处理，</span>${}<span class="p">是字符串替换。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Mybatis <span class="p">在处理</span>#{}<span class="p">时，会将 </span>sql <span class="p">中的</span>#{}<span class="p">替换为</span>?<span class="p">号，调用 </span>PreparedStatement <span class="p">的 </span>set <span class="p">方法来赋值；</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3）"><p class="s84" style="padding-left: 38pt;text-indent: -15pt;text-align: left;">Mybatis <span class="p">在处理</span>${}<span class="p">时，就是把</span>${}<span class="p">替换成变量的值。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">使用<span class="s84">#{}</span>可以有效的防止 <span class="s84">SQL </span>注入，提高系统安全性。</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">7<span class="p">、为什么说 </span>Mybatis <span class="p">是半自动 </span>ORM <span class="p">映射工具？它与全自动的区别在哪里？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：<span class="s84">Hibernate </span>属于全自动 <span class="s84">ORM </span>映射工具，使用 <span class="s84">Hibernate </span>查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 <span class="s84">Mybatis </span>在查询关联对象或关联集合对象时，需要手动编写 <span class="s84">sql </span>来完成，所以，称之为半自动 <span class="s84">ORM </span>映射工具。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">8<span class="p">、</span>Mybatis <span class="p">是否支持延迟加载？如果支持，它的实现原理是什么？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l65"><li data-list-text="1）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Mybatis <span class="p">仅支持 </span>association <span class="p">关联对象和 </span>collection <span class="p">关联集合对象的延迟加载，</span>association<span class="p">指的就是一对一，</span>collection <span class="p">指的就是一对多查询。在 </span>Mybatis <span class="p">配置文件中，可以配置是否启用延迟加载 </span>lazyLoadingEnabled=true|false<span class="p">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">它的原理是，使用 <span class="s84">CGLIB </span>创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <span class="s84">a.getB().getName()</span>，拦截器 <span class="s84">invoke()</span>方法发现 <span class="s84">a.getB()</span>是 <span class="s84">null </span>值，那么就会单独发送事先保存好的查询关联 <span class="s84">B </span>对象的 <span class="s84">sql</span>，把 <span class="s84">B </span>查询上来，然后调用 <span class="s84">a.setB(b)</span>，于是 <span class="s84">a </span>的对象 <span class="s84">b </span>属性就有值了，接着完成 <span class="s84">a.getB().getName()</span>方法的调用。这就是延迟加载的基本原理。</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">9<span class="p">、</span>MyBatis <span class="p">与 </span>Hibernate <span class="p">有哪些不同？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l66"><li data-list-text="1）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mybatis <span class="p">和 </span>hibernate <span class="p">不同，它不完全是一个 </span>ORM <span class="p">框架，因为 </span>MyBatis <span class="p">需要程序员自己编写 </span>Sql <span class="p">语句，不过 </span>mybatis <span class="p">可以通过 </span>XML <span class="p">或注解方式灵活配置要运行的 </span>sql <span class="p">语句，并将 </span>java <span class="p">对象和 </span>sql <span class="p">语句映射生成最终执行的 </span>sql<span class="p">，最后将 </span>sql <span class="p">执行的结果再映射生成 </span>java <span class="p">对 象。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mybatis <span class="p">学习门槛低，简单易学，程序员直接编写原生态 </span>sql<span class="p">，可严格控制 </span>sql <span class="p">执行性 能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是 </span>mybatis <span class="p">无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 </span>sql <span class="p">映射文件，工作量大。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Hibernate <span class="p">对象</span>/<span class="p">关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用 </span>hibernate <span class="p">开发可以节省很多代码，提高效率。但是 </span>Hibernate <span class="p">的缺点是学习门槛高，要精通门槛更高，而且怎么设计 </span>O/R <span class="p">映射，在性能和对象</span></p></li></ol><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">模型之间如何权衡，以及怎样用好 <span class="s84">Hibernate </span>需要具有很强的经验和能力才行。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">10<span class="p">、</span>MyBatis <span class="p">的好处是什么？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l67"><li data-list-text="1）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">MyBatis <span class="p">把 </span>sql <span class="p">语句从 </span>Java <span class="p">源程序中独立出来，放在单独的 </span>XML <span class="p">文件中编写，给程序的维护带来了很大便利。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">MyBatis <span class="p">封装了底层 </span>JDBC API <span class="p">的调用细节，并能自动将结果集转换成 </span>Java Bean <span class="p">对象，大大简化了 </span>Java <span class="p">数据库编程的重复工作。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3）"><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">因为 <span class="s84">MyBatis </span>需要程序员自己去编写 <span class="s84">sql </span>语句，程序员可以结合数据库自身的特点灵活控制 <span class="s84">sql </span>语句，因此能够实现比 <span class="s84">Hibernate </span>等全自动 <span class="s84">orm </span>框架更高的查询效率，能够完成复杂查询。</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">11<span class="p">、简述 </span>Mybatis <span class="p">的 </span>Xml <span class="p">映射文件和 </span>Mybatis <span class="p">内部数据结构之间的映射关系？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：<span class="s84">Mybatis </span>将所有 <span class="s84">Xml </span>配置信息都封装到 <span class="s84">All-In-One </span>重量级对象 <span class="s84">Configuration </span>内部。在 <span class="s84">Xml </span>映射文件中，<span class="s84">&lt;parameterMap&gt;</span>标签会被解析为 <span class="s84">ParameterMap </span>对象，其每个子元素会被解析为 <span class="s84">ParameterMapping </span>对象。<span class="s84">&lt;resultMap&gt;</span>标签会被解析为 <span class="s84">ResultMap </span>对象，其每个子元素会被解析为 <span class="s84">ResultMapping </span>对象。每一个<span class="s84">&lt;select&gt;</span>、<span class="s84">&lt;insert&gt;</span>、<span class="s84">&lt;update&gt;</span>、<span class="s84">&lt;delete&gt;</span>标签均会被解析为 <span class="s84">MappedStatement </span>对象，标签内的 <span class="s84">sql </span>会被解析为 <span class="s84">BoundSql </span>对象。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">12<span class="p">、什么是 </span>MyBatis <span class="p">的接口绑定</span>,<span class="p">有什么好处？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：接口映射就是在 <span class="s84">MyBatis </span>中任意定义接口<span class="s84">,</span>然后把接口里面的方法和 <span class="s84">SQL </span>语句绑定<span class="s84">,</span>我们直接调用接口方法就可以<span class="s84">,</span>这样比起原来了 <span class="s84">SqlSession </span>提供的方法我们可以有更加灵活的选择和设置<span class="s84">.</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">13<span class="p">、接口绑定有几种实现方式</span>,<span class="p">分别是怎么实现的</span>?</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：接口绑定有两种实现方式<span class="s84">,</span>一种是通过注解绑定<span class="s84">,</span>就是在接口的方法上面加上 <span class="s84">@Select@Update </span>等注解里面包含 <span class="s84">Sql </span>语句来绑定<span class="s84">,</span>另外一种就是通过 <span class="s84">xml </span>里面写 <span class="s84">SQL </span>来绑定<span class="s84">,</span>在这种情况下<span class="s84">,</span>要指定 <span class="s84">xml </span>映射文件里面的 <span class="s84">namespace </span>必须为接口的全路径名<span class="s84">.</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">14<span class="p">、什么情况下用注解绑定</span>,<span class="p">什么情况下用 </span>xml <span class="p">绑定？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">答：当 <span class="s84">Sql </span>语句比较简单时候<span class="s84">,</span>用注解绑定；当 <span class="s84">SQL </span>语句比较复杂时候<span class="s84">,</span>用 <span class="s84">xml </span>绑定<span class="s84">,</span>一般用</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">xml <span class="p">绑定的比较多</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">15<span class="p">、</span>MyBatis <span class="p">实现一对一有几种方式</span>?<span class="p">具体怎么操作的？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：有联合查询和嵌套查询<span class="s84">,</span>联合查询是几个表联合查询<span class="s84">,</span>只查询一次<span class="s84">,</span>通过在 <span class="s84">resultMap </span>里面配置 <span class="s84">association </span>节点配置一对一的类就可以完成<span class="s84">;</span>嵌套查询是先查一个表<span class="s84">,</span>根据这个表里面的结果的外键 <span class="s84">id,</span>去再另外一个表里面查询数据<span class="s84">,</span>也是通过 <span class="s84">association </span>配置<span class="s84">,</span>但另外一个表的查询通过 <span class="s84">select </span>属性配置。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">16<span class="p">、</span>Mybatis <span class="p">能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：能，<span class="s84">Mybatis </span>不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 <span class="s84">selectOne()</span>修改为 <span class="s84">selectList()</span>即</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">可；多对多查询，其实就是一对多查询，只需要把 <span class="s84">selectOne()</span>修改为 <span class="s84">selectList()</span>即可。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">关联对象查询，有两种实现方式，一种是单独发送一个 <span class="s84">sql </span>去查询关联对象，赋给主对 象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 <span class="s84">join </span>查询，一部分列是 <span class="s84">A </span>对象的属性值，另外一部分列是关联对象 <span class="s84">B </span>的属性值，好处是只发一个 <span class="s84">sql </span>查询，就可以把主对象和其关联对象查出来。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">17<span class="p">、</span>MyBatis <span class="p">里面的动态 </span>Sql <span class="p">是怎么设定的</span>?<span class="p">用什么语法</span>?</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：<span class="s84">MyBatis </span>里面的动态 <span class="s84">Sql </span>一般是通过 <span class="s84">if </span>节点来实现<span class="s84">,</span>通过 <span class="s84">OGNL </span>语法来实现<span class="s84">,</span>但是如果要写的完整<span class="s84">,</span>必须配合 <span class="s84">where,trim </span>节点<span class="s84">,where </span>节点是判断包含节点有内容就插入 <span class="s84">where,</span>否则不插入<span class="s84">,trim </span>节点是用来判断如果动态语句是以 <span class="s84">and </span>或 <span class="s84">or </span>开始<span class="s84">,</span>那么会自动把这个 <span class="s84">and </span>或者 <span class="s84">or</span>取掉。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">18<span class="p">、</span>Mybatis <span class="p">是如何将 </span>sql <span class="p">执行结果封装为目标对象并返回的？都有哪些映射形式？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">第一种是使用<span class="s84">&lt;resultMap&gt;</span>标签，逐一定义列名和对象属性名之间的映射关系。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">第二种是使用 <span class="s84">sql </span>列的别名功能，将列别名书写为对象属性名，比如 <span class="s84">T_NAME AS NAME</span>，对象属性名一般是 <span class="s84">name</span>，小写，但是列名不区分大小写，<span class="s84">Mybatis </span>会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 <span class="s84">T_NAME AS NaMe</span>，<span class="s84">Mybatis </span>一样可以正常工作。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">有了列名与属性名的映射关系后，<span class="s84">Mybatis </span>通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">19<span class="p">、</span>Xml <span class="p">映射文件中，除了常见的 </span>select|insert|updae|delete <span class="p">标签之外，还有哪些标签？答：还有很多其他的标签，</span>&lt;resultMap&gt;<span class="p">、</span>&lt;parameterMap&gt;<span class="p">、</span>&lt;sql&gt;<span class="p">、</span>&lt;include&gt;<span class="p">、</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">&lt;selectKey&gt;<span class="p">，加上动态 </span>sql <span class="p">的 </span>9 <span class="p">个标签， </span>trim|where|set|foreach|if|choose|when|otherwise|bind <span class="p">等，其中</span>&lt;sql&gt;<span class="p">为 </span>sql <span class="p">片段标签，通过</span>&lt;include&gt;<span class="p">标签引入 </span>sql <span class="p">片段，</span>&lt;selectKey&gt;<span class="p">为不支持自增的主键生成策略标签。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">20<span class="p">、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定 </span>pojo<span class="p">？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l68"><li data-list-text="1）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">通过在查询的 <span class="s84">sql </span>语句中定义字段名的别名。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">通过<span class="s84">&lt;resultMap&gt;</span>来映射字段名和实体类属性名的一一对应的关系。</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">21<span class="p">、模糊查询 </span>like <span class="p">语句该怎么写答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l69"><li data-list-text="1）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">在 <span class="s84">java </span>中拼接通配符，通过<span class="s84">#{}</span>赋值</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">在 <span class="s84">Sql </span>语句中拼接通配符 （不安全 会引起 <span class="s84">Sql </span>注入）</p></li></ol><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">22<span class="p">、通常一个 </span>Xml <span class="p">映射文件，都会写一个 </span>Dao <span class="p">接口与之对应</span>, Dao <span class="p">的工作原理，是否可以重载？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：不能重载，因为通过 <span class="s84">Dao </span>寻找 <span class="s84">Xml </span>对应的 <span class="s84">sql </span>的时候全限名<span class="s84">+</span>方法名的保存和寻找策 略。接口工作原理为 <span class="s84">jdk </span>动态代理原理，运行时会为 <span class="s84">dao </span>生成 <span class="s84">proxy</span>，代理对象会拦截接口方法，去执行对应的 <span class="s84">sql </span>返回数据。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">23<span class="p">、</span>Mybatis <span class="p">映射文件中，如果 </span>A <span class="p">标签通过 </span>include <span class="p">引用了 </span>B <span class="p">标签的内容，请问，</span>B <span class="p">标签能否定义在 </span>A <span class="p">标签的后面，还是说必须定义在 </span>A <span class="p">标签的前面？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：虽然 <span class="s84">Mybatis </span>解析 <span class="s84">Xml </span>映射文件是按照顺序解析的，但是，被引用的 <span class="s84">B </span>标签依然可以定义在任何地方，<span class="s84">Mybatis </span>都可以正确识别。原理是，<span class="s84">Mybatis </span>解析 <span class="s84">A </span>标签，发现 <span class="s84">A </span>标签引用了 <span class="s84">B </span>标签，但是 <span class="s84">B </span>标签尚未解析到，尚不存在，此时，<span class="s84">Mybatis </span>会将 <span class="s84">A </span>标签标记为未解析状态，然后继续解析余下的标签，包含 <span class="s84">B </span>标签，待所有标签解析完毕，<span class="s84">Mybatis </span>会重新解析那些被标记为未解析的标签，此时再解析 <span class="s84">A </span>标签时，<span class="s84">B </span>标签已经存在，<span class="s84">A </span>标签也就可以正常解析完成了。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">24<span class="p">、</span>Mybatis <span class="p">的 </span>Xml <span class="p">映射文件中，不同的 </span>Xml <span class="p">映射文件，</span>id <span class="p">是否可以重复？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：不同的 <span class="s84">Xml </span>映射文件，如果配置了 <span class="s84">namespace</span>，那么 <span class="s84">id </span>可以重复；如果没有配置 <span class="s84">namespace</span>，那么 <span class="s84">id </span>不能重复；毕竟 <span class="s84">namespace </span>不是必须的，只是最佳实践而已。原因就是 <span class="s84">namespace+id </span>是作为 <span class="s84">Map&lt;String,      MappedStatement&gt;</span>的 <span class="s84">key </span>使用的，如果没有 <span class="s84">namespace</span>，就剩下 <span class="s84">id</span>，那么，<span class="s84">id </span>重复会导致数据互相覆盖。有了 <span class="s84">namespace</span>，自然 <span class="s84">id </span>就可以重复，<span class="s84">namespace </span>不同，<span class="s84">namespace+id </span>自然也就不同。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">25<span class="p">、</span>Mybatis <span class="p">中如何执行批处理？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">答：使用 <span class="s84">BatchExecutor </span>完成批处理。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">26<span class="p">、</span>Mybatis <span class="p">都有哪些 </span>Executor <span class="p">执行器？它们之间的区别是什么？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：<span class="s84">Mybatis </span>有三种基本的 <span class="s84">Executor </span>执行器，<span class="s84">SimpleExecutor</span>、<span class="s84">ReuseExecutor</span>、 <span class="s84">BatchExecutor</span>。<span class="s84">1</span>）<span class="s84">SimpleExecutor</span>：每执行一次 <span class="s84">update </span>或 <span class="s84">select</span>，就开启一个 <span class="s84">Statement </span>对象，用完立刻关闭 <span class="s84">Statement </span>对象。<span class="s84">2</span>）<span class="s84">ReuseExecutor</span>：执行 <span class="s84">update </span>或 <span class="s84">select</span>，以 <span class="s84">sql </span>作为 <span class="s84">key </span>查找 <span class="s84">Statement </span>对象，存在就使用，不存在就创建，用完后，不关闭 <span class="s84">Statement </span>对象，而是放置于 <span class="s84">Map3</span>）<span class="s84">BatchExecutor</span>：完成批处理。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">27<span class="p">、</span>Mybatis <span class="p">中如何指定使用哪一种 </span>Executor <span class="p">执行器？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">答：在 <span class="s84">Mybatis </span>配置文件中，可以指定默认的 <span class="s84">ExecutorType </span>执行器类型，也可以手动给</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">DefaultSqlSessionFactory <span class="p">的创建 </span>SqlSession <span class="p">的方法传递 </span>ExecutorType <span class="p">类型参数。</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">28<span class="p">、</span>Mybatis <span class="p">执行批量插入，能返回数据库主键列表吗？答：能，</span>JDBC <span class="p">都能，</span>Mybatis <span class="p">当然也能。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">29<span class="p">、</span>Mybatis <span class="p">是否可以映射 </span>Enum <span class="p">枚举类？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：<span class="s84">Mybatis </span>可以映射枚举类，不单可以映射枚举类，<span class="s84">Mybatis </span>可以映射任何对象到表的一列上。映射方式为自定义一个 <span class="s84">TypeHandler</span>，实现 <span class="s84">TypeHandler </span>的 <span class="s84">setParameter()</span>和 <span class="s84">getResult()</span>接口方法。<span class="s84">TypeHandler </span>有两个作用，一是完成从 <span class="s84">javaType </span>至 <span class="s84">jdbcType </span>的转换，二是完成 <span class="s84">jdbcType </span>至 <span class="s84">javaType </span>的转换，体现为 <span class="s84">setParameter()</span>和 <span class="s84">getResult()</span>两个方法，分别代表设置 <span class="s84">sql </span>问号占位符参数和获取列查询结果。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">30<span class="p">、如何获取自动生成的</span>(<span class="p">主</span>)<span class="p">键值？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：配置文件设置 <span class="s84">usegeneratedkeys </span>为 <span class="s84">true 31</span>、在 <span class="s84">mapper </span>中如何传递多个参数？</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">答：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l70"><li data-list-text="1）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">直接在方法中传递参数，<span class="s84">xml </span>文件用<span class="s84">#{0} #{1}</span>来获取</p></li><li data-list-text="2）"><p style="padding-top: 2pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">使用 <span class="s84">@param </span>注解<span class="s84">:</span>这样可以直接在 <span class="s84">xml </span>文件中通过<span class="s84">#{name}</span>来获取</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">32<span class="p">、</span>resultType resultMap <span class="p">的区别？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">1<span class="p">）类的名字和数据库相同时，可以直接设置 </span>resultType <span class="p">参数为 </span>Pojo <span class="p">类 </span>2<span class="p">）若不同，需要设置 </span>resultMap <span class="p">将结果名字和 </span>Pojo <span class="p">名字进行转换</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">33<span class="p">、使用 </span>MyBatis <span class="p">的 </span>mapper <span class="p">接口调用时有哪些要求？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l71"><li data-list-text="1）"><p class="s84" style="padding-left: 38pt;text-indent: -15pt;text-align: left;">Mapper <span class="p">接口方法名和 </span>mapper.xml <span class="p">中定义的每个 </span>sql <span class="p">的 </span>id <span class="p">相同</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mapper <span class="p">接口方法的输入参数类型和 </span>mapper.xml <span class="p">中定义的每个 </span>sql  <span class="p">的 </span>parameterType <span class="p">的类型相同</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3）"><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mapper <span class="p">接口方法的输出参数类型和 </span>mapper.xml <span class="p">中定义的每个 </span>sql <span class="p">的 </span>resultType <span class="p">的类型相同</span></p></li><li data-list-text="4）"><p class="s84" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">Mapper.xml <span class="p">文件中的 </span>namespace <span class="p">即是 </span>mapper <span class="p">接口的类路径。 </span>34<span class="p">、</span>Mybatis <span class="p">比 </span>IBatis <span class="p">比较大的几个改进是什么？</span></p></li></ol><p style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">答：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l72"><li data-list-text="1）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">有接口绑定<span class="s84">,</span>包括注解绑定 <span class="s84">sql </span>和 <span class="s84">xml </span>绑定 <span class="s84">Sql</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">动态 <span class="s84">sql </span>由原来的节点配置变成 <span class="s84">OGNL </span>表达式 <span class="s84">3</span>） 在一对一<span class="s84">,</span>一对多的时候引进了</p></li></ol><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">association,<span class="p">在一对多的时候引入了 </span>collection <span class="p">节点</span>,<span class="p">不过都是在 </span>resultMap <span class="p">里面配置</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">35<span class="p">、</span>IBatis <span class="p">和 </span>MyBatis <span class="p">在核心处理类分别叫什么？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">答：<span class="s84">IBatis </span>里面的核心处理类交 <span class="s84">SqlMapClient,MyBatis </span>里面的核心处理类叫做 <span class="s84">SqlSession</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">36<span class="p">、</span>IBatis <span class="p">和 </span>MyBatis <span class="p">在细节上的不同有哪些？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l73"><li data-list-text="1）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">在 <span class="s84">sql </span>里面变量命名有原来的<span class="s84">#</span>变量<span class="s84"># </span>变成了<span class="s84">#{</span>变量<span class="s84">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">原来的<span class="s84">$</span>变量<span class="s84">$</span>变成了<span class="s84">${</span>变量<span class="s84">}</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">原来在 <span class="s84">sql </span>节点里面的 <span class="s84">class </span>都换名字交 <span class="s84">type</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">原来的 <span class="s84">queryForObject queryForList </span>变成了 <span class="s84">selectOne selectList5</span>）原来的别名设置在映</p></li></ol><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">射文件里面放在了核心配置文件里</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">1<span class="p">、一张表，里面有 </span>ID <span class="p">自增主键，当 </span>insert <span class="p">了 </span>17 <span class="p">条记录之后，删除了第 </span>15,16,17 <span class="p">条记录，再把 </span>Mysql <span class="p">重启，再 </span>insert <span class="p">一条记录，这条记录的 </span>ID <span class="p">是 </span>18 <span class="p">还是 </span>15 <span class="p">？</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">(1)<span class="p">如果表的类型是 </span>MyISAM<span class="p">，那么是 </span>18</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">因为 <span class="s84">MyISAM </span>表会把自增主键的最大 <span class="s84">ID </span>记录到数据文件里，重启 <span class="s84">MySQL </span>自增主键的最大 <span class="s84">ID </span>也不会丢失</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">（<span class="s84">2</span>）如果表的类型是 <span class="s84">InnoDB</span>，那么是 <span class="s84">15</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">InnoDB <span class="p">表只是把自增主键的最大 </span>ID <span class="p">记录到内存中，所以重启数据库或者是对表进行 </span>OPTIMIZE <span class="p">操作，都会导致最大 </span>ID <span class="p">丢失</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">2<span class="p">、</span>Mysql <span class="p">的技术特点是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mysql <span class="p">数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程 </span>SQL <span class="p">服务器、不同的后端、广泛的应用程序编程接口和管理工具。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">3<span class="p">、</span>Heap <span class="p">表是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">HEAP <span class="p">表存在于内存中，用于临时高速存储。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">BLOB <span class="p">或 </span>TEXT <span class="p">字段是不允许的</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">只能使用比较运算符<span class="s84">=</span>，<span class="s84">&lt;</span>，<span class="s84">&gt;</span>，<span class="s84">=&gt;</span>，<span class="s84">= &lt;</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">HEAP <span class="p">表不支持 </span>AUTO_INCREMENT</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">索引不可为 <span class="s84">NULL</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">4<span class="p">、</span>Mysql <span class="p">服务器默认端口是什么？ </span>Mysql <span class="p">服务器的默认端口是 </span>3306<span class="p">。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">5<span class="p">、与 </span>Oracle <span class="p">相比，</span>Mysql <span class="p">有什么优势？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mysql <span class="p">是开源软件，随时可用，无需付费。 </span>Mysql <span class="p">是便携式的</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">带有命令提示符的 <span class="s84">GUI</span>。</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">使用 <span class="s84">Mysql </span>查询浏览器支持管理 <span class="s84">6</span>、如何区分 <span class="s84">FLOAT </span>和 <span class="s84">DOUBLE</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">以下是 <span class="s84">FLOAT </span>和 <span class="s84">DOUBLE </span>的区别：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">浮点数以 <span class="s84">8 </span>位精度存储在 <span class="s84">FLOAT </span>中，并且有四个字节。浮点数存储在 <span class="s84">DOUBLE </span>中，精度为 <span class="s84">18 </span>位，有八个字节。 <span class="s84">7</span>、区分 <span class="s84">CHAR_LENGTH </span>和 <span class="s84">LENGTH</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">CHAR_LENGTH <span class="p">是字符数，而 </span>LENGTH <span class="p">是字节数。</span>Latin <span class="p">字符的这两个数据是相同的，但是对于 </span>Unicode <span class="p">和其他编码，它们是不同的。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">8<span class="p">、请简洁描述 </span>Mysql <span class="p">中 </span>InnoDB <span class="p">支持的四种事务隔离级别名称，以及逐级之间的区别？</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">SQL <span class="p">标准定义的四个隔离级别为：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">read uncommited <span class="p">：读到未提交数据 </span>read committed<span class="p">：脏读，不可重复读 </span>repeatable read<span class="p">：可重读</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">serializable <span class="p">：串行事物</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">9<span class="p">、在 </span>Mysql <span class="p">中 </span>ENUM <span class="p">的用法是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">ENUM <span class="p">是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 242%;text-align: left;">Create table size(name ENUM(&#39;Smail,&#39;Medium&#39;,&#39;Large&#39;); 10<span class="p">、如何定义 </span>REGEXP<span class="p">？</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">REGEXP <span class="p">是模式匹配，其中匹配模式在搜索值的任何位置。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">11<span class="p">、</span>CHAR <span class="p">和 </span>VARCHAR <span class="p">的区别？ 以下是 </span>CHAR <span class="p">和 </span>VARCHAR <span class="p">的区别：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">CHAR <span class="p">和 </span>VARCHAR <span class="p">类型在存储和检索方面有所不同</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">CHAR <span class="p">列长度固定为创建表时声明的长度，长度值范围是 </span>1 <span class="p">到 </span>255</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">当 <span class="s84">CHAR </span>值被存储时，它们被用空格填充到特定长度，检索 <span class="s84">CHAR </span>值时需删除尾随空格。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">12<span class="p">、列的字符串类型可以是什么？字符串类型是：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">SET BLOB ENUM CHAR TEXT</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">VARCHAR</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">13<span class="p">、如何获取当前的 </span>Mysql <span class="p">版本？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">SELECT VERSION();<span class="p">用于获取当前 </span>Mysql <span class="p">的版本。 </span>14<span class="p">、</span>Mysql <span class="p">中使用什么存储引擎？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">存储引擎称为表类型，数据使用各种技术存储在文件中。技术涉及：</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">Storage mechanism Locking levels Indexing</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Capabilities and functions.</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">15<span class="p">、</span>Mysql <span class="p">驱动程序是什么？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">以下是 <span class="s84">Mysql </span>中可用的驱动程序： <span class="s84">PHP </span>驱动程序</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 117%;text-align: left;">JDBC <span class="p">驱动程序 </span>ODBC <span class="p">驱动程序 </span>CWRAPPER</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">PYTHON <span class="p">驱动程序 </span>PERL <span class="p">驱动程序 </span>RUBY <span class="p">驱动程序 </span>CAP11PHP <span class="p">驱动程序 </span>Ado.net5.mxj</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">16<span class="p">、</span>TIMESTAMP <span class="p">在 </span>UPDATE CURRENT_TIMESTAMP <span class="p">数据类型上做什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">创建表时 <span class="s84">TIMESTAMP </span>列用 <span class="s84">Zero </span>更新。只要表中的其他字段发生更改，<span class="s84">UPDATE CURRENT_TIMESTAMP </span>修饰符就将时间戳字段更新为当前时间。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">17<span class="p">、主键和候选键有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">表格的每一行都由主键唯一标识<span class="s84">,</span>一个表只有一个主键。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">18<span class="p">、如何使用 </span>Unix shell <span class="p">登录 </span>Mysql<span class="p">？我们可以通过以下命令登录：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 120%;text-align: left;">[mysql dir]/bin/mysql -h hostname -u 19<span class="p">、 </span>myisamchk <span class="p">是用来做什么的？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">它用来压缩 <span class="s84">MyISAM </span>表，这减少了磁盘或内存使用。 <span class="s84">20</span>、<span class="s84">MYSQL </span>数据库服务器性能分析的方法命令有哪些<span class="s84">?</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">21<span class="p">、如何控制 </span>HEAP <span class="p">表的最大尺寸？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">Heal <span class="p">表的大小可通过称为 </span>max_heap_table_size <span class="p">的 </span>Mysql <span class="p">配置变量来控制。 </span>22<span class="p">、</span>MyISAM Static <span class="p">和 </span>MyISAM Dynamic <span class="p">有什么区别？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">在 <span class="s84">MyISAM  Static </span>上的所有字段有固定宽度。动态 <span class="s84">MyISAM </span>表将具有像 <span class="s84">TEXT</span>，<span class="s84">BLOB </span>等字段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">MyISAM Static <span class="p">在受损情况下更容易恢复。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">23<span class="p">、</span>federated <span class="p">表是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">federated <span class="p">表，允许访问位于其他服务器数据库上的表。 </span>24<span class="p">、如果一个表有一列定义为 </span>TIMESTAMP<span class="p">，将发生什么？每当行被更改时，时间戳字段将获取当前时间戳。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">25<span class="p">、列设置为 </span>AUTO INCREMENT <span class="p">时，如果在表中达到最大值，会发生什么情况？它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">26<span class="p">、怎样才能找出最后一次插入时分配了哪个自动增量？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">LAST_INSERT_ID <span class="p">将返回由 </span>Auto_increment <span class="p">分配的最后一个值，并且不需要指定表名称。 </span>27<span class="p">、你怎么看到为表格定义的所有索引？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">索引是通过以下方式为表格定义的：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">SHOW INDEX FROM</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">28.<span class="p">、</span>LIKE <span class="p">声明中的％和</span>_<span class="p">是什么意思？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">％对应于 <span class="s84">0 </span>个或更多字符，<span class="s84">_</span>只是 <span class="s84">LIKE </span>语句中的一个字符。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">29<span class="p">、如何在 </span>Unix <span class="p">和 </span>Mysql <span class="p">时间戳之间进行转换？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">UNIX_TIMESTAMP <span class="p">是从 </span>Mysql <span class="p">时间戳转换为 </span>Unix <span class="p">时间戳的命令 </span>FROM_UNIXTIME <span class="p">是从 </span>Unix <span class="p">时间戳转换为 </span>Mysql <span class="p">时间戳的命令 </span>30<span class="p">、列对比运算符是什么？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">在 <span class="s84">SELECT </span>语句的列比较中使用<span class="s84">=</span>，<span class="s84">&lt;&gt;</span>，<span class="s84">&lt;=</span>，<span class="s84">&lt;</span>，<span class="s84">&gt; =</span>，<span class="s84">&gt;</span>，<span class="s84">&lt;&lt;</span>，<span class="s84">&gt;&gt;</span>，<span class="s84">&lt;=&gt;</span>，<span class="s84">AND</span>，<span class="s84">OR </span>或 <span class="s84">LIKE </span>运算符。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">31<span class="p">、我们如何得到受查询影响的行数？行数可以通过以下代码获得：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 237%;text-align: justify;">SELECT COUNT(user_id)FROM users; 32<span class="p">、</span>Mysql <span class="p">查询是否区分大小写？不区分</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">SELECT VERSION(), CURRENT_DATE;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 243%;text-align: left;">SeLect version(), current_date; seleCt vErSiOn(), current_DATE;</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">所有这些例子都是一样的，<span class="s84">Mysql </span>不区分大小写。</p><ol id="l74"><li data-list-text="33."><p style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">、<span class="s84">LIKE </span>和 <span class="s84">REGEXP </span>操作有什么区别？ <span class="s84">LIKE </span>和 <span class="s84">REGEXP </span>运算符用于表示<span class="s84">^</span>和％。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 121%;text-align: left;">SELECT * FROM employee WHERE emp_name REGEXP &quot;^b&quot;; SELECT * FROM employee WHERE emp_name LIKE &quot;%b&quot;; 34.<span class="p">、</span>BLOB <span class="p">和 </span>TEXT <span class="p">有什么区别？</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">BLOB <span class="p">是一个二进制对象，可以容纳可变数量的数据。有四种类型的 </span>BLOB - TINYBLOB</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 119%;text-align: left;">BLOB MEDIUMBLOB <span class="p">和 </span>LONGBLOB</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">它们只能在所能容纳价值的最大长度上有所不同。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">TEXT <span class="p">是一个不区分大小写的 </span>BLOB<span class="p">。四种 </span>TEXT <span class="p">类型 </span>TINYTEXT</p><p class="s84" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 119%;text-align: left;">TEXT MEDIUMTEXT <span class="p">和 </span>LONGTEXT</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">它们对应于四种 <span class="s84">BLOB </span>类型，并具有相同的最大长度和存储要求。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">BLOB <span class="p">和 </span>TEXT <span class="p">类型之间的唯一区别在于对 </span>BLOB <span class="p">值进行排序和比较时区分大小写，对 </span>TEXT</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">值不区分大小写。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">35<span class="p">、</span>mysql_fetch_array <span class="p">和 </span>mysql_fetch_object <span class="p">的区别是什么？以下是 </span>mysql_fetch_array <span class="p">和 </span>mysql_fetch_object <span class="p">的区别：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">mysql_fetch_array<span class="p">（） </span>- <span class="p">将结果行作为关联数组或来自数据库的常规数组返回。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">mysql_fetch_object - <span class="p">从数据库返回结果行作为对象。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 233%;text-align: left;">36<span class="p">、我们如何在 </span>mysql <span class="p">中运行批处理模式？以下命令用于在批处理模式下运行： </span>mysql;</p><p class="s84" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">mysql mysql.out</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">37<span class="p">、</span>MyISAM <span class="p">表格将在哪里存储，并且还提供其存储格式？每个 </span>MyISAM <span class="p">表格以三种格式存储在磁盘上：</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">·“<span class="s84">.frm</span>”文件存储表定义</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">·数据文件具有“<span class="s84">.MYD</span>”（<span class="s84">MYData</span>）扩展名索引文件具有“<span class="s84">.MYI</span>”（<span class="s84">MYIndex</span>）扩展名 <span class="s84">38.</span>、<span class="s84">Mysql </span>中有哪些不同的表格？</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">共有 <span class="s84">5 </span>种类型的表格：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">MyISAM</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">Heap Merge INNODB ISAM</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">MyISAM <span class="p">是 </span>Mysql <span class="p">的默认存储引擎。 </span>39<span class="p">、</span>ISAM <span class="p">是什么？</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">ISAM <span class="p">简称为索引顺序访问方法。它是由 </span>IBM <span class="p">开发的，用于在磁带等辅助存储系统上存储和检索数据。</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">40<span class="p">、</span>InnoDB <span class="p">是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">lnnoDB <span class="p">是一个由 </span>Oracle <span class="p">公司开发的 </span>Innobase Oy <span class="p">事务安全存储引擎。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">41<span class="p">、</span>Mysql <span class="p">如何优化 </span>DISTINCT<span class="p">？</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">DISTINCT <span class="p">在所有列上转换为 </span>GROUP BY<span class="p">，并与 </span>ORDER BY <span class="p">子句结合使用。 </span>1</p><p class="s84" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 120%;text-align: left;">SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a; 42<span class="p">、如何输入字符为十六进制数字？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（<span class="s84">X</span>），或者只用（<span class="s84">Ox</span>）前缀输入十六进制数字。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">43<span class="p">、如何显示前 </span>50 <span class="p">行？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 234%;text-align: left;">在 <span class="s84">Mysql </span>中，使用以下代码查询显示前 <span class="s84">50 </span>行： <span class="s84">SELECT*FROM</span></p><p class="s84" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">LIMIT 0,50;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">44<span class="p">、可以使用多少列创建索引？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">任何标准表最多可以创建 <span class="s84">16 </span>个索引列。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">45<span class="p">、</span>NOW<span class="p">（）和 </span>CURRENT_DATE<span class="p">（）有什么区别？   </span>NOW<span class="p">（）命令用于显示当前年份，月份，日期，小时，分钟和秒。 </span>CURRENT_DATE<span class="p">（）仅显示当前年份，月份和日期。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">46<span class="p">、什么样的对象可以使用 </span>CREATE <span class="p">语句创建？以下对象是使用 </span>CREATE <span class="p">语句创建的：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">DATABASE EVENT FUNCTION INDEX</p><p class="s84" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">PROCEDURE TABLE TRIGGER USER</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">VIEW</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">47<span class="p">、</span>Mysql <span class="p">表中允许有多少个 </span>TRIGGERS<span class="p">？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">在 <span class="s84">Mysql </span>表中允许有六个触发器，如下： <span class="s84">BEFORE INSERT</span></p><p class="s84" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">AFTER INSERT BEFORE UPDATE AFTER UPDATE BEFORE DELETE AFTER DELETE</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">48<span class="p">、什么是非标准字符串类型？以下是非标准字符串类型：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">TINYTEXT TEXT MEDIUMTEXT LONGTEXT</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">49<span class="p">、什么是通用 </span>SQL <span class="p">函数？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">CONCAT(A, B) - <span class="p">连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">FORMAT(X, D)- <span class="p">格式化数字 </span>X <span class="p">到 </span>D <span class="p">有效数字。 </span>CURRDATE(), CURRTIME()- <span class="p">返回当前日期或时间。 </span>NOW<span class="p">（） </span>- <span class="p">将当前日期和时间作为一个值返回。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">MONTH<span class="p">（），</span>DAY<span class="p">（），</span>YEAR<span class="p">（），</span>WEEK<span class="p">（），</span>WEEKDAY<span class="p">（） </span>- <span class="p">从日期值中提取给定数据。</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">HOUR<span class="p">（），</span>MINUTE<span class="p">（），</span>SECOND<span class="p">（） </span>- <span class="p">从时间值中提取给定数据。 </span>DATEDIFF<span class="p">（</span>A<span class="p">，</span>B<span class="p">） </span>- <span class="p">确定两个日期之间的差异，通常用于计算年龄 </span>SUBTIMES<span class="p">（</span>A<span class="p">，</span>B<span class="p">） </span>- <span class="p">确定两次之间的差异。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">FROMDAYS<span class="p">（</span>INT<span class="p">） </span>- <span class="p">将整数天数转换为日期值。</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">50<span class="p">、解释访问控制列表</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">ACL<span class="p">（访问控制列表）是与对象关联的权限列表。这个列表是 </span>Mysql <span class="p">服务器安全模型的基础，它有助于排除用户无法连接的问题。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mysql <span class="p">将 </span>ACL<span class="p">（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，</span>Mysql <span class="p">会按照预定的顺序检查 </span>ACL <span class="p">的认证信息和权限。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">51<span class="p">、</span>MYSQL <span class="p">支持事务吗？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">在缺省模式下，<span class="s84">MYSQL </span>是 <span class="s84">autocommit </span>模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，<span class="s84">mysql </span>是不支持事务的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">但是如果你的 <span class="s84">MYSQL </span>表类型是使用 <span class="s84">InnoDB Tables </span>或 <span class="s84">BDB tables </span>的话，你的 <span class="s84">MYSQL </span>就可以使用事务处理<span class="s84">,</span>使用 <span class="s84">SET AUTOCOMMIT=0 </span>就可以使 <span class="s84">MYSQL </span>允许在非 <span class="s84">autocommit </span>模式，在非 <span class="s84">autocommit </span>模式下，你必须使用 <span class="s84">COMMIT </span>来提交你的更改，或者用 <span class="s84">ROLLBACK </span>来回滚你的更改。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">示例如下：一</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">START TRANSACTION;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 243%;text-align: left;">SELECT @A:=SUM(salary) FROM table1 WHERE type=1; UPDATE table2 SET summmary=@A WHERE type=1; COMMIT;</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">52<span class="p">、</span>mysql <span class="p">里记录货币用什么字段类型好</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">NUMERIC <span class="p">和 </span>DECIMAL <span class="p">类型被 </span>Mysql <span class="p">实现为同样的类型，这在 </span>SQL92 <span class="p">标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被</span>(<span class="p">并且通常是</span>)<span class="p">指定；点击这里有一套最全阿里面试题总</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">结。 例如：</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">salary DECIMAL(9,2)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">在这个例子中，<span class="s84">9(precision)</span>代表将被用于存储值的总的小数位数，而 <span class="s84">2(scale)</span>代表将被用于存储小数点后的位数。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">因此，在这种情况下，能被存储在 <span class="s84">salary </span>列中的值的范围是从<span class="s84">-9999999.99 </span>到 <span class="s84">9999999.99</span>。在 <span class="s84">ANSI/ISO SQL92 </span>中，句法 <span class="s84">DECIMAL(p)</span>等价于 <span class="s84">DECIMAL(p,0)</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">同样，句法 <span class="s84">DECIMAL </span>等价于 <span class="s84">DECIMAL(p,0)</span>，这里实现被允许决定值 <span class="s84">p</span>。<span class="s84">Mysql </span>当前不支持 <span class="s84">DECIMAL/NUMERIC </span>数据类型的这些变种形式的任一种。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">DECIMAL <span class="p">和 </span>NUMERIC <span class="p">值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">一个字符用于值的每一位、小数点<span class="s84">(</span>如果 <span class="s84">scale&gt;0)</span>和“<span class="s84">-</span>”符号<span class="s84">(</span>对于负值<span class="s84">)</span>。如果 <span class="s84">scale </span>是 <span class="s84">0</span>， <span class="s84">DECIMAL </span>和 <span class="s84">NUMERIC </span>值不包含小数点或小数部分。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">DECIMAL <span class="p">和 </span>NUMERIC <span class="p">值得最大的范围与 </span>DOUBLE <span class="p">一样，但是对于一个给定的 </span>DECIMAL <span class="p">或</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">NUMERIC <span class="p">列，实际的范围可由制由给定列的 </span>precision <span class="p">或 </span>scale <span class="p">限制。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">当这样的列赋给了小数点后面的位超过指定 <span class="s84">scale </span>所允许的位的值，该值根据 <span class="s84">scale </span>四舍五入。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">当一个 <span class="s84">DECIMAL </span>或 <span class="s84">NUMERIC </span>列被赋给了其大小超过指定<span class="s84">(</span>或缺省的）<span class="s84">precision </span>和 <span class="s84">scale </span>隐含的范围的值，<span class="s84">Mysql </span>存储表示那个范围的相应的端点值。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困境的第一步。</p><p class="s84" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">53<span class="p">、</span>MYSQL <span class="p">数据表在什么情况下容易损坏？服务器突然断电导致数据文件损坏。</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">强制关机，没有先关闭 <span class="s84">mysql </span>服务等。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">54<span class="p">、</span>mysql <span class="p">有关权限的表都有哪几个？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mysql <span class="p">服务器通过权限表来控制用户对数据库的访问，权限表存放在 </span>mysql <span class="p">数据库里，由 </span>mysql_install_db <span class="p">脚本初始化。这些权限表分别 </span>user<span class="p">，</span>db<span class="p">，</span>table_priv<span class="p">，</span>columns_priv <span class="p">和 </span>host<span class="p">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">55<span class="p">、</span>Mysql <span class="p">中有哪几种锁？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">MyISAM <span class="p">支持表锁，</span>InnoDB <span class="p">支持表锁和行锁，默认为行锁</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 23pt;text-align: left;"><a href="http://mygirl1314520.iteye.com/blog/829377" class="s103" target="_blank">MySQL 性能优化的 21 个最佳实践</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 21pt;text-align: left;"><a href="http://www.iteye.com/blogs/category/database" style=" color: black; font-family:&quot;Microsoft JhengHei&quot;, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt;" target="_blank">文章分类:</a><a href="http://www.iteye.com/blogs/category/database" class="s105" target="_blank">数据库</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于 Web 应用尤其明显。关于数据库的性能，这并不只是 DBA 才需要担心的事，而这更是我们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时(尤其是查表时的 SQL 语句)，我们都需要注意数据操作的性能。这里，我们不会讲过多的 SQL 语句的优化，而只是针对 MySQL 这一 Web 应用最多的数据库。希望下面的这些优化技巧对你有用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l75"><li data-list-text="1."><p class="s104" style="padding-top: 9pt;padding-left: 65pt;text-indent: -18pt;text-align: left;">为查询缓存优化你的查询</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">大多数的 MySQL 服务器都开启了查询缓存。这是提高性最有效的方法之 一，而且这是被 MySQL 的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让 MySQL 不使用缓存。请看下面的示例：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">上面两条 SQL 语句的差别就是 CURDATE() ，MySQL 的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的 SQL 函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替 MySQL 的函数，从而开启缓存。</p></li><li data-list-text="2."><p class="s104" style="padding-left: 65pt;text-indent: -18pt;line-height: 20pt;text-align: left;">EXPLAIN 你的 SELECT 查询</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">使用 EXPLAIN 关键字可以让你知道 MySQL 是如何处理你的 SQL 语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">挑一个你的 SELECT 语句(推荐挑选那个最复杂的，有多表联接的)，把关键字 EXPLAIN 加到前面。你可以使用 phpmyadmin 来做这个事。然后，你会看到一张表格。下面的这个示例中，我们忘记加上了 group_id 索引，并且有表联接：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-top: 3pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">当我们为 group_id 字段加上索引后：</p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-top: 9pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">我们可以看到，前一个结果显示搜索了 7883 行，而后一个只是搜索了两个</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">表的 9 和 16 行。查看 rows 列可以让我们找到潜在的性能问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s104" style="padding-top: 9pt;padding-left: 65pt;text-indent: -18pt;text-align: left;">当只要一行数据时使用 LIMIT 1</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去 fetch 游标，或是你也许会去检查返回的记录数。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">在这种情况下，加上 LIMIT 1 可以增加性能。这样一样，MySQL 数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">下面的示例，只是为了找一下是否有“中国”的用户，很明显，后面的会比前面的更有效率。(请注意，第一条中是 Select *，第二条是 Select 1)</p><p style="padding-left: 30pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s104" style="padding-left: 65pt;text-indent: -18pt;line-height: 21pt;text-align: left;">为搜索字段建索引</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-top: 3pt;padding-left: 23pt;text-indent: 24pt;text-align: left;">从上图你可以看到那个搜索字串 “last_name LIKE ‘a%’”，一个是建了索引，一个是没有索引，性能差了 4 倍左右。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">另外，你应该也需要知道什么样的搜索是不能使用正常的索引的。例如，当你需要在一篇大的文章中搜索一个词时，如： “WHERE post_content LIKE ‘%apple%’”，索引可能是没有意义的。你可能需要使用 MySQL 全文索引 或是自己做一个索引(比如说：搜索关键词或是 Tag 什么的)</p></li><li data-list-text="5."><p class="s104" style="padding-left: 65pt;text-indent: -18pt;text-align: left;">在 Join 表的时候使用相当类型的例，并将其索引</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">如果你的应用程序有很多 JOIN 查询，你应该确认两个表中 Join 的字段是被建过索引的。这样，MySQL 内部会启动为你优化 Join 的 SQL 语句的机制。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">而且，这些被用来 Join 的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段 Join 在一起，MySQL 就无法使用它们的索引。对于那些 STRING 类型，还需要有相同的字符集才行。(两个表的字符集有可能不一样)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="6."><p class="s104" style="padding-left: 65pt;text-indent: -18pt;line-height: 21pt;text-align: left;">千万不要 ORDER BY RAND()</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">想打乱返回的数据行?随机挑一个数据?真不知道谁发明了这种用法，但很多新手很喜欢这样用。但你确不了解这样做有多么可怕的性能问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">如果你真的想把返回的数据行打乱了，你有 N 种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL 会不得不去执行 RAND()函数(很耗 CPU 时间)，而且这是为了每一行记录去记行，然后再对其排序。就算是你用了 Limit 1 也无济于事(因为要排序)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">下面的示例是随机挑一条记录</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 30pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="7."><p class="s104" style="padding-left: 65pt;text-indent: -18pt;line-height: 21pt;text-align: left;">避免 SELECT *</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和 WEB 服务器是两台独立的服务器的话，这还会增加网络传输的负载。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">所以，你应该养成一个需要什么就取什么的好的习惯。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="8."><p class="s104" style="padding-left: 65pt;text-indent: -18pt;line-height: 21pt;text-align: left;">永远为每张表设置一个 ID</p><p class="s19" style="padding-top: 2pt;padding-left: 23pt;text-indent: 24pt;text-align: left;">我们应该为数据库里的每张表都设置一个 ID 做为其主键，而且最好的是一个 INT 型的(推荐使用 UNSIGNED)，并设置上自动增加的 AUTO_INCREMENT 标</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">志。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主 键。使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的 ID 来构造你的数据结构。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">而且，在 MySQL 数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是 说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">键”。比如：有一个“学生表”有学生的 ID，有一个“课程表”有课程 ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生 ID 和课程 ID 叫“外键”其共同组成主键。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="9."><p class="s104" style="padding-top: 9pt;padding-left: 65pt;text-indent: -18pt;text-align: left;">使用 ENUM 而不是 VARCHAR</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">而不是 VARCHAR。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">MySQL 也有一个“建议”(见第十条)告诉你怎么去重新组织你的表结构。当你有一个 VARCHAR 字段时，这个建议会告诉你把其改成 ENUM 类型。使用 PROCEDURE ANALYSE() 你可以得到相关的建议。</p></li><li data-list-text="10."><p class="s104" style="padding-left: 71pt;text-indent: -24pt;line-height: 20pt;text-align: left;">从 PROCEDURE ANALYSE() 取得建议</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">PROCEDURE ANALYSE() 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">例如，如果你创建了一个 INT 字段作为你的主键，然而并没有太多的数 据，那么，PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">在 phpmyadmin 里，你可以在查看表时，点击 “Propose table structure” 来查看这些建议</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-top: 3pt;padding-left: 23pt;text-indent: 24pt;text-align: left;">一定要注意，这些只是建议，只有当你的表里的数据越来越多时，这些建议才会变得准确。一定要记住，你才是最终做决定的人。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="11."><p class="s104" style="padding-top: 9pt;padding-left: 71pt;text-indent: -24pt;text-align: left;">尽可能的使用 NOT NULL</p><p class="s19" style="padding-top: 4pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">NOT NULL。这看起来好像有点争议，请往下看。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">首先，问问你自己“Empty”和“NULL”有多大的区别(如果是 INT，那就是 0 和 NULL)?如果你觉得它们之间没有什么区别，那么你就不要使用 NULL。 (你知道吗?在 Oracle 里，NULL 和 Empty 的字符串是一样的!)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用 NULL 了，现实情况是很复杂的，依然会有些情况下，你需要使用 NULL 值。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="12."><p class="s104" style="padding-top: 9pt;padding-left: 71pt;text-indent: -24pt;text-align: left;">Prepared Statements</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">Prepared Statements 很像存储过程，是一种运行在后台的 SQL 语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL 注入式”攻击。当然，你也可以手动地检查你的这些变量，然而，手动的检查容易出问题，而且很经常会被程序员忘了。当我们使用一些 framework 或是 ORM 的时候，这样的问题会好一些。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">在性能方面，当一个相同的查询被使用多次的时候，这会为你带来可观的性能优势。你可以给这些 Prepared Statements 定义一些参数，而 MySQL 只会解析一次。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">虽然最新版本的 MySQL 在传输 Prepared Statements 是使用二进制形势，所以这会使得网络传输非常有效率。</p><p class="s19" style="padding-top: 2pt;padding-left: 23pt;text-indent: 24pt;text-align: left;">当然，也有一些情况下，我们需要避免使用 Prepared Statements，因为其不支持查询缓存。但据说版本 5.1 后支持了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">在 PHP 中要使用 prepared statements，你可以查看其使用手册：mysqli</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">扩展 或是使用数据库抽象层，如： PDO.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="13."><p class="s104" style="padding-left: 71pt;text-indent: -24pt;line-height: 21pt;text-align: left;">无缓冲的查询</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">正常的情况下，当你在当你在你的脚本中执行一个 SQL 语句的时候，你的程序会停在那里直到没这个 SQL 语句返回，然后你的程序再往下继续执行。你可以使用无缓冲查询来改变这个行为。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">mysql_unbuffered_query() 发送一个 SQL 语句到 MySQL 而并不像 mysql_query()一样去自动 fethch 和缓存结果。这会相当节约很多可观的内 存，尤其是那些会产生大量结果的查询语句，并且，你不需要等到所有的结果都返回，只需要第一行数据返回的时候，你就可以开始马上开始工作于查询结果了。</p><p class="s19" style="padding-top: 2pt;padding-left: 23pt;text-indent: 24pt;text-align: left;">然而，这会有一些限制。因为你要么把所有行都读走，或是你要在进行下一次的查询前调用 mysql_free_result() 清除结果。而且， mysql_num_rows()或 mysql_data_seek() 将无法使用。所以，是否使用无缓冲的查询你需要仔细考虑。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="14."><p class="s104" style="padding-top: 9pt;padding-left: 71pt;text-indent: -24pt;text-align: left;">把 IP 地址存成 UNSIGNED INT</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的 IP 而不是整形的 IP。如果你用整形来存放，只需要 4 个字节，并且你可以有定长的字 段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的 WHERE 条件：IP between ip1 and ip2。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">我们必需要使用 UNSIGNED INT，因为 IP 地址会使用整个 32 位的无符号整形。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">而你的查询，你可以使用 INET_ATON() 来把一个字符串 IP 转成一个整形，并使用 INET_NTOA() 把一个整形转成一个字符串 IP。在 PHP 中，也有这样的函数 ip2long() 和 long2ip()。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 25pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="15."><p class="s104" style="padding-left: 71pt;text-indent: -24pt;line-height: 21pt;text-align: left;">固定长度的表会更快</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static”或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT， BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">表”了，这样，MySQL 引擎会用另一种方法来处理。</p><p class="s19" style="padding-top: 2pt;padding-left: 23pt;text-indent: 24pt;text-align: justify;">固定长度的表会提高性能，因为 MySQL 搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">使用“垂直分割”技术(见下一条)，你可以分割你的表成为两个一个是定长的，一个则是不定长的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="16."><p class="s104" style="padding-top: 9pt;padding-left: 71pt;text-indent: -24pt;text-align: left;">垂直分割</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。(以前，在银行做过项目，见过一张表有 100 多个字段，很恐怖)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">示例一：在 Users 表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢? 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户 ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性 能。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">示例二： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户 ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去 Join 他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。</p></li><li data-list-text="17."><p class="s104" style="padding-left: 71pt;text-indent: -24pt;text-align: left;">拆分大的 DELETE 或 INSERT 语句</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">如果你把你的表锁上一段时间，比如 30 秒钟，那么对于一个有很高访问量的站点来说，这 30 秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊 WEB 服务 Crash，还可能会让你的整台服务器马上掛了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 30pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="18."><p class="s104" style="padding-left: 71pt;text-indent: -24pt;line-height: 21pt;text-align: left;">越小的列会越快</p><p class="s19" style="padding-top: 2pt;padding-left: 23pt;text-indent: 24pt;text-align: left;">对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">参看 MySQL 的文档 Storage Requirements 查看所有的数据类型。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">如果一个表只会有几列罢了(比如说字典表，配置表)，那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看 Slashdot 的例子(2009 年 11 月 06 日)，一个简单的 ALTER TABLE 语句花了 3 个多小时，因为里面有一千六百万条数据。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="19."><p class="s104" style="padding-top: 9pt;padding-left: 71pt;text-indent: -24pt;text-align: left;">选择正确的存储引擎</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章《MySQL: InnoDB 还是 MyISAM?》讨论和这个事情。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要 update 一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*)这类的计算是超快无比的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">下面是 MySQL 的手册</p><p class="s19" style="padding-top: 2pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">target=”_blank”MyISAM Storage Engine</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">InnoDB Storage Engine</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="20."><p class="s104" style="padding-top: 9pt;padding-left: 71pt;text-indent: -24pt;text-align: left;">使用一个对象关系映射器(Object Relational Mapper)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">使用 ORM (Object Relational Mapper)，你能够获得可靠的性能增涨。一个 ORM 可以做的所有事情，也能被手动的编写出来。但是，这需要一个高级专</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">家。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">ORM 的最重要的是“Lazy Loading”，也就是说，只有在需要的去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用，因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">ORM 还可以把你的 SQL 语句打包成一个事务，这会比单独执行他们快得多得多。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">目前，个人最喜欢的 PHP 的 ORM 是：Doctrine。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="21."><p class="s104" style="padding-top: 9pt;padding-left: 71pt;text-indent: -24pt;text-align: left;">小心“永久链接”</p></li></ol></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: justify;">“永久链接”的目的是用来减少重新创建 MySQL 链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们的 Apache 开始重用它的子进程后——也就是说，下一次的 HTTP 请求会重用 Apache 的子进程，并重用相同的 MySQL 链接。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">PHP 手册：mysql_pconnect()</p><p class="s19" style="padding-top: 4pt;padding-left: 23pt;text-indent: 24pt;text-align: justify;">在理论上来说，这听起来非常的不错。但是从个人经验(也是大多数人的)上来说，这个功能制造出来的麻烦事更多。因为，你只有有限的链接数，内存问题，文件句柄数，等等。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">而且，Apache 运行在极端并行的环境中，会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前，你需要好好地考虑一下你的整个系统的架构。</p><ol id="l76"><li data-list-text="1."><p class="s104" style="padding-left: 35pt;text-indent: -12pt;line-height: 22pt;text-align: left;">数据库三范式是什么<span class="s106">?</span></p><ol id="l77"><li data-list-text="1."><p class="s19" style="padding-top: 11pt;padding-left: 59pt;text-indent: -18pt;text-align: justify;">第一范式（<span class="s107">1NF</span>）：字段具有原子性<span class="s107">,</span>不可再分。<span class="s107">(</span>所有关系型数据库系统都满足第一范式数据库表中的字段都是单一属性的，不可再分<span class="s107">)</span></p></li><li data-list-text="2."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: justify;">第二范式（<span class="s107">2NF</span>）是在第一范式（<span class="s107">1NF</span>）的基础上建立起来的，即满足第二范式（<span class="s107">2NF</span>）必须先满足第一范式（<span class="s107">1NF</span>）。要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。</p></li><li data-list-text="3."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">满足第三范式（<span class="s107">3NF</span>）必须先满足第二范式（<span class="s107">2NF</span>）。简而言之，第三范式（<span class="s107">3NF</span>）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 <span class="s107">&gt;</span>所以第三范式具有如下特征： <span class="s107">&gt;&gt;1. </span>每一列只有一个 值 <span class="s107">&gt;&gt;2. </span>每一行都能区分。 <span class="s107">&gt;&gt;3. </span>每一个表都不包含其他表已经包含的非主关键字信息。</p></li></ol></li><li data-list-text="2."><p class="s104" style="padding-top: 10pt;padding-left: 35pt;text-indent: -12pt;text-align: left;">有哪些数据库优化方面的经验<span class="s106">?</span></p><ol id="l78"><li data-list-text="1."><p class="s19" style="padding-top: 11pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">用 <span class="s107">PreparedStatement</span>， 一般来说比 <span class="s107">Statement </span>性能高：一个 <span class="s107">sql</span></p><p class="s19" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。</p></li><li data-list-text="2."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。</p></li><li data-list-text="3."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等</p></li><li data-list-text="4."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">UNION ALL <span class="s19">要比 </span>UNION <span class="s19">快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用 </span>UNION</p><p class="s107" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">ALL<span class="s19">。 </span>&gt;&gt;UNION <span class="s19">和 </span>UNION ALL <span class="s19">关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。 </span>&gt;1. <span class="s19">对重复结果的处理：</span>UNION <span class="s19">在进行表链接后会筛选掉重复的记录，</span>Union All <span class="s19">不会去除重复记录。 </span>&gt;2. <span class="s19">对排序的处理：</span>Union <span class="s19">将会按照字段的顺序进行排 序；</span>UNION ALL <span class="s19">只是简单的将两个结果合并后就返回。</span></p></li></ol></li><li data-list-text="3."><p class="s104" style="padding-top: 10pt;padding-left: 35pt;text-indent: -12pt;text-align: left;">请简述常用的索引有哪些种类<span class="s106">?</span></p><ol id="l79"><li data-list-text="1."><p class="s19" style="padding-top: 11pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">普通索引<span class="s107">: </span>即针对数据库表创建索引</p></li><li data-list-text="2."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">唯一索引<span class="s107">: </span>与普通索引类似，不同的就是：<span class="s107">MySQL </span>数据库索引列的值必须唯一，但允许有空值</p></li><li data-list-text="3."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">主键索引<span class="s107">: </span>它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引</p></li><li data-list-text="4."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">组合索引<span class="s107">: </span>为了进一步榨取 <span class="s107">MySQL </span>的效率，就要考虑建立组合索引。即将数据库表中的多个字段联合起来作为一个组合索引。</p></li></ol></li><li data-list-text="4."><p class="s104" style="padding-top: 10pt;padding-left: 35pt;text-indent: -12pt;text-align: left;">以及在 <span class="s106">mysql </span>数据库中索引的工作机制是什么？</p><p class="s19" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 <span class="s107">B </span>树及其变种 <span class="s107">B+</span>树</p></li><li data-list-text="5."><p class="s106" style="padding-top: 3pt;padding-left: 35pt;text-indent: -12pt;text-align: left;">MySQL <span class="s104">的基础操作命令</span>:</p><ol id="l80"><li data-list-text="1."><p class="s107" style="padding-top: 4pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">MySQL <span class="s19">是否处于运行状态</span>:Debian <span class="s19">上运行命令 </span>service mysql status<span class="s19">，在 </span>RedHat <span class="s19">上运行命令 </span>service mysqld status</p></li><li data-list-text="2."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">开启或停止 <span class="s107">MySQL </span>服务 <span class="s107">:</span>运行命令 <span class="s107">service mysqld start </span>开启服务；运行命令 <span class="s107">service mysqld stop </span>停止服务</p></li><li data-list-text="3."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">Shell <span class="s19">登入 </span>MySQL: <span class="s19">运行命令 </span>mysql -u root -p</p></li><li data-list-text="4."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;line-height: 15pt;text-align: left;">列出所有数据库<span class="s107">:</span>运行命令 <span class="s107">show databases;</span></p></li><li data-list-text="5."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: left;"><span class="s19">切换到某个数据库并在上面工作</span>:<span class="s19">运行命令 </span>use database<i>name; </i><span class="s2">进入名为 </span><i>database</i>name <span class="s19">的数据库</span></p></li><li data-list-text="6."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">列出某个数据库内所有表<span class="s107">: show tables;</span></p></li><li data-list-text="7."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">获取表内所有 <span class="s107">Field </span>对象的名称和类型 <span class="s107">:describe table_name;</span></p></li></ol></li><li data-list-text="6."><p class="s106" style="padding-top: 10pt;padding-left: 35pt;text-indent: -12pt;text-align: left;">mysql <span class="s104">的复制原理以及流程。</span></p><p class="s107" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Mysql <span class="s19">内建的复制功能是构建大型，高性能应用程序的基础。将 </span>Mysql <span class="s19">的数据分布到多个系统上去，这种分布的机制，是通过将 </span>Mysql <span class="s19">的某一台主机的数据复制到其它主机（</span>slaves<span class="s19">）上，并重新执行一遍来实现的。 </span>* <span class="s19">复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。 当一个从服务器连接主服务器时，它通知主服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。 过程如下 </span>1. <span class="s19">主服务器把更新记录到二进制日志文件中。 </span>2. <span class="s19">从服务器把主服务器的二进制日志拷贝到自己的中继日志（</span>replay log<span class="s19">）中。 </span>3. <span class="s19">从服务器重做中继日志中的时间，把更新应用到自己的数据库上。</span></p></li><li data-list-text="7."><p class="s106" style="padding-top: 4pt;padding-left: 35pt;text-indent: -12pt;text-align: left;">mysql <span class="s104">支持的复制类型</span>?</p><ol id="l81"><li data-list-text="1."><p class="s19" style="padding-top: 11pt;padding-left: 59pt;text-indent: -18pt;text-align: justify;">基于语句的复制： 在主服务器上执行的 <span class="s107">SQL </span>语句，在从服务器上执行同样的语句。<span class="s107">MySQL </span>默认采用基于语句的复制，效率比较高。 一旦发现没法精确复制时，会自动选着基于行的复制。</p></li><li data-list-text="2."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: justify;">基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍<span class="s107">. </span>从 <span class="s107">mysql5.0 </span>开始支持</p></li><li data-list-text="3."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: justify;">混合类型的复制<span class="s107">: </span>默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</p></li></ol></li><li data-list-text="8."><p class="s106" style="padding-top: 10pt;padding-left: 35pt;text-indent: -12pt;text-align: left;">mysql <span class="s104">中 </span>myisam <span class="s104">与 </span>innodb <span class="s104">的区别？</span></p><ol id="l82"><li data-list-text="1."><p class="s107" style="padding-top: 11pt;padding-left: 59pt;text-indent: -18pt;text-align: left;"><span class="s19">事务支持 </span>&gt; <i>MyISAM</i><span class="s2">：强调的是性能，每次查询具有原子性</span><i>,</i><span class="s2">其执行数度比 </span><i>InnoDB </i><span class="s2">类型更快，但是不提供事务支持。 </span><i>&gt; </i>InnoDB<span class="s19">：提供事务支持事务，外部键等高级数据库功能。 具有事务</span>(commit)<span class="s19">、回滚 </span>(rollback)<span class="s19">和崩溃修复能力</span>(crash recovery capabilities)<span class="s19">的事务安全 </span>(transaction-safe (ACID compliant))<span class="s19">型表。</span></p></li><li data-list-text="2."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">InnoDB <span class="s19">支持行级锁，而 </span>MyISAM <span class="s19">支持表级锁</span>. &gt;&gt; <span class="s19">用户在操作 </span>myisam <span class="s19">表时，</span>select<span class="s19">，</span>update<span class="s19">，</span>delete<span class="s19">，</span>insert <span class="s19">语句都会给表自动加锁，如果加锁以后的表满足 </span>insert <span class="s19">并发的情况下，可以在表的尾部插入新的数据。</span></p></li><li data-list-text="3."><p class="s107" style="padding-top: 4pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">InnoDB <span class="s19">支持 </span>MVCC, <span class="s19">而 </span>MyISAM <span class="s19">不支持</span></p></li><li data-list-text="4."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;line-height: 15pt;text-align: left;">InnoDB <span class="s19">支持外键，而 </span>MyISAM <span class="s19">不支持</span></p></li><li data-list-text="5."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: left;"><span class="s19">表主键 </span>&gt; <i>MyISAM</i><span class="s2">：允许没有任何索引和主键的表存在，索引都是保存行的地址。 </span><i>&gt; </i>InnoDB<span class="s19">：如果没有设定主键或者非空唯一索引，就会自动生成一个 </span>6 <span class="s19">字节的主键</span>(<span class="s19">用户不可见</span>)<span class="s19">，数据是主索引的一部分，附加索引保存的是主索引的值。</span></p></li><li data-list-text="6."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;line-height: 15pt;text-align: left;">InnoDB <span class="s19">不支持全文索引，而 </span>MyISAM <span class="s19">支持。</span></p></li><li data-list-text="7."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: left;"><span class="s19">可移植性、备份及恢复 </span>&gt; <i>MyISAM</i><span class="s2">：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。 </span><i>&gt; </i>InnoDB<span class="s19">：免费的方案可以是拷贝数据文件、备份 </span>binlog<span class="s19">，或者用 </span>mysqldump<span class="s19">，在数据量达到几十 </span>G <span class="s19">的时候就相对痛苦了</span></p></li><li data-list-text="8."><p class="s108" style="padding-left: 59pt;text-indent: -18pt;text-align: justify;"><span class="s19">存储结构 </span><span class="s107">&gt; </span>MyISAM<span class="s2">：每个 </span>MyISAM <span class="s2">在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。</span>.frm <span class="s2">文件存储表定义。数据文件的扩展名为</span>.MYD (MYData)<span class="s2">。索引文件的扩展名</span></p><p class="s107" style="padding-left: 59pt;text-indent: 0pt;text-align: justify;"><span class="s2">是</span><i>.MYI (MYIndex)</i><span class="s2">。 </span><i>&gt; </i>InnoDB<span class="s19">：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），</span>InnoDB <span class="s19">表的大小只受限于操作系统文件的大小，一般为 </span>2GB<span class="s19">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="9."><p class="s106" style="padding-left: 23pt;text-indent: 0pt;line-height: 71%;text-align: left;">mysql <span class="s104">中 </span>varchar <span class="s104">与 </span>char <span class="s104">的区别以及 </span>varchar(50)<span class="s104">中的 </span>50 <span class="s104">代表的涵义？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l83"><li data-list-text="1."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">varchar <span class="s19">与 </span>char <span class="s19">的区别</span>: char <span class="s19">是一种固定长度的类型，</span>varchar <span class="s19">则是一种可变长度的类型</span>.</p></li><li data-list-text="2."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">varchar(50)<span class="s19">中 </span>50 <span class="s19">的涵义 </span>: <span class="s19">最多存放 </span>50 <span class="s19">个字节</span></p></li><li data-list-text="3."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">int<span class="s19">（</span>20<span class="s19">）中 </span>20 <span class="s19">的涵义</span>: int(M)<span class="s19">中的 </span>M indicates the maximum display width (<span class="s19">最大显示宽度</span>)for integer types. The maximum legal display width is 255.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="10."><p class="s106" style="padding-left: 23pt;text-indent: 0pt;line-height: 71%;text-align: left;">MySQL <span class="s104">中 </span>InnoDB <span class="s104">支持的四种事务隔离级别名称，以及逐级之间的区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l84"><li data-list-text="1."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: justify;">Read Uncommitted<span class="s19">（读取未提交内容） </span>&gt;&gt; <span class="s19">在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（</span>Dirty Read<span class="s19">）。</span></p></li><li data-list-text="2."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: justify;">Read Committed<span class="s19">（读取提交内容） </span>&gt;&gt; <span class="s19">这是大多数数据库系统的默认隔离级别（但不是 </span>MySQL <span class="s19">默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（</span>Nonrepeatable Read<span class="s19">），因为同一事务的其他实例在该实例处理其间可能会有新的 </span>commit<span class="s19">，所以同一 </span>select <span class="s19">可能返回不同结果。</span></p></li><li data-list-text="3."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">Repeatable Read<span class="s19">（可重读） </span>&gt;&gt; <span class="s19">这是 </span>MySQL <span class="s19">的默认事务隔离级 别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（</span>Phantom</p><p class="s107" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">Read<span class="s19">）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的</span>“<span class="s19">幻影</span>” <span class="s19">行。</span>InnoDB <span class="s19">和 </span>Falcon <span class="s19">存储引擎通过多版本并发控制</span></p><p class="s19" style="padding-left: 59pt;text-indent: 0pt;text-align: justify;">（<span class="s107">MVCC</span>，<span class="s107">Multiversion Concurrency Control </span>间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。</p></li><li data-list-text="4."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">Serializable<span class="s19">（可串行化） </span>&gt;&gt; <span class="s19">这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 </span>&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th align=&quot;left&quot;&gt;<span class="s19">隔离级别</span>&lt;/th&gt;</p><p class="s107" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">&lt;th align=&quot;left&quot;&gt;<span class="s19">脏读（</span>Dirty Read<span class="s19">）</span>&lt;/th&gt; &lt;th align=&quot;left&quot;&gt;<span class="s19">不可重复读（</span>NonRepeatable Read<span class="s19">）</span>&lt;/th&gt; &lt;th align=&quot;left&quot;&gt;<span class="s19">幻读</span></p><p class="s19" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">（<span class="s107">Phantom Read</span>）<span class="s107">&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;tr&gt; &lt;td align=&quot;left&quot;&gt;</span>未提交读（<span class="s107">Read uncommitted</span>）<span class="s107">&lt;/td&gt; &lt;td align=&quot;left&quot;&gt;</span>可能<span class="s107">&lt;/td&gt; &lt;td align=&quot;left&quot;&gt;</span>可能<span class="s107">&lt;/td&gt; &lt;td align=&quot;left&quot;&gt;</span>可能<span class="s107">&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;left&quot;&gt;</span>已提交读</p><p class="s19" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">（<span class="s107">Read committed</span>）<span class="s107">&lt;/td&gt; &lt;td align=&quot;left&quot;&gt;</span>不可能<span class="s107">&lt;/td&gt; &lt;td align=&quot;left&quot;&gt;</span>可能<span class="s107">&lt;/td&gt; &lt;td align=&quot;left&quot;&gt;</span>可能<span class="s107">&lt;/td&gt; &lt;/tr&gt;</span></p><p class="s107" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">&lt;tr&gt; &lt;td align=&quot;left&quot;&gt;<span class="s19">可重复读（</span>Repeatable read<span class="s19">）</span>&lt;/td&gt; &lt;td align=&quot;left&quot;&gt;<span class="s19">不可能</span>&lt;/td&gt; &lt;td align=&quot;left&quot;&gt;<span class="s19">不可能</span>&lt;/td&gt; &lt;td align=&quot;left&quot;&gt;<span class="s19">可能</span>&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;left&quot;&gt;<span class="s19">可串行化</span></p><p class="s19" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">（<span class="s107">SERIALIZABLE</span>）<span class="s107">&lt;/td&gt; &lt;td align=&quot;left&quot;&gt;</span>不可能<span class="s107">&lt;/td&gt; &lt;td align=&quot;left&quot;&gt;</span>不可能<span class="s107">&lt;/td&gt; &lt;td align=&quot;left&quot;&gt;</span>不可能<span class="s107">&lt;/td&gt; &lt;/tr&gt;</span></p><p class="s107" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">&lt;/tbody&gt;&lt;/table&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="11."><p class="s104" style="padding-left: 23pt;text-indent: 0pt;line-height: 71%;text-align: left;">表中有大字段 <span class="s106">X</span>（例如：<span class="s106">text </span>类型），且字段 <span class="s106">X </span>不会经常更新，以读为为主，将该字段拆成子表好处是什么？</p><p class="s19" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">如果字段里面有大字段（<span class="s107">text,blob)</span>类型的，而且这些字段的访问并不多，这时候放在一起就变成缺点了。 <span class="s107">MYSQL </span>数据库的记录存储是按行存储的，数据块大小又是固定的（<span class="s107">16K</span>），每条记录越小，相同的块存储的记录就越多。此时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率。当需要查询大字段时，此时的关联查询是不可避免的，但也是值得的。拆分开后，对字段的 <span class="s107">UPDAE </span>就要 <span class="s107">UPDATE </span>多个表了</p></li><li data-list-text="12."><p class="s106" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 71%;text-align: left;">MySQL <span class="s104">中 </span>InnoDB <span class="s104">引擎的行锁是通过加在什么上完成（或称实现）的？</span></p><p class="s107" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">InnoDB <span class="s19">行锁是通过给索引上的索引项加锁来实现的，这一点 </span>MySQL <span class="s19">与 </span>Oracle <span class="s19">不同，后者是通过在数据块中对相应数据行加锁来实现的。</span>InnoDB <span class="s19">这种行锁实现特点意味着：只有通过索引条件检索数据，</span>InnoDB <span class="s19">才使用行级 锁，否则，</span>InnoDB <span class="s19">将使用表锁！</span></p></li><li data-list-text="13."><p class="s106" style="padding-top: 3pt;padding-left: 44pt;text-indent: -21pt;text-align: left;">MySQL <span class="s104">中控制内存分配的全局参数，有哪些？</span></p><ol id="l85"><li data-list-text="1."><p class="s107" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">Key<i>buffer</i>size<span class="s19">： </span>&gt; * key<i>buffer</i>size <span class="s19">指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值</span></p><p class="s107" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">Key<i>read</i>requests <span class="s19">和 </span>Key<i>reads</i><span class="s2">，可以知道 </span><i>key</i>buffer<i>size </i><span class="s2">设置是否合理。比例 </span><i>key</i>reads /key<i>read</i>requests <span class="s19">应该尽可能的低，至少是 </span>1:100<span class="s19">，</span>1:1000 <span class="s19">更好（上述状态值可以使用 </span>SHOW STATUS LIKE ‘key<i>read%&#39;</i><span class="s2">获得）。 </span><i>&gt; * key</i>buffer<i>size </i><span class="s2">只对 </span><i>MyISAM </i><span class="s2">表起作用。即使你不使用 </span><i>MyISAM </i><span class="s2">表，但是内部的临时磁盘表是 </span><i>MyISAM </i><span class="s2">表，也要使用该值。可以使用检查状态值 </span><i>created</i>tmp<i>disk</i>tables <span class="s19">得知详情。对于 </span>1G <span class="s19">内存的机器，如果不使用 </span>MyISAM <span class="s19">表，推荐值是 </span>16M<span class="s19">（</span>8- 64M<span class="s19">） </span>&gt; * key<i>buffer</i>size <span class="s19">设置注意事项 </span>&gt;&gt;&gt;1. <span class="s19">单个 </span>key<i>buffer </i><span class="s2">的大小不能超过 </span><i>4G</i><span class="s2">，如果设置超过 </span><i>4G</i><span class="s2">，就有可能遇到下面 </span><i>3 </i><span class="s2">个</span></p><p class="s108" style="padding-left: 59pt;text-indent: 0pt;text-align: left;"><a href="http://bugs.mysql.com/bug.php?id=29446" class="s109" target="_blank">bug: &gt;&gt;&gt;&gt;&gt; </a>http://bugs.mysql.com/bug.php?id=29446 &lt;br</p><p class="s108" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;"><a href="http://bugs.mysql.com/bug.php?id=29419" class="s109" target="_blank">/&gt; &gt;&gt;&gt;&gt;&gt; </a>http://bugs.mysql.com/bug.php?id=29419 &lt;br</p><p class="s108" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;"><a href="http://bugs.mysql.com/bug.php?id=5731" class="s109" target="_blank">/&gt; &gt;&gt;&gt;&gt;&gt; </a>http://bugs.mysql.com/bug.php?id=5731 &lt;br</p><p class="s107" style="padding-left: 59pt;text-indent: 0pt;text-align: left;"><i>/&gt; &gt;&gt;&gt;2. </i><span class="s2">建议 </span><i>key</i>buffer <span class="s19">设置为物理内存的 </span>1/4(<span class="s19">针对 </span>MyISAM <span class="s19">引擎</span>)<span class="s19">，甚至是物理内存的 </span>30%~40%<span class="s19">，如果 </span>key<i>buffer</i>size <span class="s19">设置太大，系统就会频繁的换页，降低系统性能。因为 </span>MySQL <span class="s19">使用操作系统的缓存来缓存数据，所以我们得为系统留够足够的内存；在很多情况下数据要比索引大得多。 </span>&gt;&gt;&gt;3. <span class="s19">如果机器性能优越，可以设置多个 </span>key<i>buffer,</i><span class="s2">分别让不同的 </span><i>key</i>buffer <span class="s19">来缓存专门的索引</span></p></li><li data-list-text="2."><p class="s107" style="padding-top: 7pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">innodb<i>buffer</i>pool_size &gt; <span class="s2">表示缓冲池字节大小，</span><i>InnoDB </i><span class="s2">缓存表和索引数据的内存区域。</span><i>mysql </i><span class="s2">默认的值是 </span><i>128M</i><span class="s2">。最大值与你的 </span><i>CPU </i><span class="s2">体系结构有关，在 </span><i>32 </i><span class="s2">位操作系统，最大值是 </span><i>4294967295 (2^32-1) </i><span class="s2">，在 </span><i>64 </i><span class="s2">位操作系统，最大值为 </span><i>18446744073709551615 (2^64-1)</i><span class="s2">。 </span><i>&gt; </i><span class="s19">在 </span>32 <span class="s19">位操作系统中， </span>CPU <span class="s19">和操作系统实用的最大大小低于设置的最大值。如果设定的缓冲池的大小大于 </span>1G<span class="s19">，设置 </span>innodb<i>buffer</i>pool<i>instances </i><span class="s2">的值大于 </span><i>1. &gt; *</i><span class="s2">数据读写在内存中非常快</span><i>, innodb</i>buffer<i>pool</i>size <span class="s19">减少了对磁盘的读写。 当数据提交或满足检查点条件后才一次性将内存数据刷新到磁盘中。然而内存还有操作系统或数据库其他进程使用</span>, <span class="s19">一般设置 </span>buffer pool <span class="s19">大小为总内存的 </span>3/4 <span class="s19">至 </span>4/5<span class="s19">。 若设置不当</span>, <span class="s19">内存使用可能浪费或者使用过多。 对于繁忙的服务器</span>, buffer pool <span class="s19">将划分为多个实例以提高系统并发性</span>, <span class="s19">减少线程间读写缓存的争用。</span>buffer pool <span class="s19">的大小首先受 </span>innodb<i>buffer</i>pool_instances <span class="s19">影响</span>, <span class="s19">当然影响较小。</span></p></li><li data-list-text="3."><p class="s108" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;"><span class="s107">query</span>cache<span class="s107">size &gt; </span><span class="s2">当 </span>mysql <span class="s2">接收到一条 </span>select <span class="s2">类型的 </span>query <span class="s2">时，</span>mysql <span class="s2">会对这条 </span>query <span class="s2">进行 </span>hash <span class="s2">计算而得到一个 </span>hash <span class="s2">值，然后通过该 </span>hash <span class="s2">值到 </span>query cache <span class="s2">中去匹配，如果没有匹配中，则将这个 </span>hash <span class="s2">值存放在一个 </span>hash <span class="s2">链表中，同时将 </span>query <span class="s2">的结果集存放进 </span>cache <span class="s2">中，存放 </span>hash <span class="s2">值的链表的每一个 </span>hash <span class="s2">节点存放了相应 </span>query<span class="s2">结果集在 </span>cache <span class="s2">中的地址，以及该 </span>query <span class="s2">所涉及到的一些 </span>table <span class="s2">的相关信息；如果通过 </span>hash <span class="s2">值匹配到了一样的 </span>query<span class="s2">，则直接将 </span>cache <span class="s2">中相应的 </span>query <span class="s2">结果集返回给客户端。如果 </span>mysql <span class="s2">任何一个表中的任何一条数据发生了变化，便会通知 </span>query cache <span class="s2">需要与该 </span>table <span class="s2">相关的 </span>query <span class="s2">的 </span>cache <span class="s2">全部失效，并释放占用的内存地址。 </span>&gt; <span class="s107">query cache</span><span class="s19">优缺点 </span><span class="s107">&gt;&gt; 1. query </span><span class="s19">语句的 </span><span class="s107">hash </span><span class="s19">计算和 </span><span class="s107">hash </span><span class="s19">查找带来的资源消</span></p><p class="s19" style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">耗。<span class="s107">mysql </span>会对每条接收到的 <span class="s107">select </span>类型的 <span class="s107">query </span>进行 <span class="s107">hash </span>计算然后查找该 <span class="s107">query </span>的 <span class="s107">cache </span>是否存在，虽然 <span class="s107">hash </span>计算和查找的效率已经足够高了，一条 <span class="s107">query </span>所带来的消耗可以忽略，但一旦涉及到高并发，有成千上万条 <span class="s107">query </span>时，<span class="s107">hash </span>计算和查找所带来的开销就的重视了； <span class="s107">&gt;&gt; 2. query cache </span>的失效问题。如果表变更比较频繁，则会造成 <span class="s107">query cache </span>的失效率非常高。表变更不仅仅指表中的数据发生变化，还包括结构或者索引的任何变化； <span class="s107">&gt;&gt; 3. </span>对于不同 <span class="s107">sql </span>但同一结果集的 <span class="s107">query </span>都会被缓存，这样便会造成内存资源的过渡消耗。<span class="s107">sql </span>的字符大小写、空格或者注释的不同，缓存都是认为是不同的 <span class="s107">sql</span>（因为他们的 <span class="s107">hash </span>值会不同）； <span class="s107">&gt;&gt; 4. </span>相关参数设置不合理会造成大量内存碎片，相关的参数设置会稍后介绍。</p></li><li data-list-text="4."><p class="s107" style="padding-top: 7pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">read<i>buffer</i>size &gt;<span class="s19">是 </span>MySQL <span class="s19">读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，</span>MySQL <span class="s19">会为它分配一段内存缓冲区。 </span>read<i>buffer</i>size <span class="s19">变量控制这一缓冲区的大小。如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能。</span></p></li></ol></li><li data-list-text="14."><p class="s104" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 71%;text-align: justify;">若一张表中只有一个字段 <span class="s106">VARCHAR(N)</span>类型，<span class="s106">utf8 </span>编码，则 <span class="s106">N </span>最大值为多少<span class="s106">(</span>精确到数量级即可<span class="s106">)?</span></p><p class="s19" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">由于 <span class="s107">utf8 </span>的每个字符最多占用 <span class="s107">3 </span>个字节。而 <span class="s107">MySQL </span>定义行的长度不能超过 <span class="s107">65535</span>，因此 <span class="s107">N </span>的最大值计算方法为：<span class="s107">(65535-1-2)/3</span>。减去 <span class="s107">1 </span>的原因是实际存储从第二个字节开始，减去 <span class="s107">2 </span>的原因是因为要在列表长度存储实际的字符长度，除以 <span class="s107">3 </span>是因为 <span class="s107">utf8 </span>限制：每个字符最多占用 <span class="s107">3 </span>个字节。</p></li><li data-list-text="15."><p class="s106" style="padding-top: 3pt;padding-left: 48pt;text-indent: -25pt;text-align: left;">[SELECT *] <span class="s104">和</span>[SELECT <span class="s104">全部字段</span>]<span class="s104">的 </span>2 <span class="s104">种写法有何优缺点</span>?</p><ol id="l86"><li data-list-text="1."><p class="s19" style="padding-top: 11pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">前者要解析数据字典，后者不需要</p></li><li data-list-text="2."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序。</p></li><li data-list-text="3."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">表字段改名，前者不需要修改，后者需要改</p></li><li data-list-text="4."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">后者可以建立索引进行优化，前者无法优化</p></li><li data-list-text="5."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">后者的可读性比前者要高</p></li></ol></li><li data-list-text="16."><p class="s106" style="padding-top: 10pt;padding-left: 44pt;text-indent: -21pt;text-align: left;">HAVNG <span class="s104">子句 和 </span>WHERE <span class="s104">的异同点</span>?</p><ol id="l87"><li data-list-text="1."><p class="s19" style="padding-top: 11pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">语法上：<span class="s107">where </span>用表中列名，<span class="s107">having </span>用 <span class="s107">select </span>结果别名</p></li><li data-list-text="2."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">影响结果范围：<span class="s107">where </span>从表读出数据的行数，<span class="s107">having </span>返回客户端的行数</p></li><li data-list-text="3."><p class="s19" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">索引：<span class="s107">where </span>可以使用索引，<span class="s107">having </span>不能使用索引，只能在临时结果集操作</p></li><li data-list-text="4."><p class="s107" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">where <span class="s19">后面不能使用聚集函数，</span>having <span class="s19">是专门使用聚集函数的。</span></p></li></ol></li><li data-list-text="17."><p class="s106" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;line-height: 114%;text-align: left;">MySQL <span class="s104">当记录不存在时 </span>insert,<span class="s104">当记录存在时 </span>update<span class="s104">，语句怎么写？ </span><span class="s107">INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1;</span></p></li><li data-list-text="18."><p class="s106" style="padding-left: 44pt;text-indent: -21pt;text-align: left;">MySQL <span class="s104">的 </span>insert <span class="s104">和 </span>update <span class="s104">的 </span>select <span class="s104">语句语法</span></p></li></ol></li></ol><p class="s107" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 107%;text-align: left;">`SQL insert into student (stuid,stuname,deptid) select 10,&#39;xzm&#39;,3 from student where stuid &gt; 8;</p><p class="s107" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 107%;text-align: left;">update student a inner join student b on b.stuID=10 set a.stuname=concat(b.stuname, b.stuID) where a.stuID=10 ; `</p><ol id="l88"><li data-list-text="1."><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">BIO<span class="p">、</span>NIO <span class="p">和 </span>AIO <span class="p">的区别？ </span>BIO<span class="p">：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">伪异步 <span class="s84">IO</span>：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。    <span class="s84">NIO</span>：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <span class="s84">I/O </span>请求时才启动一个线程进行处理。           <span class="s84">AIO</span>：一个有效请求一个线程，客户端的 <span class="s84">I/O </span>请求都是由 <span class="s84">OS </span>先完成了再通知服务器应用去启动线程进行处理，</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">BIO <span class="p">是面向流的，</span>NIO <span class="p">是面向缓冲区的；</span>BIO <span class="p">的各种流是阻塞的。而 </span>NIO <span class="p">是非阻塞的；</span>BIO</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">的 <span class="s84">Stream </span>是单向的，而 <span class="s84">NIO </span>的 <span class="s84">channel </span>是双向的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">NIO <span class="p">的特点：事件驱动模型、单线程处理多任务、非阻塞 </span>I/O<span class="p">，</span>I/O <span class="p">读写不再阻塞，而是返回 </span>0<span class="p">、基于 </span>block <span class="p">的传输比基于流的传输更高效、更高级的 </span>IO <span class="p">函数 </span>zero-copy<span class="p">、</span>IO <span class="p">多路复用大大提高了 </span>Java <span class="p">网络应用的可伸缩性和实用性。基于 </span>Reactor <span class="p">线程模型。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">在 <span class="s84">Reactor </span>模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操 作。如在 <span class="s84">Reactor </span>中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事 件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s84" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">NIO <span class="p">的组成？</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Buffer<span class="p">：与 </span>Channel <span class="p">进行交互，数据是从 </span>Channel <span class="p">读入缓冲区，从缓冲区写入 </span>Channel <span class="p">中的</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">flip <span class="p">方法 ： 反转此缓冲区，将 </span>position <span class="p">给 </span>limit<span class="p">，然后将 </span>position <span class="p">置为 </span>0<span class="p">，其实就是切换读写模式</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">clear <span class="p">方法 ：清除此缓冲区，将 </span>position <span class="p">置为 </span>0<span class="p">，把 </span>capacity <span class="p">的值给 </span>limit<span class="p">。 </span>rewind <span class="p">方法 ： 重绕此缓冲区，将 </span>position <span class="p">置为 </span>0</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">DirectByteBuffer <span class="p">可减少一次系统空间到用户空间的拷贝。但 </span>Buffer <span class="p">创建和销毁的成本更 高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机 </span>I/O <span class="p">操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用 </span>heapBuffer<span class="p">，由 </span>JVM <span class="p">进行管理。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Channel<span class="p">：表示 </span>IO <span class="p">源与目标打开的连接，是双向的，但不能直接访问数据，只能与 </span>Buffer</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">进行交互。通过源码可知，<span class="s84">FileChannel </span>的 <span class="s84">read </span>方法和 <span class="s84">write </span>方法都导致数据复制了两次！</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Selector <span class="p">可使一个单独的线程管理多个 </span>Channel<span class="p">，</span>open <span class="p">方法可创建 </span>Selector<span class="p">，</span>register <span class="p">方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、</span>accept<span class="p">。注册事件后会产生一个 </span>SelectionKey<span class="p">：它表示 </span>SelectableChannel  <span class="p">和 </span>Selector <span class="p">之间的注册关系，</span>wakeup <span class="p">方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的 </span>channel <span class="p">或者事件；</span>channel <span class="p">关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Selector <span class="p">在 </span>Linux <span class="p">的实现类是 </span>EPollSelectorImpl<span class="p">，委托给 </span>EPollArrayWrapper <span class="p">实现，其中三个</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">native <span class="p">方法是对 </span>epoll <span class="p">的封装，而 </span>EPollSelectorImpl.  implRegister <span class="p">方法，通过调用 </span>epoll_ctl<span class="p">向 </span>epoll <span class="p">实例中注册事件，还将注册的文件描述符</span>(fd)<span class="p">与 </span>SelectionKey <span class="p">的对应关系添加到 </span>fdToKey <span class="p">中，这个 </span>map <span class="p">维护了文件描述符与 </span>SelectionKey <span class="p">的映射。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">fdToKey <span class="p">有时会变得非常大，因为注册到 </span>Selector <span class="p">上的 </span>Channel <span class="p">非常多（百万连接）；过期或失效的 </span>Channel <span class="p">没有及时关闭。</span>fdToKey <span class="p">总是串行读取的，而读取是在 </span>select <span class="p">方法中进行的，该方法是非线程安全的。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Pipe<span class="p">：两个线程之间的单向数据连接，数据会被写到 </span>sink <span class="p">通道，从 </span>source <span class="p">通道读取</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">NIO <span class="p">的服务端建立过程：</span>Selector.open()<span class="p">：打开一个 </span>Selector<span class="p">；</span>ServerSocketChannel.open()<span class="p">：创建服务端的 </span>Channel<span class="p">；</span>bind()<span class="p">：绑定到某个端口上。并配置非阻塞模式；</span>register()<span class="p">：注册 </span>Channel <span class="p">和关注的事件到 </span>Selector <span class="p">上；</span>select()<span class="p">轮询拿到已经就绪的事件</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s84" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">Netty <span class="p">的特点？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">一个高性能、异步事件驱动的 <span class="s84">NIO </span>框架，它提供了对 <span class="s84">TCP</span>、<span class="s84">UDP </span>和文件传输的支持</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">使用更高效的 <span class="s84">socket </span>底层，对 <span class="s84">epoll </span>空轮询引起的 <span class="s84">cpu </span>占用飙升在内部进行了处理，避免了直接使用 <span class="s84">NIO </span>的陷阱，简化了 <span class="s84">NIO </span>的处理方式。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">采用多种 <span class="s84">decoder/encoder </span>支持，对 <span class="s84">TCP </span>粘包<span class="s84">/</span>分包进行自动化处理</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">可使用接受<span class="s84">/</span>处理线程池，提高连接效率，对重连、心跳检测的简单支持</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">可配置 <span class="s84">IO </span>线程数、<span class="s84">TCP </span>参数， <span class="s84">TCP </span>接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用 <span class="s84">ByteBuf</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">通过引用计数器及时申请释放不再引用的对象，降低了 <span class="s84">GC </span>频率使用单线程串行化的方式，高效的 <span class="s84">Reactor </span>线程模型</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">大量使用了 <span class="s84">volitale</span>、使用了 <span class="s84">CAS </span>和原子类、线程安全类的使用、读写锁的使用</p></li><li data-list-text="4."><p class="s84" style="padding-top: 2pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">Netty <span class="p">的线程模型？</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Netty <span class="p">通过 </span>Reactor <span class="p">模型基于多路复用器接收并处理用户请求，内部实现了两个线程池， </span>boss <span class="p">线程池和 </span>work <span class="p">线程池，其中 </span>boss <span class="p">线程池的线程负责处理请求的 </span>accept <span class="p">事件，当接收到 </span>accept <span class="p">事件的请求时，把对应的 </span>socket <span class="p">封装到一个 </span>NioSocketChannel <span class="p">中，并交给 </span>work<span class="p">线程池，其中 </span>work <span class="p">线程池负责请求的 </span>read <span class="p">和 </span>write <span class="p">事件，由对应的 </span>Handler <span class="p">处理。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">单线程模型：所有 <span class="s84">I/O </span>操作都由一个线程完成，即多路复用、事件分发和处理都是在一个 <span class="s84">Reactor </span>线程上完成的。既要接收客户端的连接请求<span class="s84">,</span>向服务端发起连接，又要发送<span class="s84">/</span>读取请求或应答<span class="s84">/</span>响应消息。一个 <span class="s84">NIO </span>线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">多线程模型：有一个 <span class="s84">NIO </span>线程（<span class="s84">Acceptor</span>） 只负责监听服务端，接收客户端的 <span class="s84">TCP </span>连接请求；<span class="s84">NIO </span>线程池负责网络 <span class="s84">IO </span>的操作，即消息的读取、解码、编码和发送；<span class="s84">1 </span>个 <span class="s84">NIO </span>线程可以同时处理 <span class="s84">N </span>条链路，但是 <span class="s84">1 </span>个链路只对应 <span class="s84">1 </span>个 <span class="s84">NIO </span>线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个 <span class="s84">Acceptor </span>线程可能会存在性能不足问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">主从多线程模型：<span class="s84">Acceptor </span>线程用于绑定监听端口，接收客户端连接，将 <span class="s84">SocketChannel</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">从主线程池的 <span class="s84">Reactor </span>线程的多路复用器上移除，重新注册到 <span class="s84">Sub </span>线程池的线程上，用于</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">处理 <span class="s84">I/O </span>的读写等操作，从而保证 <span class="s84">mainReactor </span>只负责接入认证、握手等操作；</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5."><p class="s84" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">TCP <span class="p">粘包</span>/<span class="p">拆包的原因及解决方法？</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">TCP <span class="p">是以流的方式来处理数据，一个完整的包可能会被 </span>TCP <span class="p">拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">TCP <span class="p">粘包</span>/<span class="p">分包的原因：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">进行 <span class="s84">MSS </span>大小的 <span class="s84">TCP </span>分段，当 <span class="s84">TCP </span>报文长度<span class="s84">-TCP </span>头部长度<span class="s84">&gt;MSS </span>的时候将发生拆包以太网帧的 <span class="s84">payload</span>（净荷）大于 <span class="s84">MTU</span>（<span class="s84">1500 </span>字节）进行 <span class="s84">ip </span>分片。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">解决方法</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">消息定长：<span class="s84">FixedLengthFrameDecoder </span>类</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">包尾增加特殊字符分割：行分隔符类：<span class="s84">LineBasedFrameDecoder </span>或自定义分隔符类  ：</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">DelimiterBasedFrameDecoder</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">将消息分为消息头和消息体：<span class="s84">LengthFieldBasedFrameDecoder </span>类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</p></li><li data-list-text="6."><p style="padding-left: 31pt;text-indent: -8pt;line-height: 13pt;text-align: left;">了解哪几种序列化协议？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">序列化（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">（<span class="s84">CPU </span>资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Java <span class="p">默认提供的序列化：无法跨语言、序列化后的码流太大、序列化的性能差</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">XML<span class="p">，优点：人机可读性好，可指定元素或特性的名称。缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。适用场景：当做配置文件存储数据，实时数据转换。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">JSON<span class="p">，是一种轻量级的数据交换格式，优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与 </span>XML <span class="p">相比，其协议比较简单，解析速度比较快。缺点：数据的描述性比 </span>XML <span class="p">差、不适合性能要求为 </span>ms <span class="p">级别的情况、额外空间开销比较大。适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于 </span>Web browser <span class="p">的 </span>Ajax <span class="p">请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Fastjson<span class="p">，采用一种“假定有序快速匹配”的算法。优点：接口简单易用、目前 </span>java <span class="p">语言中最快的 </span>json <span class="p">库。缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全。适用场景：协议交互、</span>Web <span class="p">输出、</span>Android <span class="p">客户端</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Thrift<span class="p">，不仅是序列化协议，还是一个 </span>RPC <span class="p">框架。优点：序列化后的体积小</span>, <span class="p">速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">难、不能与其他传输层协议共同使用（例如 <span class="s84">HTTP</span>）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。适用场景：分布式系统的 <span class="s84">RPC </span>解决方案</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Avro<span class="p">，</span>Hadoop <span class="p">的一个子项目，解决了 </span>JSON <span class="p">的冗长和没有 </span>IDL <span class="p">的问题。优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用 </span>RPC<span class="p">、支持跨编程语言实现。缺点：对于习惯于静态类型语言的用户不直观。适用场景：在 </span>Hadoop <span class="p">中做 </span>Hive<span class="p">、</span>Pig <span class="p">和 </span>MapReduce<span class="p">的持久化数据格式。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Protobuf<span class="p">，将数据结构以</span>.proto <span class="p">文件进行描述，通过代码生成工具可以生成对应数据结构的 </span>POJO <span class="p">对象和 </span>Protobuf <span class="p">相关的方法和属性。优点：序列化后码流小，性能高、结构化数据存储格式（</span>XML JSON <span class="p">等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持 </span>Java <span class="p">、</span>C++ <span class="p">、</span>python<span class="p">。适用场景：对性能要求高的 </span>RPC <span class="p">调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">其它</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">protostuff <span class="p">基于 </span>protobuf <span class="p">协议，但不需要配置 </span>proto <span class="p">文件，直接导包即可 </span>Jboss marshaling <span class="p">可以直接序列化 </span>java <span class="p">类， 无须实 </span>java.io.Serializable <span class="p">接口 </span>Message pack <span class="p">一个高效的二进制序列化格式</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Hessian <span class="p">采用二进制协议的轻量级 </span>remoting onhttp <span class="p">工具</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">kryo <span class="p">基于 </span>protobuf <span class="p">协议，只支持 </span>java <span class="p">语言</span>,<span class="p">需要注册（</span>Registration<span class="p">），然后序列化</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">（<span class="s84">Output</span>），反序列化（<span class="s84">Input</span>）</p></li><li data-list-text="7."><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">如何选择序列化协议？具体场景</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">对于公司间的系统调用，如果性能要求在 <span class="s84">100ms </span>以上的服务，基于 <span class="s84">XML </span>的 <span class="s84">SOAP </span>协议是一个值得考虑的方案。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">基于 <span class="s84">Web browser </span>的 <span class="s84">Ajax</span>，以及 <span class="s84">Mobile app </span>与服务端之间的通讯，<span class="s84">JSON </span>协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，<span class="s84">JSON</span>也是非常不错的选择。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">对于调试环境比较恶劣的场景，采用 <span class="s84">JSON </span>或 <span class="s84">XML </span>能够极大的提高调试效率，降低系统开发成本。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">当对性能和简洁性有极高要求的场景，<span class="s84">Protobuf</span>，<span class="s84">Thrift</span>，<span class="s84">Avro </span>之间具有一定的竞争关系。对于 <span class="s84">T </span>级别的数据的持久化应用场景，<span class="s84">Protobuf </span>和 <span class="s84">Avro </span>是首要选择。如果持久化后的数据存储在 <span class="s84">hadoop </span>子项目里，<span class="s84">Avro </span>会是更好的选择。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">对于持久层非 <span class="s84">Hadoop </span>项目，以静态类型语言为主的应用场景，<span class="s84">Protobuf </span>会更符合静态类型语言工程师的开发习惯。由于 <span class="s84">Avro </span>的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，<span class="s84">Avro </span>是更好的选择。</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">如果需要提供一个完整的 <span class="s84">RPC </span>解决方案，<span class="s84">Thrift </span>是一个好的选择。</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Protobuf <span class="p">可以优先考虑。</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">protobuf <span class="p">的数据类型有多种：</span>bool<span class="p">、</span>double<span class="p">、</span>float<span class="p">、</span>int32<span class="p">、</span>int64<span class="p">、</span>string<span class="p">、</span>bytes<span class="p">、</span>enum<span class="p">、 </span>message<span class="p">。</span>protobuf <span class="p">的限定符：</span>required: <span class="p">必须赋值，不能为空、</span>optional:<span class="p">字段可以赋值，也可以不赋值、</span>repeated: <span class="p">该字段可以重复任意次数（包括 </span>0 <span class="p">次）、枚举；只能用指定的常量集中的一个值作为其值；</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">protobuf <span class="p">的基本规则：每个消息中必须至少留有一个 </span>required <span class="p">类型的字段、包含 </span>0 <span class="p">个或多个 </span>optional <span class="p">类型的字段；</span>repeated <span class="p">表示的字段可以包含 </span>0 <span class="p">个或多个数据；</span>[1,15]<span class="p">之内的标识号在编码的时候会占用一个字节（常用），</span>[16,2047]<span class="p">之内的标识号则占用 </span>2 <span class="p">个字节，标识号一定不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替 组。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">protobuf <span class="p">的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的 </span>required <span class="p">字段，</span>optional <span class="p">和 </span>repeated <span class="p">类型的字段可以被移除，但要保留标号不能被重用。新添加的字段必须是 </span>optional <span class="p">或 </span>repeated<span class="p">。因为旧版本程序无法读取或写入新增的 </span>required <span class="p">限定符的字段。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">编译器为每一个消息类型生成了一个<span class="s84">.java </span>文件，以及一个特殊的 <span class="s84">Builder </span>类（该类是用来创建消息类接口的）。如：<span class="s84">UserProto.User.Builder           builder           = UserProto.User.newBuilder();builder.build()</span>；</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Netty <span class="p">中的使用：</span>ProtobufVarint32FrameDecoder <span class="p">是用于处理半包消息的解码类； </span>ProtobufDecoder(UserProto.User.getDefaultInstance())<span class="p">这是创建的 </span>UserProto.java <span class="p">文件中的解码类；</span>ProtobufVarint32LengthFieldPrepender  <span class="p">对 </span>protobuf <span class="p">协议的消息头上加上一个长度为 </span>32 <span class="p">的整形字段，用于标志这个消息的长度的类；</span>ProtobufEncoder <span class="p">是编码类</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">将 <span class="s84">StringBuilder </span>转换为 <span class="s84">ByteBuf </span>类型：<span class="s84">copiedBuffer()</span>方法</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="8."><p class="s84" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">Netty <span class="p">的零拷贝实现？</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Netty <span class="p">的接收和发送 </span>ByteBuffer <span class="p">采用 </span>DIRECT   BUFFERS<span class="p">，使用堆外直接内存进行 </span>Socket <span class="p">读写，不需要进行字节缓冲区的二次拷贝。堆内存多了一次内存拷贝，</span>JVM <span class="p">会将堆内存 </span>Buffer <span class="p">拷贝一份到直接内存中，然后才写入 </span>Socket <span class="p">中。</span>ByteBuffer <span class="p">由 </span>ChannelConfig <span class="p">分配，而 </span>ChannelConfig <span class="p">创建 </span>ByteBufAllocator <span class="p">默认使用 </span>Direct Buffer</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">CompositeByteBuf <span class="p">类可以将多个 </span>ByteBuf <span class="p">合并为一个逻辑上的 </span>ByteBuf, <span class="p">避免了传统通过内存拷贝的方式将几个小 </span>Buffer <span class="p">合并成一个大的 </span>Buffer<span class="p">。</span>addComponents <span class="p">方法将  </span>header<span class="p">与 </span>body <span class="p">合并为一个逻辑上的 </span>ByteBuf, <span class="p">这两个 </span>ByteBuf <span class="p">在 </span>CompositeByteBuf <span class="p">内部都是单独存在的</span>, CompositeByteBuf <span class="p">只是逻辑上是一个整体</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">通过 <span class="s84">FileRegion </span>包装的 <span class="s84">FileChannel.tranferTo </span>方法 实现文件传输<span class="s84">, </span>可以直接将文件缓冲区的数据发送到目标 <span class="s84">Channel</span>，避免了传统通过循环 <span class="s84">write </span>方式导致的内存拷贝问题。</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">通过 <span class="s84">wrap </span>方法<span class="s84">, </span>我们可以将 <span class="s84">byte[] </span>数组、<span class="s84">ByteBuf</span>、<span class="s84">ByteBuffer </span>等包装成一个 <span class="s84">Netty ByteBuf </span>对象<span class="s84">, </span>进而避免了拷贝操作。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Selector  BUG<span class="p">：若 </span>Selector <span class="p">的轮询结果为空，也没有 </span>wakeup <span class="p">或新消息处理，则发生空轮询，</span>CPU <span class="p">使用率 </span>100%<span class="p">，</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Netty <span class="p">的解决办法：对 </span>Selector <span class="p">的 </span>select <span class="p">操作周期进行统计，每完成一次空的 </span>select <span class="p">操作进行一次计数，若在某个周期内连续发生 </span>N <span class="p">次空轮询，则触发了 </span>epoll <span class="p">死循环 </span>bug<span class="p">。重建 </span>Selector<span class="p">，判断是否是其他线程发起的重建请求，若不是则将原 </span>SocketChannel <span class="p">从旧的 </span>Selector <span class="p">上去除注册，重新注册到新的 </span>Selector <span class="p">上，并将原来的 </span>Selector <span class="p">关闭。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="9."><p class="s84" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">Netty <span class="p">的高性能表现在哪些方面？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">心跳，对服务端：会定时清除闲置会话 <span class="s84">inactive(netty5)</span>，对客户端<span class="s84">:</span>用来检测会话是否断开，是否重来，检测网络延迟，其中 <span class="s84">idleStateHandler </span>类 用来检测会话状态</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">串行无锁化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎 <span class="s84">CPU </span>利用率不高，并发程度不够。但是，通过调整 <span class="s84">NIO </span>线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列<span class="s84">-</span>多个工作线程模型性能更优。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">可靠性，链路有效性检测：链路空闲检测机制，读<span class="s84">/</span>写空闲超时机制；内存保护机制：通过内存池重用 <span class="s84">ByteBuf;ByteBuf </span>的解码保护；优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Netty <span class="p">安全性：支持的安全协议：</span>SSL V2 <span class="p">和 </span>V3<span class="p">，</span>TLS<span class="p">，</span>SSL <span class="p">单向认证、双向认证和第三方 </span>CA</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">认证。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">高效并发编程的体现：<span class="s84">volatile </span>的大量、正确使用；<span class="s84">CAS </span>和原子类的广泛使用；线程安全容器的使用；通过读写锁提升并发性能。<span class="s84">IO </span>通信性能三原则：传输（<span class="s84">AIO</span>）、协议（<span class="s84">Http</span>）、线程（主从多线程）</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">流量整型的作用（变压器）：防止由于上下游网元性能不均衡导致下游网元被压垮，业务流中断；防止由于通信模块接受消息过快，后端业务线程处理不及时导致撑死问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">TCP <span class="p">参数配置：</span>SO_RCVBUF <span class="p">和 </span>SO_SNDBUF<span class="p">：通常建议值为 </span>128K <span class="p">或者 </span>256K<span class="p">； </span>SO_TCPNODELAY<span class="p">：</span>NAGLE <span class="p">算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="10."><p class="s84" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">NIOEventLoopGroup <span class="p">源码？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">NioEventLoopGroup(<span class="p">其实是 </span>MultithreadEventExecutorGroup) <span class="p">内部维护一个类型为</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">EventExecutor children [], <span class="p">默认大小是处理器核数 </span>* 2, <span class="p">这样就构成了一个线程池，初始化</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">EventExecutor <span class="p">时 </span>NioEventLoopGroup <span class="p">重载 </span>newChild <span class="p">方法，所以 </span>children <span class="p">元素的实际类型为 </span>NioEventLoop<span class="p">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">线程启动时调用 <span class="s84">SingleThreadEventExecutor </span>的构造方法，执行 <span class="s84">NioEventLoop </span>类的 <span class="s84">run </span>方法，首先会调用 <span class="s84">hasTasks()</span>方法判断当前 <span class="s84">taskQueue </span>是否有元素。如果 <span class="s84">taskQueue </span>中有元</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">素，执行 <span class="s84">selectNow() </span>方法，最终执行 <span class="s84">selector.selectNow()</span>，该方法会立即返回。如果 <span class="s84">taskQueue </span>没有元素，执行 <span class="s84">select(oldWakenUp) </span>方法</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">select ( oldWakenUp) <span class="p">方法解决了 </span>Nio <span class="p">中的 </span>bug<span class="p">，</span>selectCnt <span class="p">用来记录 </span>selector.select <span class="p">方法的执行次数和标识是否执行过 </span>selector.selectNow()<span class="p">，若触发了 </span>epoll <span class="p">的空轮询 </span>bug<span class="p">，则会反复执行 </span>selector.select(timeoutMillis)<span class="p">，变量 </span>selectCnt <span class="p">会逐渐变大，当 </span>selectCnt <span class="p">达到阈值（默认 </span>512<span class="p">），则执行 </span>rebuildSelector <span class="p">方法，进行 </span>selector <span class="p">重建，解决 </span>cpu <span class="p">占用 </span>100%<span class="p">的 </span>bug<span class="p">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">rebuildSelector <span class="p">方法先通过 </span>openSelector <span class="p">方法创建一个新的 </span>selector<span class="p">。然后将 </span>old selector <span class="p">的 </span>selectionKey <span class="p">执行 </span>cancel<span class="p">。最后将 </span>old    selector <span class="p">的 </span>channel <span class="p">重新注册到新的 </span>selector <span class="p">中。 </span>rebuild <span class="p">后，需要重新执行方法 </span>selectNow<span class="p">，检查是否有已 </span>ready <span class="p">的 </span>selectionKey<span class="p">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">接下来调用 <span class="s84">processSelectedKeys </span>方法（处理 <span class="s84">I/O </span>任务），当 <span class="s84">selectedKeys != null </span>时，调用 <span class="s84">processSelectedKeysOptimized </span>方法，迭代 <span class="s84">selectedKeys </span>获取就绪的 <span class="s84">IO </span>事件的 <span class="s84">selectkey </span>存放在数组 <span class="s84">selectedKeys </span>中<span class="s84">, </span>然后为每个事件都调用  <span class="s84">processSelectedKey </span>来处理它， <span class="s84">processSelectedKey </span>中分别处理 <span class="s84">OP_READ</span>；<span class="s84">OP_WRITE</span>；<span class="s84">OP_CONNECT </span>事件。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">最后调用 <span class="s84">runAllTasks </span>方法（非 <span class="s84">IO </span>任务），该方法首先会调用 <span class="s84">fetchFromScheduledTaskQueue</span>方法，把 <span class="s84">scheduledTaskQueue </span>中已经超过延迟执行时间的任务移到 <span class="s84">taskQueue </span>中等待被执行，然后依次从 <span class="s84">taskQueue </span>中取任务执行，每执行 <span class="s84">64 </span>个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非 <span class="s84">IO </span>任务，避免非 <span class="s84">IO </span>任务太多，影响 <span class="s84">IO </span>任务的执行。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">每个 <span class="s84">NioEventLoop </span>对应一个线程和一个 <span class="s84">Selector</span>，<span class="s84">NioServerSocketChannel </span>会主动注册到某一个 <span class="s84">NioEventLoop </span>的 <span class="s84">Selector </span>上，<span class="s84">NioEventLoop </span>负责事件轮询。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Outbound <span class="p">事件都是请求事件</span>, <span class="p">发起者是 </span>Channel<span class="p">，处理者是 </span>unsafe<span class="p">，通过 </span>Outbound <span class="p">事件进行通知，传播方向是 </span>tail <span class="p">到 </span>head<span class="p">。</span>Inbound <span class="p">事件发起者是 </span>unsafe<span class="p">，事件的处理者是 </span>Channel, <span class="p">是通知事件，传播方向是从头到尾。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">内存管理机制，首先会预申请一大块内存 <span class="s84">Arena</span>，<span class="s84">Arena </span>由许多 <span class="s84">Chunk </span>组成，而每个 <span class="s84">Chunk</span>默认由 <span class="s84">2048 </span>个 <span class="s84">page </span>组成。<span class="s84">Chunk </span>通过 <span class="s84">AVL </span>树的形式组织 <span class="s84">Page</span>，每个叶子节点表示一个 <span class="s84">Page</span>，而中间节点表示内存区域，节点自己记录它在整个 <span class="s84">Arena </span>中的偏移地址。当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。大于 <span class="s84">8k </span>的内存分配在 <span class="s84">poolChunkList </span>中，而 <span class="s84">PoolSubpage </span>用于分配小于 <span class="s84">8k </span>的内存，它会把一个 <span class="s84">page </span>分割成多段，进行内存分配。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">ByteBuf <span class="p">的特点：支持自动扩容（</span>4M<span class="p">），保证 </span>put <span class="p">方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（</span>zero-copy<span class="p">）；不需要调用 </span>flip()<span class="p">来切换读</span>/<span class="p">写模式，读取和写入索引分</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">开；方法链；引用计数基于 <span class="s84">AtomicIntegerFieldUpdater </span>用于内存回收；<span class="s84">PooledByteBuf </span>采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象。<span class="s84">UnpooledHeapByteBuf </span>每次都会新建一个缓冲区对象。</p><p class="s104" style="padding-left: 23pt;text-indent: 0pt;line-height: 20pt;text-align: left;">1、请解释一下什么是 Nginx?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Nginx 是一个 web 服务器和反向代理服务器，用于 HTTP、HTTPS、SMTP、POP3</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">和 IMAP 协议。</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2、请列举 Nginx 的一些特性。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;line-height: 193%;text-align: left;">Nginx 服务器的特性包括：反向代理/L7 负载均衡器 嵌入式 Perl 解释器</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">动态二进制升级</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">可用于重新编写 URL，具有非常好的 PCRE 支持</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">3、请列举 Nginx 和 Apache 之间的不同点</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s104" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">4、请解释 Nginx 如何处理 HTTP 请求。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">Nginx 使用反应器模式。主事件循环等待操作系统发出准备事件的信号，这样数据就可以从套接字读取，在该实例中读取到缓冲区并进行处理。单个线程可以提供数万个并发连接。</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">5、在 Nginx 中，如何使用未定义的服务器名称来阻止处理请求?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">只需将请求删除的服务器就可以定义为：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Server {listen 80;server_name “ “ ;return 444;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下匹配请求，而一个特殊的 Nginx 的非标准代码 444 被返回，从而终止连接。</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">6、 使用“反向代理服务器”的优点是什么?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">7、请列举 Nginx 服务器的最佳用途。</p><p class="s19" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Nginx 服务器的最佳用法是在网络上部署动态 HTTP 内容，使用 SCGI、WSGI 应用程序服务器、用于脚本的 FastCGI 处理程序。它还可以作为负载均衡器。</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">8、请解释 Nginx 服务器上的 Master 和 Worker 进程分别是什么?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;line-height: 193%;text-align: left;">Master 进程：读取及评估配置和维持 Worker 进程：处理请求</p><p class="s104" style="padding-left: 23pt;text-indent: 0pt;line-height: 18pt;text-align: left;">9、请解释你如何通过不同于 80 的端口开启 Nginx?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">为了通过一个不同的端口开启 Nginx，你必须进入/etc/Nginx/sites- enabled/，如果这是默认文件，那么你必须打开名为“default”的文件。编辑文件，并放置在你想要的端口：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Like server { listen 81; }</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">10、请解释是否有可能将 Nginx 的错误替换为 502 错误、503?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">502 =错误网关</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">503 =服务器超载</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">有可能，但是您可以确保 fastcgi_intercept_errors 被设置为 ON，并使用错误页面指令。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Location / {fastcgi_pass 127.0.01:9001;fastcgi_intercept_errors on;error_page 502 =503/error_page.html;#…}</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">11、在 Nginx 中，解释如何在 URL 中保留双斜线?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">要在 URL 中保留双斜线，就必须使用 merge_slashes_off;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">语法:merge_slashes [on/off]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">默认值: merge_slashes on</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">环境: http，server</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">12、请解释 ngx_http_upstream_module 的作用是什么?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">ngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">传递、memcached 传递和 scgi 传递指令来引用的服务器组。</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">13、请解释什么是 C10K 问题?</p><p class="s19" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">C10K 问题是指无法同时处理大量客户端(10,000)的网络套接字。</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">14、请陈述 stub_status 和 sub_filter 指令的作用是什么?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Stub_status 指令：该指令用于了解 Nginx 当前状态的当前状态，如当前的活动连接，接受和处理当前读/写/等待连接的总数</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Sub_filter 指令：它用于搜索和替换响应中的内容，并快速修复陈旧的数据</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">15、解释 Nginx 是否支持将请求压缩到上游?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤器，它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">码:gzip”来解压缩响应。</p><p class="s104" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">16、解释如何在 Nginx 中获得当前的时间?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">要获得 Nginx 的当前时间，必须使用 SSI 模块、$date_gmt 和$date_local 的变量。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;line-height: 162%;text-align: left;">Proxy_set_header THE-TIME $date_gmt; <span class="s104">17、用 Nginx 服务器解释-s 的目的是什么?</span>用于运行 Nginx -s 参数的可执行文件。 <span class="s104">18、解释如何在 Nginx 服务器上添加模块?</span></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">择。</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">问题一：<span class="s84">RabbitMQ </span>中的 <span class="s84">broker </span>是指什么？<span class="s84">cluster </span>又是指什么？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：<span class="s84">broker </span>是指一个或多个 <span class="s84">erlang node </span>的逻辑分组，且 <span class="s84">node </span>上运行着 <span class="s84">RabbitMQ </span>应用程序。<span class="s84">cluster </span>是在 <span class="s84">broker </span>的基础之上，增加了 <span class="s84">node </span>之间共享元数据的约束。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">问题二：什么是元数据？元数据分为哪些类型？包括哪些内容？与 <span class="s84">cluster </span>相关的元数据有哪些？元数据是如何保存的？元数据在 <span class="s84">cluster </span>中是如何分布的？</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：在非 <span class="s84">cluster </span>模式下，元数据主要分为 <span class="s84">Queue </span>元数据（<span class="s84">queue </span>名字和属性等）、 <span class="s84">Exchange </span>元数据（<span class="s84">exchange </span>名字、类型和属性等）、<span class="s84">Binding </span>元数据（存放路由关系的查找表）、<span class="s84">Vhost </span>元数据（<span class="s84">vhost </span>范围内针对前三者的名字空间约束和安全属性设置）。在 <span class="s84">cluster </span>模式下，还包括 <span class="s84">cluster </span>中 <span class="s84">node </span>位置信息和 <span class="s84">node </span>关系信息。元数据按照 <span class="s84">erlang node </span>的类型确定是仅保存于 <span class="s84">RAM </span>中，还是同时保存在 <span class="s84">RAM  </span>和 <span class="s84">disk </span>上。元数据在 <span class="s84">cluster </span>中是全 <span class="s84">node </span>分布的。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">下图所示为 <span class="s84">queue </span>的元数据在单 <span class="s84">node </span>和 <span class="s84">cluster </span>两种模式下的分布图。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">问题三：<span class="s84">RAM node </span>和 <span class="s84">disk node </span>的区别？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：<span class="s84">RAM node </span>仅将 <span class="s84">fabric</span>（即 <span class="s84">queue</span>、<span class="s84">exchange </span>和 <span class="s84">binding </span>等 <span class="s84">RabbitMQ </span>基础构件）相关元数据保存到内存中，但 <span class="s84">disk node </span>会在内存和磁盘中均进行存储。<span class="s84">RAM node </span>上唯一会存储到磁盘上的元数据是 <span class="s84">cluster </span>中使用的 <span class="s84">disk node </span>的地址。要求在 <span class="s84">RabbitMQ cluster</span>中至少存在一个 <span class="s84">disk node </span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">问题四：<span class="s84">RabbitMQ </span>上的一个 <span class="s84">queue </span>中存放的 <span class="s84">message </span>是否有数量限制？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：可以认为是无限制，因为限制取决于机器的内存，但是消息过多会导致处理效率的下降。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">问题五：<span class="s84">RabbitMQ </span>概念里的 <span class="s84">channel</span>、<span class="s84">exchange </span>和 <span class="s84">queue </span>这些东东是逻辑概念，还是对应着进程实体？这些东东分别起什么作用？</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：<span class="s84">queue </span>具有自己的 <span class="s84">erlang </span>进程；<span class="s84">exchange </span>内部实现为保存 <span class="s84">binding </span>关系的查找表； <span class="s84">channel </span>是实际进行路由工作的实体，即负责按照  <span class="s84">routing_key  </span>将  <span class="s84">message </span>投递给 <span class="s84">queue </span>。由 <span class="s84">AMQP </span>协议描述可知，<span class="s84">channel </span>是真实 <span class="s84">TCP </span>连接之上的虚拟连接，所有 <span class="s84">AMQP </span>命令都是通过 <span class="s84">channel </span>发送的，且每一个 <span class="s84">channel </span>有唯一的 <span class="s84">ID</span>。一个 <span class="s84">channel </span>只能被单独一个操作系统线程使用，故投递到特定 <span class="s84">channel </span>上的 <span class="s84">message </span>是有顺序的。但一个操作系统线程上允许使用多个 <span class="s84">channel </span>。<span class="s84">channel </span>号为 <span class="s84">0 </span>的 <span class="s84">channel </span>用于处理所有对于当前 <span class="s84">connection </span>全局有效的帧，而 <span class="s84">1-65535 </span>号 <span class="s84">channel </span>用于处理和特定 <span class="s84">channel </span>相关的帧。<span class="s84">AMQP </span>协议给出的 <span class="s84">channel </span>复用模型如下</p><p style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: justify;">其中每一个 <span class="s84">channel </span>运行在一个独立的线程上，多线程共享同一个 <span class="s84">socket</span>。问题六：<span class="s84">vhost </span>是什么？起什么作用？</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: justify;">答：<span class="s84">vhost </span>可以理解为虚拟 <span class="s84">broker  </span>，即 <span class="s84">mini-RabbitMQ  server</span>。其内部均含有独立的</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">queue<span class="p">、</span>exchange  <span class="p">和 </span>binding <span class="p">等，但最最重要的是，其拥有独立的权限系统，可以做到 </span>vhost <span class="p">范围的用户控制。当然，从 </span>RabbitMQ <span class="p">的全局角度，</span>vhost <span class="p">可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 </span>vhost <span class="p">中）。</span></p><p style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">【<span class="s84">cluster </span>相关】</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">问题七：在单 <span class="s84">node </span>系统和多 <span class="s84">node </span>构成的 <span class="s84">cluster </span>系统中声明 <span class="s84">queue</span>、<span class="s84">exchange </span>，以及进行 <span class="s84">binding </span>会有什么不同？</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：当你在单 <span class="s84">node </span>上声明 <span class="s84">queue </span>时，只要该 <span class="s84">node </span>上相关元数据进行了变更，你就会得到 <span class="s84">Queue.Declare-ok </span>回应；而在 <span class="s84">cluster </span>上声明 <span class="s84">queue </span>，则要求 <span class="s84">cluster </span>上的全部 <span class="s84">node </span>都要进行元数据成功更新，才会得到 <span class="s84">Queue.Declare-ok </span>回应。另外，若 <span class="s84">node </span>类型为 <span class="s84">RAM node </span>则变更的数据仅保存在内存中，若类型为 <span class="s84">disk node </span>则还要变更保存在磁盘上的数据。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">问题八：客户端连接到 <span class="s84">cluster </span>中的任意 <span class="s84">node </span>上是否都能正常工作？答：是的。客户端感觉不到有何不同。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">问题九：若 <span class="s84">cluster </span>中拥有某个 <span class="s84">queue </span>的 <span class="s84">owner node </span>失效了，且该 <span class="s84">queue </span>被声明具有</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">durable <span class="p">属性，是否能够成功从其他 </span>node <span class="p">上重新声明该 </span>queue <span class="p">？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：不能，在这种情况下，将得到 <span class="s84">404 NOT_FOUND </span>错误。只能等 <span class="s84">queue </span>所属的 <span class="s84">node</span>恢复后才能使用该 <span class="s84">queue </span>。但若该 <span class="s84">queue </span>本身不具有 <span class="s84">durable </span>属性，则可在其他 <span class="s84">node</span>上重新声明。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">问题十：<span class="s84">cluster </span>中 <span class="s84">node </span>的失效会对 <span class="s84">consumer </span>产生什么影响？若是在 <span class="s84">cluster </span>中创建了</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">mirrored queue <span class="p">，这时 </span>node <span class="p">失效会对 </span>consumer <span class="p">产生什么影响？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：若是 <span class="s84">consumer </span>所连接的那个 <span class="s84">node </span>失效（无论该 <span class="s84">node </span>是否为 <span class="s84">consumer </span>所订阅 <span class="s84">queue </span>的 <span class="s84">owner node</span>），则 <span class="s84">consumer </span>会在发现 <span class="s84">TCP </span>连接断开时，按标准行为执行重连逻辑，并根据“<span class="s84">Assume Nothing</span>”原则重建相应的 <span class="s84">fabric </span>即可。若是失效的 <span class="s84">node  </span>为 <span class="s84">consumer </span>订阅 <span class="s84">queue  </span>的 <span class="s84">owner node</span>，则 <span class="s84">consumer </span>只能通过 <span class="s84">Consumer Cancellation Notification </span>机制来检测与该 <span class="s84">queue </span>订阅关系的终止，否则会出现傻等却没有任何消息来到的问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十一：能够在地理上分开的不同数据中心使用 <span class="s84">RabbitMQ cluster </span>么？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：不能。第一，你无法控制所创建的 <span class="s84">queue </span>实际分布在 <span class="s84">cluster </span>里的哪个 <span class="s84">node </span>上（一般使用 <span class="s84">HAProxy + cluster </span>模型时都是这样），这可能会导致各种跨地域访问时的常见问题；第二，<span class="s84">Erlang </span>的 <span class="s84">OTP </span>通信框架对延迟的容忍度有限，这可能会触发各种超时，导致业务疲于处理；第三，在广域网上的连接失效问题将导致经典的“脑裂”问题，而 <span class="s84">RabbitMQ </span>目前无法处理（该问题主要是说 <span class="s84">Mnesia</span>）。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">【综合问题】</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十二：为什么 <span class="s84">heavy RPC </span>的使用场景下不建议采用 <span class="s84">disk node </span>？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：<span class="s84">heavy RPC </span>是指在业务逻辑中高频调用 <span class="s84">RabbitMQ </span>提供的 <span class="s84">RPC </span>机制，导致不断创建、销毁 <span class="s84">reply queue </span>，进而造成 <span class="s84">disk node </span>的性能问题（因为会针对元数据不断写盘）。所以在使用 <span class="s84">RPC </span>机制时需要考虑自身的业务场景。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十三：向不存在的 <span class="s84">exchange </span>发 <span class="s84">publish </span>消息会发生什么？向不存在的 <span class="s84">queue </span>执行</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">consume <span class="p">动作会发生什么？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">答：都会收到 <span class="s84">Channel.Close </span>信令告之不存在（内含原因 <span class="s84">404 NOT_FOUND</span>）。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">问题十四：<span class="s84">routing_key </span>和 <span class="s84">binding_key </span>的最大长度是多少？答：<span class="s84">255 </span>字节。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十五：<span class="s84">RabbitMQ </span>允许发送的 <span class="s84">message </span>最大可达多大？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：根据 <span class="s84">AMQP </span>协议规定，消息体的大小由 <span class="s84">64-bit </span>的值来指定，所以你就可以知道到底能发多大的数据了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十六：什么情况下 <span class="s84">producer </span>不主动创建 <span class="s84">queue </span>是安全的？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">答：<span class="s84">1.message </span>是允许丢失的；<span class="s84">2.</span>实现了针对未处理消息的 <span class="s84">republish </span>功能（例如采用</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Publisher Confirm <span class="p">机制）。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">问题十七：“<span class="s84">dead letter</span>”<span class="s84">queue </span>的用途？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：当消息被 <span class="s84">RabbitMQ server </span>投递到 <span class="s84">consumer </span>后，但 <span class="s84">consumer </span>却通过 <span class="s84">Basic.Reject</span>进行了拒绝时（同时设置 <span class="s84">requeue=false</span>），那么该消息会被放入“<span class="s84">dead letter</span>”<span class="s84">queue </span>中。该 <span class="s84">queue </span>可用于排查 <span class="s84">message </span>被 <span class="s84">reject </span>或 <span class="s84">undeliver </span>的原因。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十八：为什么说保证 <span class="s84">message </span>被可靠持久化的条件是 <span class="s84">queue  </span>和 <span class="s84">exchange </span>具有</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">durable <span class="p">属性，同时 </span>message <span class="p">具有 </span>persistent <span class="p">属性才行？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：<span class="s84">binding </span>关系可以表示为 <span class="s84">exchange </span>– <span class="s84">binding </span>– <span class="s84">queue </span>。从文档中我们知道，若要求投递的 <span class="s84">message </span>能够不丢失，要求 <span class="s84">message </span>本身设置 <span class="s84">persistent </span>属性，要求 <span class="s84">exchange</span>和 <span class="s84">queue </span>都设置 <span class="s84">durable </span>属性。其实这问题可以这么想，若 <span class="s84">exchange </span>或 <span class="s84">queue </span>未设置 <span class="s84">durable </span>属性，则在其 <span class="s84">crash </span>之后就会无法恢复，那么即使 <span class="s84">message </span>设置了 <span class="s84">persistent </span>属性，仍然存在 <span class="s84">message </span>虽然能恢复但却无处容身的问题；同理，若 <span class="s84">message </span>本身未设置 <span class="s84">persistent </span>属性，则 <span class="s84">message </span>的持久化更无从谈起。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十九：什么情况下会出现 <span class="s84">blackholed </span>问题？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：<span class="s84">blackholed </span>问题是指，向 <span class="s84">exchange </span>投递了 <span class="s84">message  </span>，而由于各种原因导致该 <span class="s84">message </span>丢失，但发送者却不知道。可导致 <span class="s84">blackholed </span>的情况：<span class="s84">1.</span>向未绑定 <span class="s84">queue  </span>的 <span class="s84">exchange </span>发送 <span class="s84">message</span>；<span class="s84">2.exchange </span>以 <span class="s84">binding_key key_A </span>绑定了 <span class="s84">queue queue_A</span>，但向该 <span class="s84">exchange </span>发送 <span class="s84">message </span>使用的 <span class="s84">routing_key </span>却是 <span class="s84">key_B</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">问题二十：如何防止出现 <span class="s84">blackholed </span>问题？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：没有特别好的办法，只能在具体实践中通过各种方式保证相关 <span class="s84">fabric </span>的存在。另外，如果在执行 <span class="s84">Basic.Publish </span>时设置 <span class="s84">mandatory=true </span>，则在遇到可能出现 <span class="s84">blackholed </span>情况时，服务器会通过返回 <span class="s84">Basic.Return </span>告之当前 <span class="s84">message </span>无法被正确投递（内含原因 <span class="s84">312 NO_ROUTE</span>）。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">问题二十一：<span class="s84">Consumer Cancellation Notification </span>机制用于什么场景？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：用于保证当镜像 <span class="s84">queue </span>中 <span class="s84">master </span>挂掉时，连接到 <span class="s84">slave </span>上的 <span class="s84">consumer </span>可以收到自身 <span class="s84">consume </span>被取消的通知，进而可以重新执行 <span class="s84">consume </span>动作从新选出的 <span class="s84">master </span>出获得消息。若不采用该机制，连接到 <span class="s84">slave </span>上的 <span class="s84">consumer </span>将不会感知 <span class="s84">master </span>挂掉这个事</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">情，导致后续无法再收到新 <span class="s84">master </span>广播出来的 <span class="s84">message </span>。另外，因为在镜像 <span class="s84">queue </span>模式下，存在将 <span class="s84">message </span>进行 <span class="s84">requeue </span>的可能，所以实现 <span class="s84">consumer </span>的逻辑时需要能够正确处理出现重复 <span class="s84">message </span>的情况。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">问题二十二：<span class="s84">Basic.Reject </span>的用法是什么？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：该信令可用于 <span class="s84">consumer </span>对收到的 <span class="s84">message </span>进行 <span class="s84">reject </span>。若在该信令中设置 <span class="s84">requeue=true</span>，则当 <span class="s84">RabbitMQ server </span>收到该拒绝信令后，会将该 <span class="s84">message </span>重新发送到下一个处于  <span class="s84">consume </span>状态的  <span class="s84">consumer </span>处（理论上仍可能将该消息发送给当前 <span class="s84">consumer</span>）。若设置 <span class="s84">requeue=false </span>，则 <span class="s84">RabbitMQ server </span>在收到拒绝信令后，将直接将该 <span class="s84">message </span>从 <span class="s84">queue </span>中移除。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">另外一种移除 <span class="s84">queue </span>中 <span class="s84">message </span>的小技巧是，<span class="s84">consumer </span>回复 <span class="s84">Basic.Ack </span>但不对获取到的</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">message <span class="p">做任何处理。</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">而 <span class="s84">Basic.Nack </span>是对 <span class="s84">Basic.Reject </span>的扩展，以支持一次拒绝多条 <span class="s84">message </span>的能力。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">问题二十三：为什么不应该对所有的 <span class="s84">message </span>都使用持久化机制？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：首先，必然导致性能的下降，因为写磁盘比写 <span class="s84">RAM </span>慢的多，<span class="s84">message </span>的吞吐量可能有 <span class="s84">10 </span>倍的差距。其次，<span class="s84">message </span>的持久化机制用在 <span class="s84">RabbitMQ </span>的内置 <span class="s84">cluster </span>方案时会出现“坑爹”问题。矛盾点在于，若 <span class="s84">message </span>设置了 <span class="s84">persistent </span>属性，但 <span class="s84">queue </span>未设置 <span class="s84">durable </span>属性，那么当该 <span class="s84">queue </span>的 <span class="s84">owner node </span>出现异常后，在未重建该 <span class="s84">queue </span>前，发往该 <span class="s84">queue </span>的 <span class="s84">message </span>将被 <span class="s84">blackholed </span>；若 <span class="s84">message </span>设置了 <span class="s84">persistent </span>属性，同时 <span class="s84">queue </span>也设置了 <span class="s84">durable </span>属性，那么当 <span class="s84">queue </span>的 <span class="s84">owner node </span>异常且无法重启的情况下，则该 <span class="s84">queue </span>无法在其他 <span class="s84">node </span>上重建，只能等待其 <span class="s84">owner node </span>重启后，才能恢复该 <span class="s84">queue </span>的使用，而在这段时间内发送给该 <span class="s84">queue </span>的 <span class="s84">message </span>将被 <span class="s84">blackholed </span>。所以，是否要对 <span class="s84">message </span>进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 <span class="s84">100,000 </span>条<span class="s84">/</span>秒以上的消息吞吐量（单 <span class="s84">RabbitMQ </span>服务器），则要么使用其他的方式来确保 <span class="s84">message </span>的可靠 <span class="s84">delivery </span>，要么使用非常快速的存储系统以支持全持久化（例如使用 <span class="s84">SSD</span>）。另外一种处理原则是：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">问题二十四：<span class="s84">RabbitMQ </span>中的 <span class="s84">cluster</span>、<span class="s84">mirrored queue</span>，以及 <span class="s84">warrens </span>机制分别用于解决什么问题？存在哪些问题？</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">答：<span class="s84">cluster </span>是为了解决当 <span class="s84">cluster </span>中的任意 <span class="s84">node </span>失效后，<span class="s84">producer </span>和 <span class="s84">consumer </span>均可以通过其他 <span class="s84">node </span>继续工作，即提高了可用性；另外可以通过增加 <span class="s84">node </span>数量增加 <span class="s84">cluster</span>的消息吞吐量的目的。<span class="s84">cluster </span>本身不负责 <span class="s84">message </span>的可靠性问题（该问题由 <span class="s84">producer </span>通过各种机制自行解决）；<span class="s84">cluster </span>无法解决跨数据中心的问题（即脑裂问题）。另外，在 <span class="s84">cluster </span>前使用 <span class="s84">HAProxy </span>可以解决 <span class="s84">node </span>的选择问题，即业务无需知道 <span class="s84">cluster </span>中多个 <span class="s84">node </span>的 <span class="s84">ip </span>地址。可以利用 <span class="s84">HAProxy </span>进行失效 <span class="s84">node </span>的探测，可以作负载均衡。下图为 <span class="s84">HAProxy + cluster </span>的模型。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Mirrored queue <span class="p">是为了解决使用 </span>cluster <span class="p">时所创建的 </span>queue <span class="p">的完整信息仅存在于单一 </span>node <span class="p">上的问题，从另一个角度增加可用性。若想正确使用该功能，需要保证：</span>1.consumer<span class="p">需要支持 </span>Consumer Cancellation Notification <span class="p">机制；</span>2.consumer <span class="p">必须能够正确处理重复 </span>message <span class="p">。</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Warrens <span class="p">是为了解决 </span>cluster  <span class="p">中 </span>message <span class="p">可能被 </span>blackholed <span class="p">的问题，即不能接受 </span>producer <span class="p">不停 </span>republish message <span class="p">但 </span>RabbitMQ server <span class="p">无回应的情况。</span>Warrens <span class="p">有两种构成方式，一种模型是两台独立的 </span>RabbitMQ server + HAProxy <span class="p">，其中两个 </span>server <span class="p">的状态分别为 </span>active <span class="p">和 </span>hot-standby <span class="p">。该模型的特点为：两台 </span>server <span class="p">之间无任何数据共享和协议交互，两台 </span>server <span class="p">可以基于不同的 </span>RabbitMQ <span class="p">版本。如下图所示</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">另一种模型为两台共享存储的 <span class="s84">RabbitMQ server + keepalived </span>，其中两个 <span class="s84">server </span>的状态分别为 <span class="s84">active </span>和 <span class="s84">cold-standby </span>。该模型的特点为：两台 <span class="s84">server </span>基于共享存储可以做到完全恢复，要求必须基于完全相同的 <span class="s84">RabbitMQ </span>版本。如下图所示</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Warrens <span class="p">模型存在的问题：对于第一种模型，虽然理论上讲不会丢失消息，但若在该模型上使用持久化机制，就会出现这样一种情况，即若作为 </span>active <span class="p">的 </span>server <span class="p">异常后，持久化在该 </span>server <span class="p">上的消息将暂时无法被 </span>consume <span class="p">，因为此时该 </span>queue <span class="p">将无法在作为 </span>hot- standby <span class="p">的 </span>server <span class="p">上被重建，所以，只能等到异常的 </span>active server <span class="p">恢复后，才能从其上的 </span>queue <span class="p">中获取相应的 </span>message <span class="p">进行处理。而对于业务来说，需要具有：</span>a.<span class="p">感知 </span>AMQP <span class="p">连接断开后重建各种 </span>fabric <span class="p">的能力；</span>b.<span class="p">感知 </span>active server <span class="p">恢复的能力；</span>c.<span class="p">切换回 </span>active server <span class="p">的时机控制，以及切回后，针对 </span>message <span class="p">先后顺序产生的变化进行处理的能力。对于第二种模型，因为是基于共享存储的模式，所以导致 </span>active server <span class="p">异常的条件，可能同样会导致 </span>cold-standby server <span class="p">异常；另外，在该模型下，要求 </span>active <span class="p">和 </span>cold-standby<span class="p">的 </span>server <span class="p">必须具有相同的 </span>node <span class="p">名和 </span>UID <span class="p">，否则将产生访问权限问题；最后，由于该模型是冷备方案，故无法保证 </span>cold-standby server <span class="p">能在你要求的时限内成功启动。</span></p><p class="s91" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">redis <span class="s97">和 </span>memcached <span class="s97">什么区别？为什么高并发下有时单线程的 </span>redis <span class="s97">比多线程的</span></p><p class="s91" style="padding-left: 23pt;text-indent: 0pt;line-height: 17pt;text-align: left;">memcached <span class="s97">效率要高？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">区别：</p><ol id="l89"><li data-list-text="1."><p class="s84" style="padding-top: 2pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">mc <span class="p">可缓存图片和视频。</span>rd <span class="p">支持除 </span>k/v <span class="p">更多的数据结构</span>;</p></li><li data-list-text="2."><p class="s84" style="padding-top: 2pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">rd <span class="p">可以使用虚拟内存，</span>rd <span class="p">可持久化和 </span>aof <span class="p">灾难恢复，</span>rd <span class="p">通过主从支持数据备份</span>;</p></li><li data-list-text="3."><p class="s84" style="padding-top: 2pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">rd <span class="p">可以做消息队列。</span></p></li></ol><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">原因：<span class="s84">mc </span>多线程模型引入了缓存一致性和锁，加锁带来了性能损耗。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 23pt;text-indent: 0pt;line-height: 19pt;text-align: left;">redis <span class="s97">主从复制如何实现的？</span>redis <span class="s97">的集群模式如何实现？</span>redis <span class="s97">的 </span>key <span class="s97">是如何寻址的？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">主从复制实现：主节点将自己内存中的数据做一份快照，将快照发给从节点，从节点将数据恢复到内存中。之后再每次增加新数据的时候，主节点以类似于 <span class="s84">mysql </span>的二进制日志方式将语句发送给从节点，从节点拿到主节点发送过来的语句进行重放。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">分片方式：</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">-<span class="p">客户端分片</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">-<span class="p">基于代理的分片</span></p><ul id="l90"><li data-list-text="●"><p class="s84" style="padding-top: 2pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">Twemproxy</p></li><li data-list-text="●"><p class="s84" style="padding-top: 2pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">codis</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">-<span class="p">路由查询分片</span></p></li><li data-list-text="●"><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Redis-cluster<span class="p">（本身提供了自动将数据分散到 </span>Redis Cluster <span class="p">不同节点的能力，整个数据集合的某个数据子集存储在哪个节点对于用户来说是透明的）</span></p></li></ul><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">redis-cluster <span class="p">分片原理：</span>Cluster <span class="p">中有一个 </span>16384 <span class="p">长度的槽</span>(<span class="p">虚拟槽</span>)<span class="p">，编号分别为 </span>0-16383<span class="p">。 每个 </span>Master <span class="p">节点都会负责一部分的槽，当有某个 </span>key <span class="p">被映射到某个 </span>Master <span class="p">负责的槽，那么这个 </span>Master <span class="p">负责为这个 </span>key <span class="p">提供服务，至于哪个 </span>Master <span class="p">节点负责哪个槽，可以由用户指定，也可以在初始化的时候自动生成，只有 </span>Master <span class="p">才拥有槽的所有权。</span>Master <span class="p">节点维 护着一个 </span>16384/8 <span class="p">字节的位序列，</span>Master <span class="p">节点用 </span>bit <span class="p">来标识对于某个槽自己是否拥有。比如对于编号为 </span>1 <span class="p">的槽，</span>Master <span class="p">只要判断序列的第二位（索引从 </span>0 <span class="p">开始）是不是为 </span>1 <span class="p">即可。这种结构很容易添加或者删除节点。比如如果我想新添加个节点 </span>D, <span class="p">我需要从节点 </span>A<span class="p">、</span>B<span class="p">、 </span>C <span class="p">中得部分槽到 </span>D <span class="p">上。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s97" style="padding-left: 23pt;text-indent: 0pt;line-height: 81%;text-align: left;">使用 <span class="s91">redis </span>如何设计分布式锁？说一下实现思路？使用 <span class="s91">zk </span>可以吗？如何实现？这两种有什么区别？</p><p class="s84" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">redis:</p><ol id="l91"><li data-list-text="1."><p style="padding-top: 2pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">线程 <span class="s84">A setnx(</span>上锁的对象<span class="s84">,</span>超时时的时间戳 <span class="s84">t1)</span>，如果返回 <span class="s84">true</span>，获得锁。</p></li><li data-list-text="2."><p style="padding-top: 2pt;padding-left: 31pt;text-indent: -8pt;text-align: left;">线程 <span class="s84">B </span>用 <span class="s84">get </span>获取 <span class="s84">t1,</span>与当前时间戳比较<span class="s84">,</span>判断是是否超时<span class="s84">,</span>没超时 <span class="s84">false,</span>若超时执行第 <span class="s84">3 </span>步<span class="s84">;</span></p></li><li data-list-text="3."><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">计算新的超时时间 <span class="s84">t2,</span>使用 <span class="s84">getset </span>命令返回 <span class="s84">t3(</span>该值可能其他线程已经修改过<span class="s84">),</span>如果 <span class="s84">t1==t3</span>，获得锁，如果 <span class="s84">t1!=t3 </span>说明锁被其他线程获取了。</p></li><li data-list-text="4."><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时，不用处理（防止删除其他线程的锁）。</p></li></ol><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">zk:</p><ol id="l92"><li data-list-text="1."><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">客户端对某个方法加锁时，在 <span class="s84">zk </span>上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点 <span class="s84">node1;</span></p></li><li data-list-text="2."><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">客户端获取该路径下所有已经创建的子节点，如果发现自己创建的 <span class="s84">node1 </span>的序号是最小的，就认为这个客户端获得了锁。</p></li><li data-list-text="3."><p style="padding-left: 31pt;text-indent: -8pt;line-height: 13pt;text-align: left;">如果发现 <span class="s84">node1 </span>不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待。</p></li><li data-list-text="4."><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">获取锁后，处理完逻辑，删除自己创建的 <span class="s84">node1 </span>即可。区别<span class="s84">:zk </span>性能差一些，开销大，实现简单。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s97" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">知道 <span class="s91">redis </span>的持久化吗？底层如何实现的？有什么优点缺点？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">RDB(Redis  DataBase:<span class="p">在不同的时间点将 </span>redis <span class="p">的数据生成的快照同步到磁盘等介质上</span>):<span class="p">内存到硬盘的快照，定期更新。缺点：耗时，耗性能</span>(fork+io <span class="p">操作</span>)<span class="p">，易丢失数据。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">AOF(Append Only File<span class="p">：将 </span>redis <span class="p">所执行过的所有指令都记录下来，在下次 </span>redis <span class="p">重启时，只需要执行指令就可以了</span>):<span class="p">写日志。缺点：体积大，恢复速度慢。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">bgsave <span class="p">做镜像全量持久化，</span>aof <span class="p">做增量持久化。因为 </span>bgsave <span class="p">会消耗比较长的时间，不够实时，在停机的时候会导致大量的数据丢失，需要 </span>aof <span class="p">来配合，在 </span>redis <span class="p">实例重启时，优先使用 </span>aof <span class="p">来恢复内存的状态，如果没有 </span>aof <span class="p">日志，就会使用 </span>rdb <span class="p">文件来恢复。</span>Redis <span class="p">会定期做 </span>aof <span class="p">重写，压缩 </span>aof <span class="p">文件日志大小。</span>Redis4.0 <span class="p">之后有了混合持久化的功能，将 </span>bgsave <span class="p">的全量和 </span>aof <span class="p">的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。</span>bgsave <span class="p">的原理，</span>fork <span class="p">和 </span>cow, fork <span class="p">是指 </span>redis <span class="p">通过创建子进程来进行 </span>bgsave <span class="p">操作，</span>cow <span class="p">指的是 </span>copy on write<span class="p">，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">redis <span class="s97">过期策略都有哪些？</span>LRU <span class="s97">算法知道吗？写一下 </span>java <span class="s97">代码实现？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">过期策略<span class="s84">:</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">定时过期<span class="s84">(</span>一 <span class="s84">key </span>一定时器<span class="s84">)</span>，惰性过期：只有使用 <span class="s84">key </span>时才判断 <span class="s84">key </span>是否已过期，过期则清除。定期过期：前两者折中。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">LRU:new LinkedHashMap&lt;K, V&gt;(capacity, DEFAULT_LOAD_FACTORY, true);</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">//<span class="p">第三个参数置为 </span>true<span class="p">，代表 </span>linkedlist <span class="p">按访问顺序排序，可作为 </span>LRU <span class="p">缓存；设为 </span>false <span class="p">代表按插入顺序排序，可作为 </span>FIFO <span class="p">缓存</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">LRU <span class="p">算法实现：</span>1.<span class="p">通过双向链表来实现，新数据插入到链表头部；</span>2.<span class="p">每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</span>3.<span class="p">当链表满的时候，将链表尾部的数据丢弃。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">LinkedHashMap<span class="p">：</span>HashMap <span class="p">和双向链表合二为一即是 </span>LinkedHashMap<span class="p">。</span>HashMap <span class="p">是无序 的，</span>LinkedHashMap <span class="p">通过维护一个额外的双向链表保证了迭代顺序。该迭代顺序可以是插入顺序（默认），也可以是访问顺序。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s97" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">缓存穿透、缓存击穿、缓存雪崩解决方案？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">缓存穿透：指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 <span class="s84">DB </span>去查询，可能导致 <span class="s84">DB </span>挂掉。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">解决方案：<span class="s84">1.</span>查询返回的数据为空，仍把这个空结果进行缓存，但过期时间会比较短；<span class="s84">2.</span>布隆过滤器：将所有可能存在的数据哈希到一个足够大的 <span class="s84">bitmap </span>中，一个一定不存在的数据会被这个 <span class="s84">bitmap </span>拦截掉，从而避免了对 <span class="s84">DB </span>的查询。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">缓存击穿：对于设置了过期时间的 <span class="s84">key</span>，缓存在某个时间点过期的时候，恰好这时间点对这个 <span class="s84">Key </span>有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 <span class="s84">DB </span>加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 <span class="s84">DB </span>压垮。</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">解决方案：<span class="s84">1.</span>使用互斥锁：当缓存失效时，不立即去 <span class="s84">load db</span>，先使用如 <span class="s84">Redis </span>的 <span class="s84">setnx </span>去设置一个互斥锁，当操作成功返回时再进行 <span class="s84">load db </span>的操作并回设缓存，否则重试 <span class="s84">get </span>缓存的方法。<span class="s84">2.</span>永远不过期：物理不过期，但逻辑过期（后台异步线程去刷新）。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">缓存雪崩：设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 <span class="s84">DB</span>，<span class="s84">DB </span>瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多 <span class="s84">key</span>，击穿是某一个 <span class="s84">key </span>缓存。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">解决方案：将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如 <span class="s84">1-5 </span>分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s97" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">在选择缓存时，什么时候选择 <span class="s91">redis</span>，什么时候选择 <span class="s91">memcached</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">选择 <span class="s84">redis </span>的情况：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 14pt;line-height: 115%;text-align: justify;">1<span class="p">、复杂数据结构，</span>value <span class="p">的数据是哈希，列表，集合，有序集合等这种情况下，会选择 </span>redis, <span class="p">因为 </span>memcache <span class="p">无法满足这些数据结构，最典型的的使用场景是，用户订单列表，用户消息，帖子评论等。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 21pt;line-height: 115%;text-align: left;">2<span class="p">、需要进行数据的持久化功能，但是注意，不要把 </span>redis <span class="p">当成数据库使用，如果 </span>redis<span class="p">挂了，内存能够快速恢复热数据，不会将压力瞬间压在数据库上，没有 </span>cache <span class="p">预热的过 程。对于只读和数据一致性要求不高的场景可以采用持久化存储</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 19pt;line-height: 115%;text-align: left;">3<span class="p">、高可用，</span>redis <span class="p">支持集群，可以实现主动复制，读写分离，而对于 </span>memcache <span class="p">如果想要实现高可用，需要进行二次开发。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 14pt;line-height: 231%;text-align: left;">4<span class="p">、存储的内容比较大，</span>memcache <span class="p">存储的 </span>value <span class="p">最大为 </span>1M<span class="p">。选择 </span>memcache <span class="p">的场景：</span></p><p class="s84" style="padding-left: 34pt;text-indent: 0pt;line-height: 13pt;text-align: left;">1<span class="p">、纯 </span>KV,<span class="p">数据量非常大的业务，使用 </span>memcache <span class="p">更合适，原因是，</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l93"><li data-list-text="a)"><p class="s84" style="padding-left: 23pt;text-indent: 32pt;line-height: 115%;text-align: left;">memcache <span class="p">的内存分配采用的是预分配内存池的管理方式，能够省去内存分配的时间，</span>redis <span class="p">是临时申请空间，可能导致碎片化。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="b)"><p style="padding-left: 23pt;text-indent: 31pt;line-height: 115%;text-align: left;">虚拟内存使用，<span class="s84">memcache </span>将所有的数据存储在物理内存里，<span class="s84">redis </span>有自己的 <span class="s84">vm </span>机制，理论上能够存储比物理内存更多的数据，当数据超量时，引发 <span class="s84">swap,</span>把冷数据刷新到 磁盘上，从这点上，数据量大时，<span class="s84">memcache </span>更快</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="c)"><p style="padding-left: 23pt;text-indent: 32pt;line-height: 115%;text-align: justify;">网络模型，<span class="s84">memcache </span>使用非阻塞的 <span class="s84">IO </span>复用模型，<span class="s84">redis </span>也是使用非阻塞的 <span class="s84">IO </span>复用模型，但是 <span class="s84">redis </span>还提供了一些非 <span class="s84">KV </span>存储之外的排序，聚合功能，复杂的 <span class="s84">CPU </span>计算，会阻塞整个 <span class="s84">IO </span>调度，从这点上由于 <span class="s84">redis </span>提供的功能较多，<span class="s84">memcache </span>更快些</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="d)"><p style="padding-left: 23pt;text-indent: 34pt;line-height: 115%;text-align: left;">线程模型，<span class="s84">memcache </span>使用多线程，主线程监听，<span class="s84">worker </span>子线程接受请求，执行读写，这个过程可能存在锁冲突。<span class="s84">redis </span>使用的单线程，虽然无锁冲突，但是难以利用多核</p></li></ol></li></ol><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">的特性提升吞吐量。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s97" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">缓存与数据库不一致怎么办</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">假设采用的主存分离，读写分离的数据库，</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">如果一个线程 <span class="s84">A </span>先删除缓存数据，然后将数据写入到主库当中，这个时候，主库和从库同步没有完成，线程 <span class="s84">B </span>从缓存当中读取数据失败，从从库当中读取到旧数据，然后更新至缓存，这个时候，缓存当中的就是旧的数据。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">发生上述不一致的原因在于，主从库数据不一致问题，加入了缓存之后，主从不一致的时间被拉长了</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">处理思路：在从库有数据更新之后，将缓存当中的数据也同时进行更新，即当从库发生了数据更新之后，向缓存发出删除，淘汰这段时间写入的旧数据。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s97" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">主从数据库不一致如何解决</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">场景描述，对于主从库，读写分离，如果主从库更新同步有时差，就会导致主从库数据的不一致</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">1<span class="p">、忽略这个数据不一致，在数据一致性要求不高的业务下，未必需要时时一致性</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">2<span class="p">、强制读主库，使用一个高可用的主库，数据库读写都在主库，添加一个缓存，提升数据读取的性能。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">3<span class="p">、选择性读主库，添加一个缓存，用来记录必须读主库的数据，将哪个库，哪个表，哪个主键，作为缓存的 </span>key,<span class="p">设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Redis <span class="s97">常见的性能问题和解决方案</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">1<span class="p">、</span>master <span class="p">最好不要做持久化工作，如 </span>RDB <span class="p">内存快照和 </span>AOF <span class="p">日志文件</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">2<span class="p">、如果数据比较重要，某个 </span>slave <span class="p">开启 </span>AOF <span class="p">备份，策略设置成每秒同步一次</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">3<span class="p">、为了主从复制的速度和连接的稳定性，</span>master <span class="p">和 </span>Slave <span class="p">最好在一个局域网内</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 27pt;text-indent: 0pt;text-align: left;">4<span class="p">、尽量避免在压力大得主库上增加从库</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 27pt;text-indent: 0pt;text-align: justify;">5<span class="p">、主从复制不要采用网状结构，尽量是线性结构，</span>Master&lt;--Slave1&lt;----Slave2 ....</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Redis <span class="s97">的数据淘汰策略有哪些</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">voltile-lru <span class="p">从已经设置过期时间的数据集中挑选最近最少使用的数据淘汰 </span>voltile-ttl <span class="p">从已经设置过期时间的数据库集当中挑选将要过期的数据 </span>voltile-random <span class="p">从已经设置过期时间的数据集任意选择淘汰数据</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">allkeys-lru <span class="p">从数据集中挑选最近最少使用的数据淘汰</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">allkeys-random <span class="p">从数据集中任意选择淘汰的数据</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">no-eviction <span class="p">禁止驱逐数据</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Redis <span class="s97">当中有哪些数据结构</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">字符串 <span class="s84">String</span>、字典 <span class="s84">Hash</span>、列表 <span class="s84">List</span>、集合 <span class="s84">Set</span>、有序集合 <span class="s84">SortedSet</span>。如果是高级用户，那么还会有，如果你是 <span class="s84">Redis </span>中高级用户，还需要加上下面几种数据结构 <span class="s84">HyperLogLog</span>、 <span class="s84">Geo</span>、<span class="s84">Pub/Sub</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s97" style="padding-left: 23pt;text-indent: 0pt;line-height: 81%;text-align: left;">假如 <span class="s91">Redis </span>里面有 <span class="s91">1 </span>亿个 <span class="s91">key</span>，其中有 <span class="s91">10w </span>个 <span class="s91">key </span>是以某个固定的已知的前缀开头的，如果将它们全部找出来？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">使用 <span class="s84">keys </span>指令可以扫出指定模式的 <span class="s84">key </span>列表。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">对方接着追问：如果这个 <span class="s84">redis </span>正在给线上的业务提供服务，那使用 <span class="s84">keys </span>指令会有什么问题？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这个时候你要回答 <span class="s84">redis </span>关键的一个特性：<span class="s84">redis </span>的单线程的。<span class="s84">keys </span>指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <span class="s84">scan </span>指令，<span class="s84">scan </span>指令可以无阻塞的提取出指定模式的 <span class="s84">key </span>列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <span class="s84">keys </span>指令长。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s97" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">使用 <span class="s91">Redis </span>做过异步队列吗，是如何实现的</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 20pt;line-height: 115%;text-align: left;">使用 <span class="s84">list </span>类型保存数据信息，<span class="s84">rpush </span>生产消息，<span class="s84">lpop </span>消费消息，当 <span class="s84">lpop </span>没有消息时，可以 <span class="s84">sleep </span>一段时间，然后再检查有没有信息，如果不想 <span class="s84">sleep </span>的话，可以使用 <span class="s84">blpop, </span>在没有信息的时候，会一直阻塞，直到信息的到来。<span class="s84">redis </span>可以通过 <span class="s84">pub/sub </span>主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">失。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s91" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Redis <span class="s97">如何实现延时队列</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 15pt;line-height: 115%;text-align: left;">使用 <span class="s84">sortedset</span>，使用时间戳做 <span class="s84">score, </span>消息内容作为 <span class="s84">key,</span>调用 <span class="s84">zadd </span>来生产消息，消费者使用 <span class="s84">zrangbyscore </span>获取 <span class="s84">n </span>秒之前的数据做轮询处理。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="895" alt="image" src="整合_files/Image_351.png"/></span></p><p class="s110" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">1、什么是 Redis？简述它的优缺点？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">Redis 的全称是：Remote Dictionary.Server，本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Key-Value DB。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的 memcached 来用。 Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">2、Redis 与 memcached 相比有哪些优势？</p><ol id="l94"><li data-list-text="1."><p class="s110" style="padding-left: 30pt;text-indent: -7pt;line-height: 16pt;text-align: left;">memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型</p></li><li data-list-text="2."><p class="s110" style="padding-left: 30pt;text-indent: -7pt;line-height: 16pt;text-align: left;">redis 的速度比 memcached 快很多 redis 的速度比 memcached 快很多</p></li><li data-list-text="3."><p class="s110" style="padding-left: 30pt;text-indent: -7pt;line-height: 16pt;text-align: left;">redis 可以持久化其数据 redis 可以持久化其数据</p></li></ol><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">3、Redis 支持哪几种数据类型？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">String、List、Set、Sorted Set、hashes 4、Redis 主要消耗什么物理资源？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">内存。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">5、Redis 有哪几种数据淘汰策略？</p><ol id="l95"><li data-list-text="1."><p class="s110" style="padding-left: 30pt;text-indent: -7pt;line-height: 16pt;text-align: left;">noeviction:返回错误当内存限制达到，并且客户端尝试执行会让更多内存被使用的命令。</p></li><li data-list-text="2."><p class="s110" style="padding-left: 30pt;text-indent: -7pt;line-height: 16pt;text-align: left;">allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p></li><li data-list-text="3."><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</p></li><li data-list-text="4."><p class="s110" style="padding-left: 30pt;text-indent: -7pt;line-height: 15pt;text-align: left;">allkeys-random: 回收随机的键使得新添加的数据有空间存放。</p></li><li data-list-text="5."><p class="s110" style="padding-left: 30pt;text-indent: -7pt;line-height: 16pt;text-align: left;">volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</p></li><li data-list-text="6."><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p></li></ol><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">6、Redis 官方为什么不提供 Windows 版本？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来兼容性等问题。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">7、一个字符串类型的值能存储最大容量是多少？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">512M</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">8、为什么 Redis 需要把所有数据放到内存中？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">所以 redis 具有快速和数据持久化的特征，如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的性能。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">在内存越来越便宜的今天，redis 将会越来越受欢迎， 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">9、Redis 集群方案应该怎么做？都有哪些方案？</p><ol id="l96"><li data-list-text="1."><p class="s110" style="padding-left: 30pt;text-indent: -7pt;line-height: 16pt;text-align: left;">codis</p></li><li data-list-text="2."><p class="s110" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在节点数量改变情况下，旧节点数据可恢复到新 hash 节点。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p></li><li data-list-text="3."><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">在业务代码层实现，起几个毫无关联的 redis 实例，在代码层，对 key 进行 hash 计算，然后去对应的 redis 实例操作数据。这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方 案，数据震荡后的自动脚本恢复，实例的监控，等等。</p></li></ol><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">欢迎工作一到五年的 Java 工程师朋友们加入 Java 进阶架构学习交流：952124565，群内提供免费的 Java 架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm 性能调优、Spring 源码， MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx 等多个知识点的架构资料）合理利用自己每一分每一秒的时间来学习提升自己，不要再用&quot;没有时间“来掩饰自己思想上的懒</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">惰！趁年轻，使劲拼，给未来的自己一个交代！</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">10、Redis 集群方案什么情况下会导致整个集群不可用？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">5501-11000 这个范围的槽而不可用。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">11、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">其实面试除了考察 Redis，不少公司都很重视高并发高可用的技术，特别是一线互联网公司，分布式、 JVM、spring 源码分析、微服务等知识点已是面试的必考题。我自己整理收集了一套系统的架构技术体系，针对当前互联网公司的技术需求以及结合主流技术，这些东西可能你们平时在工作中接触过，但是缺少的全面系统的学习，加入后端开发群：943918498，或是关注微信公众号：Java 资讯库，回复“架</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">构”，免费领取架构资料。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">12、Redis 有哪些适合的场景？</p><ol id="l97"><li data-list-text="（1）"><p class="s110" style="padding-left: 46pt;text-indent: -23pt;line-height: 16pt;text-align: left;">会话缓存（Session Cache）</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">最常用的一种使用 Redis 的情景是会话缓存（sessioncache），用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台 Magento 也提供 Redis 的插件。</p></li><li data-list-text="（2）"><p class="s110" style="padding-left: 46pt;text-indent: -23pt;line-height: 15pt;text-align: left;">全页缓存（FPC）</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p></li><li data-list-text="（3）"><p class="s110" style="padding-left: 46pt;text-indent: -23pt;line-height: 15pt;text-align: left;">队列</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop操作。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。</p></li><li data-list-text="（4）"><p class="s110" style="padding-left: 46pt;text-indent: -23pt;line-height: 16pt;text-align: left;">排行榜/计数器</p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="915" alt="image" src="整合_files/Image_352.png"/></span></p><p class="s110" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（SortedSet）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">ZRANGE user_scores 0 10 WITHSCORES</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。</p></li><li data-list-text="（5）"><p class="s110" style="padding-left: 46pt;text-indent: -23pt;line-height: 15pt;text-align: left;">发布/订阅</p></li></ol><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">13、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？ Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。 14、Redis 和 Redisson 有什么关系？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">Redisson 是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">15、Jedis 与 Redisson 对比有什么优缺点？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">16、说说 Redis 哈希槽的概念？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">17、Redis 集群的主从复制模型是怎样的？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">18、Redis 集群会有写操作丢失吗？为什么？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">19、Redis 集群之间是如何复制的？异步复制</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">20、Redis 集群最大节点个数是多少？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">16384 个</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">21、Redis 集群如何选择数据库？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Redis 集群目前无法做数据库选择，默认在 0 数据库。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">22、Redis 中的管道有什么用？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="915" alt="image" src="整合_files/Image_353.png"/></span></p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 16pt;text-align: left;">23、怎么理解 Redis 事务？</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 94%;text-align: left;">事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 15pt;text-align: left;">事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 16pt;text-align: left;">24、Redis 事务相关的命令有哪几个？</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 16pt;text-align: left;">MULTI、EXEC、DISCARD、WATCH</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 16pt;text-align: left;">25、Redis key 的过期时间和永久有效分别怎么设置？</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 16pt;text-align: left;">EXPIRE 和 PERSIST 命令</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 16pt;text-align: left;">26、Redis 如何做内存优化？</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 94%;text-align: left;">尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 94%;text-align: left;">比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面。</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 15pt;text-align: left;">27、Redis 回收进程如何工作的？</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 16pt;text-align: left;">一个客户端运行了新的命令，添加了新的数据。</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 94%;text-align: left;">Redi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。一个新的命令被执行，等等。</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 15pt;text-align: left;">所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 94%;text-align: left;">如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l98"><li data-list-text="28."><p class="s111" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">加锁机制</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">咱们来看上面那张图，现在某个客户端要加锁。如果该客户端面对的是一个 <span class="s113">redis cluster </span>集群，他首先会根据 <span class="s113">hash </span>节点选择一台机器。<span class="s111">这里注意</span>，仅仅只是选择一台机器！这点很关键！紧接着，就会发送一段 <span class="s113">lua </span>脚本到 <span class="s113">redis </span>上，那段 <span class="s113">lua </span>脚本如下所示：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">为啥要用 <span class="s113">lua </span>脚本呢？因为一大坨复杂的业务逻辑，可以通过封装在 <span class="s113">lua </span>脚本中发送给 <span class="s113">redis</span>，保证这段复杂业务逻辑执行的<span class="s111">原子性</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">那么，这段 <span class="s113">lua </span>脚本是什么意思呢？这里 <span class="s114">KEYS[1]</span>代表的是你加锁的那个 <span class="s113">key</span>，比如说：<span class="s113">RLoc k lock = redisson.getLock(&quot;myLock&quot;);</span>这里你自己设置了加锁的那个锁 <span class="s113">key </span>就是<span class="s113">“myLock”</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;"><span class="s114">ARGV[1]</span>代表的就是锁 <span class="s113">key </span>的默认生存时间，默认 <span class="s113">30 </span>秒。<span class="s114">ARGV[2]</span>代表的是加锁的客户端的 <span class="s113">I D</span>，类似于下面这样：<span class="s113">8743c9c0-0795-4907-87fd-6c719a6b4586:1</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">给大家解释一下，第一段 <span class="s113">if </span>判断语句，就是用<span class="s113">“</span><span class="s114">exists myLock</span><span class="s113">”</span>命令判断一下，如果你要加锁的那个锁 <span class="s113">key </span>不存在的话，你就进行加锁。如何加锁呢？很简单，<span class="s111">用下面的命令</span>：<span class="s113">hset myLoc k</span></p><p class="s113" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">8743c9c0-0795-4907-87fd-6c719a6b4586:1 1<span class="s112">，通过这个命令设置一个 </span>hash <span class="s112">数据结构，这行命令执行后，会出现一个类似下面的数据结构：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 90%;text-align: left;">上述就代表<span class="s113">“8743c9c0-0795-4907-87fd-6c719a6b4586:1”</span>这个客户端对<span class="s113">“myLock”</span>这个锁 <span class="s113">key </span>完成了加锁。接着会执行<span class="s113">“</span><span class="s114">pexpire myLock 30000</span><span class="s113">”</span>命令，设置 <span class="s113">myLock </span>这个锁 <span class="s113">key </span>的<span class="s111">生存时间是 </span><span class="s114">30 </span><span class="s111">秒</span>。好了，到此为止，<span class="s113">ok</span>，加锁完成了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="29."><p class="s111" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">锁互斥机制</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s113" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;"><span class="s112">那么在这个时候，如果客户端 </span>2 <span class="s112">来尝试加锁，执行了同样的一段 </span>lua <span class="s112">脚本，会咋样呢？很简单，第一个 </span>if <span class="s112">判断会执行</span>“<b>exists myLock</b>”<span class="s112">，发现 </span>myLock <span class="s112">这个锁 </span>key <span class="s112">已经存在了。接着第二个 </span>if <span class="s112">判断，判断一下，</span>myLock <span class="s112">锁 </span>key <span class="s112">的 </span>hash <span class="s112">数据结构中，是否包含客户端 </span>2 <span class="s112">的 </span>ID<span class="s112">，但是明显不是的，因为那里包含的是客户端 </span>1 <span class="s112">的 </span>ID<span class="s112">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">所以，客户端 <span class="s113">2 </span>会获取到 <span class="s114">pttl myLock </span>返回的一个数字，这个数字代表了 <span class="s113">myLock </span>这个锁 <span class="s113">key</span>的<span class="s111">剩余生存时间。</span>比如还剩 <span class="s113">15000 </span>毫秒的生存时间。此时客户端 <span class="s113">2 </span>会进入一个 <span class="s113">while </span>循环，不停的尝试加锁。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="30."><p class="s114" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">watch dog <span class="s111">自动延期机制</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">客户端 <span class="s113">1 </span>加锁的锁 <span class="s113">key </span>默认生存时间才 <span class="s113">30 </span>秒，如果超过了 <span class="s113">30 </span>秒，客户端 <span class="s113">1 </span>还想一直持有这把锁，怎么办呢？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;line-height: 85%;text-align: justify;">简单！只要客户端 <span class="s113">1 </span>一旦加锁成功，就会启动一个 <span class="s113">watch dog </span>看门狗，<span class="s111">他是一个后台线程，会每隔 </span><span class="s114">10 </span><span class="s111">秒检查一下</span>，如果客户端 <span class="s113">1 </span>还持有锁 <span class="s113">key</span>，那么就会不断的延长锁 <span class="s113">key </span>的生存时间。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="31."><p class="s111" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">可重入加锁机制</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">那如果客户端 <span class="s113">1 </span>都已经持有了这把锁了，结果可重入的加锁会怎么样呢？比如下面这种代码：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;line-height: 93%;text-align: justify;">这时我们来分析一下上面那段 <span class="s113">lua </span>脚本。<span class="s111">第一个 </span><span class="s114">if </span><span class="s111">判断肯定不成立</span>，<span class="s113">“exists myLock”</span>会显示锁 <span class="s113">key </span>已经存在了。<span class="s111">第二个 </span><span class="s114">if </span><span class="s111">判断会成立</span>，因为 <span class="s113">myLock </span>的 <span class="s113">hash </span>数据结构中包含的那个 <span class="s113">ID</span>，就是客户端 <span class="s113">1 </span>的那个 <span class="s113">ID</span>，也就是<span class="s113">“8743c9c0-0795-4907-87fd-6c719a6b4586:1”</span></p><p class="s112" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">此时就会执行可重入加锁的逻辑，他会用：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s113" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">incrby myLock 8743c9c0-0795-4907-87fd-6c71a6b4586:1 1 <span class="s112">，通过这个命令，对客户端 </span>1</p><p class="s112" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">的加锁次数，累加 <span class="s113">1</span>。此时 <span class="s113">myLock </span>数据结构变为下面这样：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">大家看到了吧，那个 <span class="s113">myLock </span>的 <span class="s113">hash </span>数据结构中的那个客户端 <span class="s113">ID</span>，就对应着加锁的次数</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="32."><p class="s111" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">释放锁机制</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">如果执行 <span class="s113">lock.unlock()</span>，就可以释放分布式锁，此时的业务逻辑也是非常简单的。其实说白 了，就是每次都对 <span class="s113">myLock </span>数据结构中的那个加锁次数减 <span class="s113">1</span>。如果发现加锁次数是 <span class="s113">0 </span>了，说明这个客户端已经不再持有锁了，此时就会用：<span class="s114">“del myLock”</span><span class="s111">命令</span>，从 <span class="s113">redis </span>里删除这个 <span class="s113">key</span>。然后呢，另外的客户端 <span class="s113">2 </span>就可以尝试完成加锁了。这就是所谓的<span class="s111">分布式锁的开源 </span><span class="s114">Redisson </span><span class="s111">框架的实现机制。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">一般我们在生产系统中，可以用 <span class="s113">Redisson </span>框架提供的这个类库来基于 <span class="s113">redis </span>进行分布式锁的加锁与释放锁。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="33."><p class="s111" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">上述 <span class="s114">Redis </span>分布式锁的缺点</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">其实上面那种方案最大的问题，就是如果你对某个 <span class="s113">redis master </span>实例，写入了 <span class="s113">myLock </span>这种锁 <span class="s113">key </span>的 <span class="s113">value</span>，此时会异步复制给对应的 <span class="s113">master slave </span>实例。但是这个过程中一旦发生 <span class="s113">redis m aster </span>宕机，主备切换，<span class="s113">redis slave </span>变为了 <span class="s113">redis master</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: justify;">接着就会导致，客户端 <span class="s113">2 </span>来尝试加锁的时候，在新的 <span class="s113">redis master </span>上完成了加锁，而客户端 <span class="s113">1</span>也以为自己成功加了锁。此时就会导致多个客户端对一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题，<span class="s111">导致各种脏数据的产生</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s112" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">所以这个就是 <span class="s113">redis cluster</span>，或者是 <span class="s113">redis master-slave </span>架构的主从异步复制导致的 <span class="s113">redis </span>分布式锁的最大缺陷：<span class="s111">在 </span><span class="s114">redis master </span><span class="s111">实例宕机的时候，可能导致多个客户端同时完成加锁</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="34."><p class="s115" style="padding-left: 36pt;text-indent: -13pt;text-align: justify;">使用过 Redis 分布式锁么，它是怎么实现的？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 94%;text-align: left;">先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</p><p class="s110" style="padding-left: 1pt;text-indent: 0pt;line-height: 16pt;text-align: left;">set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！</p><p class="s110" style="padding-top: 3pt;padding-left: 1pt;text-indent: 0pt;text-align: left;">35.<span class="s115">使用过 Redis 做异步队列么，你是怎么用的？有什么缺点？</span></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="562" alt="image" src="整合_files/Image_354.png"/></span></p><p class="s110" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">一会再重试。缺点：</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。能不能生产一次消费多次呢？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">使用 pub/sub 主题订阅者模式，可以实现 1:N 的消息队列。</p><p class="s110" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">36.<span class="s115">什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</span></p><p class="s110" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">缓存穿透</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value，就应该去后端系统查找（比如 DB）。一些恶意的请求会故意查询不存在的 key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">如何避免？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理缓存。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">2：对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过该 bitmap 过滤。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">缓存雪崩</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">如何避免？</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">2：做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期</p><p class="s110" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">3：不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">问题一</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 <span class="s84">Spring Boot</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">多年来，随着新功能的增加，<span class="s84">spring </span>变得越来越复杂。只需访问 <span class="s84">https://spring.io/projects </span>页面，我们就会看到可以在我们的应用程序中使用的所有 <span class="s84">Spring </span>项目的不同功能。如果必须启动一个新的 <span class="s84">Spring </span>项目，我们必须添加构建路径或添加 <span class="s84">Maven </span>依赖关系，配置应用程序服务器，添加 <span class="s84">spring </span>配置。因此，开始一个新的 <span class="s84">spring </span>项目需要很多努力，因为我们现在必须从头开始做所有事情。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Spring  Boot <span class="p">是解决这个问题的方法。</span>Spring  Boot <span class="p">已经建立在现有 </span>spring <span class="p">框架之上。使用 </span>spring <span class="p">启动，我们避免了之前我们必须做的所有样板代码和配置。因此，</span>Spring  Boot <span class="p">可以帮助我们以最少的工作量，更加健壮地使用现有的 </span>Spring <span class="p">功能。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题二</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">Spring Boot <span class="p">有哪些优点？ </span>Spring Boot <span class="p">的优点有：</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">减少开发，测试时间和努力。</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">使用 <span class="s84">JavaConfig </span>有助于避免使用 <span class="s84">XML</span>。 避免大量的 <span class="s84">Maven </span>导入和各种版本冲突。提供意见发展方法。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">通过提供默认值快速开始开发。</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">没有单独的 <span class="s84">Web </span>服务器需要。这意味着你不再需要启动 <span class="s84">Tomcat</span>，<span class="s84">Glassfish </span>或其他任何东西。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">需要更少的配置 因为没有 <span class="s84">web.xml </span>文件。只需添加用<span class="s84">@ Configuration </span>注释的类，然后添加用<span class="s84">@Bean </span>注释的方法，<span class="s84">Spring </span>将自动加载对象并像以前一样对其进行管理。您甚至可以将 <span class="s84">@Autowired </span>添加到 <span class="s84">bean </span>方法中，以使 <span class="s84">Spring </span>自动装入需要的依赖关系中。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：<span class="s84">- Dspring.profiles.active   =   {enviornment}</span>。在加载主应用程序属性文件后，<span class="s84">Spring </span>将在</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">（<span class="s84">application{environment} .properties</span>）中加载后续的应用程序属性文件。问题三</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">什么是 <span class="s84">JavaConfig</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Spring JavaConfig <span class="p">是 </span>Spring <span class="p">社区的产品，它提供了配置 </span>Spring IoC <span class="p">容器的纯 </span>Java <span class="p">方法。因此它有助于避免使用 </span>XML <span class="p">配置。使用 </span>JavaConfig <span class="p">的优点在于：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">面向对象的配置。由于配置被定义为 <span class="s84">JavaConfig </span>中的类，因此用户可以充分利用 <span class="s84">Java </span>中的面向对象功能。一个配置类可以继承另一个，重写它的<span class="s84">@Bean </span>方法等。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">减少或消除 <span class="s84">XML </span>配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">员不希望在 <span class="s84">XML </span>和 <span class="s84">Java </span>之间来回切换。<span class="s84">JavaConfig </span>为开发人员提供了一种纯 <span class="s84">Java </span>方法来配置与 <span class="s84">XML </span>配置概念相似的 <span class="s84">Spring </span>容器。从技术角度来讲，只使用 <span class="s84">JavaConfig </span>配置类来配置容器是可行的，但实际上很多人认为将 <span class="s84">JavaConfig </span>与 <span class="s84">XML </span>混合匹配是理想的。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">类型安全和重构友好。<span class="s84">JavaConfig </span>提供了一种类型安全的方法来配置 <span class="s84">Spring </span>容器。由于 <span class="s84">Java  5.0 </span>对泛型的支持，现在可以按类型而不是按名称检索 <span class="s84">bean</span>，不需要任何强制转换或基于字符串的查找。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题四</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">如何重新加载 <span class="s84">Spring Boot </span>上的更改，而无需重新启动服务器？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">这可以使用 <span class="s84">DEV </span>工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式 <span class="s84">tomcat</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">将重新启动。<span class="s84">Spring  Boot </span>有一个开发工具（<span class="s84">DevTools</span>）模块，它有助于提高开发人员的生产力。<span class="s84">Java </span>开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 <span class="s84">Spring Boot </span>上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。<span class="s84">Spring Boot </span>在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。<span class="s84">DevTools </span>模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 <span class="s84">H2 </span>数据库控制台以更好地测试应用程序。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">org.springframework.boot spring-boot-devtools true</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">问题五</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring Boot <span class="p">中的监视器是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Spring boot actuator <span class="p">是 </span>spring <span class="p">启动框架中的重要功能之一。</span>Spring boot <span class="p">监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 </span>HTTP URL <span class="p">访问的 </span>REST <span class="p">端点来检查状态。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题六</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">如何在 <span class="s84">Spring Boot </span>中禁用 <span class="s84">Actuator </span>端点安全性？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">默认情况下，所有敏感的 <span class="s84">HTTP </span>端点都是安全的，只有具有 <span class="s84">ACTUATOR </span>角色的用户才能访问它们。安全性是使用标准的 <span class="s84">HttpServletRequest.isUserInRole </span>方法实施的。 我们可以使用</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">management.security.enabled = false</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。问题七</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">如何在自定义端口上运行 <span class="s84">Spring Boot </span>应用程序？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">为了在自定义端口上运行 <span class="s84">Spring  Boot </span>应用程序，您可以在 <span class="s84">application.properties </span>中指定端</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">口。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">server.port = 8090</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题八</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 <span class="s84">YAML</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">YAML <span class="p">是一种人类可读的数据序列化语言。它通常用于配置文件。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">与属性文件相比，如果我们想要在配置文件中添加复杂的属性，<span class="s84">YAML </span>文件就更加结构化，而且更少混淆。可以看出 <span class="s84">YAML </span>具有分层配置数据。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题九</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">如何实现 <span class="s84">Spring Boot </span>应用程序的安全性？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">为了实现 <span class="s84">Spring Boot </span>的安全性，我们使用 <span class="s84">spring-boot-starter-security </span>依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展 <span class="s84">WebSecurityConfigurerAdapter </span>并覆盖其方法。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">如何集成 <span class="s84">Spring Boot </span>和 <span class="s84">ActiveMQ</span>？</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">对于集成 <span class="s84">Spring Boot </span>和 <span class="s84">ActiveMQ</span>，我们使用 <span class="s84">spring-boot-starter-activemq</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">依赖关系。 它只需要很少的配置，并且不需要样板代码。问题十一</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">如何使用 <span class="s84">Spring Boot </span>实现分页和排序？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">使用 <span class="s84">Spring Boot </span>实现分页非常简单。使用 <span class="s84">Spring Data-JPA </span>可以实现将可分页的</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">org.springframework.data.domain.Pageable</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">传递给存储库方法。问题十二</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">什么是 <span class="s84">Swagger</span>？你用 <span class="s84">Spring Boot </span>实现了它吗？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Swagger <span class="p">广泛用于可视化 </span>API<span class="p">，使用 </span>Swagger UI <span class="p">为前端开发人员提供在线沙箱。</span>Swagger <span class="p">是</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">用于生成 <span class="s84">RESTful  Web </span>服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 <span class="s84">Swagger </span>正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，<span class="s84">Swagger </span>消除了调用服务时的猜测。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十三</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 <span class="s84">Spring Profiles</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Spring  Profiles <span class="p">允许用户根据配置文件（</span>dev<span class="p">，</span>test<span class="p">，</span>prod <span class="p">等）来注册 </span>bean<span class="p">。因此，当应用程序在开发中运行时，只有某些 </span>bean <span class="p">可以加载，而在 </span>PRODUCTION <span class="p">中，某些其他 </span>bean <span class="p">可以加载。假设我们的要求是 </span>Swagger <span class="p">文档仅适用于 </span>QA <span class="p">环境，并且禁用所有其他文档。这可以使用配置文件来完成。</span>Spring Boot <span class="p">使得使用配置文件非常简单。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十四</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 <span class="s84">Spring Batch</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Spring Boot Batch <span class="p">提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志</span>/<span class="p">跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十五</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 <span class="s84">FreeMarker </span>模板？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">FreeMarker <span class="p">是一个基于 </span>Java <span class="p">的模板引擎，最初专注于使用 </span>MVC <span class="p">软件架构进行动态网页生成。使用 </span>Freemarker <span class="p">的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 </span>html <span class="p">页面设计。最后使用 </span>freemarker <span class="p">可以将这些结合起来，给出最终的输出页面。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十六</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">如何使用 <span class="s84">Spring Boot </span>实现异常处理？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring <span class="p">提供了一种使用 </span>ControllerAdvice <span class="p">处理异常的非常有用的方法。 我们通过实现一个</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">ControlerAdvice <span class="p">类，来处理控制器类抛出的所有异常。问题十七</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">您使用了哪些 <span class="s84">starter maven </span>依赖项？使用了下面的一些依赖项</p><p class="s84" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">spring-boot-starter-activemq spring-boot-starter-security spring-boot-starter-web</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">这有助于增加更少的依赖关系，并减少版本的冲突。问题十八</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">什么是 <span class="s84">CSRF </span>攻击？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">CSRF <span class="p">代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的 </span>Web <span class="p">应用程序上执行不需要的操作。</span>CSRF <span class="p">攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题十九</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 <span class="s84">WebSockets</span>？</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">WebSocket <span class="p">是一种计算机通信协议，通过单个 </span>TCP <span class="p">连接提供全双工通信信道。 </span>WebSocket <span class="p">是双向的 </span>-<span class="p">使用 </span>WebSocket <span class="p">客户端或服务器可以发起消息发送。</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">WebSocket <span class="p">是全双工的 </span>-<span class="p">客户端和服务器通信是相互独立的。</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">单个 <span class="s84">TCP </span>连接 <span class="s84">-</span>初始连接使用 <span class="s84">HTTP</span>，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">Light -<span class="p">与 </span>http <span class="p">相比，</span>WebSocket <span class="p">消息数据交换要轻得多。问题二十</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">什么是 <span class="s84">AOP</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">在软件开发过程中，跨越应用程序多个点的功能称为交叉问题。这些交叉问题与应用程序的主要业务逻辑不同。因此，将这些横切关注与业务逻辑分开是面向方面编程（<span class="s84">AOP</span>）的地方。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题二十一</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 <span class="s84">Apache Kafka</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Apache Kafka <span class="p">是一个分布式发布 </span>- <span class="p">订阅消息系统。它是一个可扩展的，容错的发布 </span>- <span class="p">订阅消息系统，它使我们能够构建分布式应用程序。这是一个 </span>Apache <span class="p">顶级项目。</span>Kafka <span class="p">适合离线和在线消息消费。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题二十二</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">我们如何监视所有 <span class="s84">Spring Boot </span>微服务？</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Spring Boot <span class="p">提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 <span class="s84">50 </span>个应用程序的微服务，管理员将不得不击中所有 <span class="s84">50 </span>个应用程序的执行终端。</p><p class="s6" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">问题一：</p><p class="s6" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 Spring Cloud？</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成。</p><p class="s7" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s6" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题二：</p><p class="s6" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">使用 Spring Cloud 有什么优势？</p><p class="s7" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">使用 Spring Boot 开发分布式微服务时，我们面临以下问题</p></li><li data-list-text=""><p class="s7" style="padding-top: 8pt;padding-left: 40pt;text-indent: -18pt;text-align: left;">与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</p></li><li data-list-text=""><p class="s7" style="padding-top: 8pt;padding-left: 40pt;text-indent: -18pt;line-height: 94%;text-align: left;">服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</p></li><li data-list-text=""><p class="s7" style="padding-top: 8pt;padding-left: 40pt;text-indent: -18pt;text-align: left;">冗余-分布式系统中的冗余问题。</p></li><li data-list-text=""><p class="s7" style="padding-top: 8pt;padding-left: 40pt;text-indent: -18pt;line-height: 94%;text-align: left;">负载平衡 --负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</p></li><li data-list-text=""><p class="s7" style="padding-top: 8pt;padding-left: 40pt;text-indent: -18pt;text-align: left;">性能-问题 由于各种运营开销导致的性能问题。</p></li><li data-list-text=""><p class="s7" style="padding-top: 7pt;padding-left: 40pt;text-indent: -18pt;text-align: left;">部署复杂性-Devops 技能的要求。</p><p class="s6" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">问题三：</p><p class="s6" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">服务注册和发现是什么意思？Spring Cloud 如何实现？</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s6" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题四：</p><p class="s6" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">负载平衡的意义什么？</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s6" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">问题五：</p><p class="s6" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 Hystrix？它如何实现容错？</p><p class="s7" style="padding-top: 2pt;padding-left: 23pt;text-indent: 2pt;line-height: 94%;text-align: left;">Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 148%;text-align: left;">通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。思考以下微服务</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">假设如果上图中的微服务 9 失败了，那么使用传统方法我们将传播一个异常。但这仍然会导致整个系统崩溃。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达 1000.这是 hystrix 出现的地方我们将使用 Hystrix 在这种情况下的 Fallback 方法功能。我们有两个服务 employee-consumer 使用由 employee-consumer 公开的服务。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">简化图如下所示</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">现在假设由于某种原因，employee-producer 公开的服务会抛出异常。我们在这种情况下使用 Hystrix定义了一个回退方法。这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。</p><p class="s6" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">问题六：</p><p class="s6" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 Hystrix 断路器？我们需要它吗？</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用 Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s7" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">如果 firstPage method() 中的异常继续发生，则 Hystrix 电路将中断，并且员工使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。</p><p class="s6" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">问题七：</p><p class="s6" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 Netflix Feign？它的优点是什么？</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 2pt;line-height: 94%;text-align: left;">Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程序。Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定性。在 employee-consumer 的例子中，我们使用了 employee-producer 使用 REST 模板公开的 REST 服务。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">但是我们必须编写大量代码才能执行以下步骤</p></li><li data-list-text=""><p class="s7" style="padding-top: 8pt;padding-left: 40pt;text-indent: -18pt;text-align: left;">使用功能区进行负载平衡。</p></li><li data-list-text=""><p class="s7" style="padding-top: 7pt;padding-left: 40pt;text-indent: -18pt;text-align: left;">获取服务实例，然后获取基本 URL。</p></li><li data-list-text=""><p class="s7" style="padding-top: 7pt;padding-left: 40pt;text-indent: -18pt;text-align: left;">利用 REST 模板来使用服务。 前面的代码如下</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l99"><li data-list-text="1."><p class="s116" style="padding-left: 27pt;text-indent: -18pt;text-align: left;">@Controller</p></li><li data-list-text="2."><p style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 167%;text-align: left;"><span class="s117">public</span><span><img width="6" height="13" alt="image" src="整合_files/Image_359.png"/></span><span class="s117">class </span><span class="s118">ConsumerControllerClient </span><span class="s119" style=" background-color: #FAFAFA;">{</span><span class="s120"> 3.</span></p></li></ol><ol id="l100"><li data-list-text="4."><p class="s116" style="padding-left: 27pt;text-indent: -18pt;line-height: 9pt;text-align: left;">@Autowired</p></li><li data-list-text="5."><p style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 167%;text-align: left;"><span class="s117">private</span><span class="s119" style=" background-color: #FAFAFA;"> LoadBalancerClient loadBalancer;</span><span class="s120"> 6.</span></p></li></ol><p style="padding-left: 9pt;text-indent: 0pt;line-height: 167%;text-align: left;"><span class="s120">7. </span><span class="s117">public void </span><span class="s116">getEmployee</span><span class="s120">() </span><span class="s117">throws </span><span class="s120">RestClientException, IOException </span><span class="s119" style=" background-color: #FAFAFA;">{</span><span class="s120"> 8.</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 167%;text-align: left;"><span class="s120">9. </span><span class="s119" style=" background-color: #FAFAFA;">  ServiceInstance serviceInstance=loadBalancer.choose(</span><span class="s121">&quot;employee-producer&quot;</span><span class="s119" style=" background-color: #FAFAFA;">);</span><span class="s120"> 10.</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 167%;text-align: left;"><span class="s120">11. </span><span class="s119" style=" background-color: #FAFAFA;">  System.out.println(serviceInstance.getUri());</span><span class="s120"> 12.</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 167%;text-align: left;"><span class="s120">13. </span><span class="s119" style=" background-color: #FAFAFA;">  String baseUrl=serviceInstance.getUri().toString();</span><span class="s120"> 14.</span></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 167%;text-align: left;"><span class="s120">15. </span><span class="s119" style=" background-color: #FAFAFA;"> baseUrl=baseUrl+</span><span class="s121">&quot;/employee&quot;</span><span class="s119" style=" background-color: #FAFAFA;">;</span><span class="s120"> 16.</span></p><ol id="l101"><li data-list-text="17."><p style="padding-left: 27pt;text-indent: -18pt;line-height: 9pt;text-align: left;"><span class="s119" style=" background-color: #FAFAFA;">  RestTemplate restTemplate = </span><span class="s117">new</span><span class="s119" style=" background-color: #FAFAFA;"> RestTemplate();</span></p></li><li data-list-text="18."><p style="padding-top: 5pt;padding-left: 27pt;text-indent: -18pt;text-align: left;"><span class="s119" style=" background-color: #FAFAFA;">  ResponseEntity&lt;String&gt; response=</span><span class="s117">null</span><span class="s119" style=" background-color: #FAFAFA;">;</span></p></li><li data-list-text="19."><p style="padding-top: 6pt;padding-left: 22pt;text-indent: -13pt;text-align: left;"><span><img width="24" height="13" alt="image" src="整合_files/Image_360.png"/></span><span class="s117">try</span><span class="s119" style=" background-color: #FAFAFA;">{</span></p></li><li data-list-text="20."><p style="padding-top: 6pt;padding-left: 27pt;text-indent: -18pt;text-align: left;"><span class="s119" style=" background-color: #FAFAFA;">  response=restTemplate.exchange(baseUrl,</span></p></li><li data-list-text="21."><p style="padding-top: 6pt;padding-left: 27pt;text-indent: -18pt;text-align: left;"><span class="s119" style=" background-color: #FAFAFA;">     HttpMethod.GET, getHeaders(),String.class);</span></p></li><li data-list-text="22."><p style="padding-top: 6pt;padding-left: 27pt;text-indent: -18pt;text-align: left;"><span class="s119" style=" background-color: #FAFAFA;">  }</span><span class="s117">catch</span><span class="s119" style=" background-color: #FAFAFA;"> (Exception ex)</span></p></li></ol><p style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;"><span class="s120">23. </span><span class="s119" style=" background-color: #FAFAFA;">  {</span></p><p style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;"><span class="s120">24. </span><span class="s119" style=" background-color: #FAFAFA;">   System.out.println(ex);</span></p><p style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;"><span class="s120">25. </span><span class="s119" style=" background-color: #FAFAFA;">  }</span></p><ol id="l102"><li data-list-text="26."><p style="padding-top: 6pt;padding-left: 27pt;text-indent: -18pt;text-align: left;"><span class="s119" style=" background-color: #FAFAFA;">  System.out.println(response.getBody());</span></p><p style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;text-align: left;"><span class="s120">27. </span><span class="s119" style=" background-color: #FAFAFA;">}</span></p><p class="s7" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">之前的代码，有像 NullPointer 这样的例外的机会，并不是最优的。我们将看到如何使用 Netflix Feign使呼叫变得更加轻松和清洁。如果 Netflix Ribbon 依赖关系也在类路径中，那么 Feign 默认也会负责负载平衡。</p><p class="s6" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">问题八：</p><p class="s6" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 Spring Cloud Bus？我们需要它吗？</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而 Spring Cloud Config 从 GIT 读取这些属性。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka 注册的财产。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生什么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。</p><p class="s7" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: justify;">还有另一种使用执行器端点/刷新的方式。但是我们将不得不为每个模块单独调用这个 url。例如，如果 Employee Producer1 部署在端口 8080 上，则调用 http：// localhost：8080 / refresh。同样对于 Employee Producer2 http：// localhost：8081 / refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥作用的地方。</p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微服务，并且它们也会刷新。可以通过使用端点/总线/刷新来实现对任何单个实例的刷新。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1<span class="p">、什么是 </span>SpringMvc<span class="p">？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：<span class="s84">SpringMvc </span>是 <span class="s84">spring </span>的一个模块，基于 <span class="s84">MVC </span>的一个框架，无需中间整合层来整合。 <span class="s84">2</span>、<span class="s84">Spring MVC </span>的优点：</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">答：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l103"><li data-list-text="1）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">它是基于组件技术的<span class="s84">.</span>全部的应用对象<span class="s84">,</span>无论控制器和视图<span class="s84">,</span>还是业务对象之类的都是 <span class="s84">java</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">组件<span class="s84">.</span>并且和 <span class="s84">Spring </span>提供的其他基础结构紧密集成<span class="s84">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p style="padding-left: 41pt;text-indent: -15pt;text-align: left;">不依赖于 <span class="s84">Servlet API(</span>目标虽是如此<span class="s84">,</span>但是在实现的时候确实是依赖于 <span class="s84">Servlet </span>的<span class="s84">)</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3）"><p style="padding-left: 41pt;text-indent: -15pt;text-align: left;">可以任意使用各种视图技术<span class="s84">,</span>而不仅仅局限于 <span class="s84">JSP</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4）"><p style="padding-left: 41pt;text-indent: -15pt;text-align: left;">支持各种请求资源的映射策略</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5）"><p style="padding-left: 41pt;text-indent: -15pt;text-align: left;">它应是易于扩展的</p></li></ol></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">3<span class="p">、</span>SpringMVC <span class="p">工作原理？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l104"><li data-list-text="1）"><p style="padding-left: 41pt;text-indent: -15pt;text-align: left;">客户端发送请求到 <span class="s84">DispatcherServlet</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p class="s84" style="padding-left: 25pt;text-indent: 0pt;line-height: 231%;text-align: left;">DispatcherServlet <span class="p">查询 </span>handlerMapping <span class="p">找到处理请求的 </span>Controller 3<span class="p">）</span>Controller <span class="p">调用业务逻辑后，返回 </span>ModelAndView 4<span class="p">）</span>DispatcherServlet <span class="p">查询 </span>ModelAndView<span class="p">，找到指定视图 </span>5<span class="p">）视图将结果返回到客户端</span></p></li></ol><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">4<span class="p">、</span>SpringMVC <span class="p">流程？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 25pt;text-indent: 0pt;line-height: 231%;text-align: left;">1<span class="p">）用户发送请求至前端控制器 </span>DispatcherServlet<span class="p">。 </span>2<span class="p">）</span>DispatcherServlet <span class="p">收到请求调用 </span>HandlerMapping <span class="p">处理器映射器。</span></p><ol id="l105"><li data-list-text="3）"><p style="padding-left: 23pt;text-indent: 2pt;line-height: 115%;text-align: left;">处理器映射器找到具体的处理器<span class="s84">(</span>可以根据 <span class="s84">xml </span>配置、注解进行查找<span class="s84">)</span>，生成处理器对象及处理器拦截器<span class="s84">(</span>如果有则生成<span class="s84">)</span>一并返回给 <span class="s84">DispatcherServlet</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4）"><p class="s84" style="padding-left: 41pt;text-indent: -15pt;text-align: left;">DispatcherServlet <span class="p">调用 </span>HandlerAdapter <span class="p">处理器适配器。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5）"><p class="s84" style="padding-left: 41pt;text-indent: -15pt;text-align: left;">HandlerAdapter <span class="p">经过适配调用具体的处理器</span>(Controller<span class="p">，也叫后端控制器</span>)<span class="p">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="6）"><p class="s84" style="padding-left: 41pt;text-indent: -15pt;text-align: left;">Controller <span class="p">执行完成返回 </span>ModelAndView<span class="p">。</span></p></li><li data-list-text="7）"><p class="s84" style="padding-top: 2pt;padding-left: 25pt;text-indent: 0pt;line-height: 231%;text-align: left;">HandlerAdapter <span class="p">将 </span>controller <span class="p">执行结果 </span>ModelAndView <span class="p">返回给 </span>DispatcherServlet<span class="p">。 </span>8<span class="p">）</span>DispatcherServlet <span class="p">将 </span>ModelAndView <span class="p">传给 </span>ViewReslover <span class="p">视图解析器。 </span>9<span class="p">）</span>ViewReslover <span class="p">解析后返回具体 </span>View<span class="p">。</span></p></li></ol><ol id="l106"><li data-list-text="10）"><p class="s84" style="padding-left: 46pt;text-indent: -21pt;line-height: 13pt;text-align: left;">DispatcherServlet <span class="p">根据 </span>View <span class="p">进行渲染视图（即将模型数据填充至视图中）。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="11）"><p class="s84" style="padding-left: 46pt;text-indent: -21pt;text-align: left;">DispatcherServlet <span class="p">响应用户。</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">6<span class="p">、</span>SpringMvc <span class="p">的控制器是不是单例模式</span>,<span class="p">如果是</span>,<span class="p">有什么问题</span>,<span class="p">怎么解决？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：是单例模式<span class="s84">,</span>所以在多线程访问的时候有线程安全问题<span class="s84">,</span>不要用同步<span class="s84">,</span>会影响性能的<span class="s84">,</span>解决方案是在控制器里面不能写字段。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">7<span class="p">、如果你也用过 </span>struts2.<span class="p">简单介绍下 </span>springMVC <span class="p">和 </span>struts2 <span class="p">的区别有哪些</span>?<span class="p">答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l107"><li data-list-text="1）"><p class="s84" style="padding-left: 41pt;text-indent: -15pt;text-align: left;">springmvc <span class="p">的入口是一个 </span>servlet <span class="p">即前端控制器，而 </span>struts2 <span class="p">入口是一个 </span>filter <span class="p">过虑器。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p class="s84" style="padding-left: 23pt;text-indent: 2pt;line-height: 115%;text-align: left;">springmvc <span class="p">是基于方法开发</span>(<span class="p">一个 </span>url <span class="p">对应一个方法</span>)<span class="p">，请求参数传递到方法的形参，可以设计为单例或多例</span>(<span class="p">建议单例</span>)<span class="p">，</span>struts2 <span class="p">是基于类开发，传递参数是通过类的属性，只能设计为多例。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3）"><p class="s84" style="padding-left: 23pt;text-indent: 2pt;line-height: 115%;text-align: left;">Struts <span class="p">采用值栈存储请求和响应的数据，通过 </span>OGNL <span class="p">存取数据，</span>springmvc <span class="p">通过参数解 析器是将 </span>request <span class="p">请求内容解析，并给方法形参赋值，将数据和视图封装成 </span>ModelAndView<span class="p">对象，最后又将 </span>ModelAndView <span class="p">中的模型数据通过 </span>reques <span class="p">域传输到页面。</span>Jsp <span class="p">视图解析器默认使用 </span>jstl<span class="p">。</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">8<span class="p">、</span>SpingMvc <span class="p">中的控制器的注解一般用那个</span>,<span class="p">有没有别的注解可以替代？答：一般用</span>@Conntroller <span class="p">注解</span>,<span class="p">表示是表现层</span>,<span class="p">不能用用别的注解代替。 </span>9<span class="p">、 </span>@RequestMapping <span class="p">注解用在类上面有什么作用？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">10<span class="p">、怎么样把某个请求映射到特定的方法上面？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">答：直接在方法上面加上注解<span class="s84">@RequestMapping,</span>并且在这个注解里面写上要拦截的路径</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">11<span class="p">、如果在拦截请求中</span>,<span class="p">我想拦截 </span>get <span class="p">方式提交的方法</span>,<span class="p">怎么配置？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：可以在<span class="s84">@RequestMapping </span>注解里面加上 <span class="s84">method=RequestMethod.GET 12</span>、怎么样在方法里面得到 <span class="s84">Request,</span>或者 <span class="s84">Session</span>？</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">答：直接在方法的形参中声明 <span class="s84">request,SpringMvc </span>就自动把 <span class="s84">request </span>对象传入</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">13<span class="p">、我想在拦截的方法里面得到从前台传入的参数</span>,<span class="p">怎么得到？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">答：直接在形参里面声明这个参数就可以<span class="s84">,</span>但必须名字和传过来的参数一样</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">14<span class="p">、如果前台有很多个参数传入</span>,<span class="p">并且这些参数都是一个对象的</span>,<span class="p">那么怎么样快速得到这个对象？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">答：直接在方法中声明这个对象<span class="s84">,SpringMvc </span>就自动会把属性赋值到这个对象里面。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">15<span class="p">、</span>SpringMvc <span class="p">中函数的返回值是什么？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">答：返回值可以有很多类型<span class="s84">,</span>有 <span class="s84">String, ModelAndView,</span>当一般用 <span class="s84">String </span>比较好。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">16<span class="p">、</span>SpringMVC <span class="p">怎么样设定重定向和转发的？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：在返回值前面加<span class="s84">&quot;forward:&quot;</span>就可以让结果转发<span class="s84">,</span>譬如<span class="s84">&quot;forward:user.do?name=method4&quot; </span>在返回值前面加<span class="s84">&quot;redirect:&quot;</span>就可以让返回值重定向<span class="s84">,</span>譬如<a href="http://www.baidu.com/" class="s122" target="_blank">&quot;redirect:http://www.baid</a><span class="s84">u.com&quot;</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">17<span class="p">、</span>SpringMvc <span class="p">用什么对象从后台向前台传递数据的？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：通过 <span class="s84">ModelMap </span>对象<span class="s84">,</span>可以在这个对象里面用 <span class="s84">put </span>方法<span class="s84">,</span>把对象加到里面<span class="s84">,</span>前台就可以通过 <span class="s84">el </span>表达式拿到。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">18<span class="p">、</span>SpringMvc <span class="p">中有个类把视图和数据都合并的一起的</span>,<span class="p">叫什么？答：叫 </span>ModelAndView<span class="p">。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">19<span class="p">、怎么样把 </span>ModelMap <span class="p">里面的数据放入 </span>Session <span class="p">里面？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：可以在类上面加上<span class="s84">@SessionAttributes </span>注解<span class="s84">,</span>里面包含的字符串就是要放入 <span class="s84">session </span>里面的 <span class="s84">key</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">20<span class="p">、</span>SpringMvc <span class="p">怎么和 </span>AJAX <span class="p">相互调用的？答：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 25pt;text-indent: -2pt;line-height: 231%;text-align: left;">通过 <span class="s84">Jackson </span>框架就可以把 <span class="s84">Java </span>里面的对象直接转化成 <span class="s84">Js </span>可以识别的 <span class="s84">Json </span>对象。具体步骤如下 ：</p><p class="s84" style="padding-left: 34pt;text-indent: 0pt;line-height: 231%;text-align: left;">1<span class="p">）加入 </span>Jackson.jar      2<span class="p">）在配置文件中配置 </span>json <span class="p">的映射</span></p><p class="s84" style="padding-left: 34pt;text-indent: 0pt;line-height: 13pt;text-align: left;">3<span class="p">）在接受 </span>Ajax <span class="p">方法里面可以直接返回 </span>Object,List <span class="p">等</span>,<span class="p">但方法前面要加上</span>@ResponseBody</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">注解</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">21<span class="p">、当一个方法向 </span>AJAX <span class="p">返回特殊对象</span>,<span class="p">譬如 </span>Object,List <span class="p">等</span>,<span class="p">需要做什么处理？答：要加上</span>@ResponseBody <span class="p">注解</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">22<span class="p">、</span>SpringMvc <span class="p">里面拦截器是怎么写的</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：有两种写法<span class="s84">,</span>一种是实现接口<span class="s84">,</span>另外一种是继承适配器类<span class="s84">,</span>然后在 <span class="s84">SpringMvc </span>的配置文件中配置拦截器即可：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;!-- <span class="p">配置 </span>SpringMvc <span class="p">的拦截器 </span>--&gt;</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;mvc:interceptors&gt;</p><p class="s84" style="padding-top: 2pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">&lt;!-- <span class="p">配置一个拦截器的 </span>Bean <span class="p">就可以了 默认是对所有请求都拦截 </span>--&gt;</p><p class="s84" style="padding-top: 2pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">&lt;bean id=&quot;myInterceptor&quot; class=&quot;com.et.action.MyHandlerInterceptor&quot;&gt;&lt;/bean&gt;</p><p class="s84" style="padding-top: 2pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">&lt;!-- <span class="p">只针对部分请求拦截 </span>--&gt;</p><p class="s84" style="padding-top: 2pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">&lt;mvc:interceptor&gt;</p><p class="s84" style="padding-top: 2pt;padding-left: 65pt;text-indent: 0pt;text-align: left;">&lt;mvc:mapping path=&quot;/modelMap.do&quot; /&gt;</p><p class="s84" style="padding-top: 2pt;padding-left: 65pt;text-indent: 0pt;text-align: left;">&lt;bean class=&quot;com.et.action.MyHandlerInterceptorAdapter&quot; /&gt;</p><p class="s84" style="padding-top: 2pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">&lt;/mvc:interceptor&gt;</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;/mvc:interceptors&gt;</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">23<span class="p">、讲下 </span>SpringMvc <span class="p">的执行流程</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">答：系统启动的时候根据配置文件创建 <span class="s84">spring </span>的容器<span class="s84">, </span>首先是发送 <span class="s84">http </span>请求到核心控制器 <span class="s84">disPatherServlet</span>，<span class="s84">spring </span>容器通过映射器去寻找业务控制器，使用适配器找到相应的业务 类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用 <span class="s84">ModelAndView </span>进行视图转发，数据放在 <span class="s84">model </span>中，用 <span class="s84">map </span>传递数据进行页面显示。</p><p class="s123" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">以下为 <span class="s124">spring </span>常见面试问题：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">1<span class="s126">、什么是 </span>Spring <span class="s126">框架？</span>Spring <span class="s126">框架有哪些主要模块？</span></p><p class="s124" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring <span class="s123">框架是一个为 </span>Java <span class="s123">应用程序的开发提供了综合、广泛的基础性支持的 </span>Java <span class="s123">平台。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s124" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring <span class="s123">帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。</span></p><p class="s124" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">Spring <a href="http://www.amazon.cn/gp/product/B001130JN8/ref%3Das_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=importnew-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B001130JN8" class="s135" target="_blank">框架本身亦是按照</a><span style=" color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 9.5pt;">设计模式</span><span class="s123">精心打造，这使得我们可以在开发环境中安心的集成 </span>Spring <span class="s123">框架，不必担心 </span>Spring <span class="s123">是如何在后台进行工作的。</span></p><p class="s124" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">Spring <span class="s123">框架至今已集成了 </span>20 <span class="s123">多个模块。这些模块主要被分如下图所示的核心容器、数据访问</span>/<span class="s123">集成</span>,<span class="s123">、</span>Web<span class="s123">、</span>AOP<span class="s123">（面向切面编程）、工具、消息和测试模块。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">2<span class="s126">、使用 </span>Spring <span class="s126">框架能带来哪些好处？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">下面列举了一些使用 <span class="s124">Spring </span>框架带来的主要好处：</p><ul id="l108"><li data-list-text=""><p class="s124" style="padding-top: 8pt;padding-left: 39pt;text-indent: -18pt;line-height: 127%;text-align: left;"><a href="http://howtodoinjava.com/2013/03/19/inversion-of-control-ioc-and-dependency-injection-di-patterns-in-spring-framework-and-related-interview-questions/" class="s128" target="_blank">Dependency </a><span style=" color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 9.5pt;">Injection(DI)</span> <span class="s123">方法使得构造器和 </span>JavaBean properties <span class="s123">文件中的依赖关系一目了然。</span></p></li><li data-list-text=""><p class="s123" style="padding-left: 39pt;text-indent: -18pt;line-height: 127%;text-align: left;">与 <span class="s124">EJB </span>容器相比较，<span class="s124">IoC </span>容器更加趋向于轻量级。这样一来 <span class="s124">IoC </span>容器在有限的内存和 <span class="s124">CPU </span>资源的情况下进行应用程序的开发和发布就变得十分有利。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s124" style="padding-left: 39pt;text-indent: -18pt;line-height: 127%;text-align: left;">Spring <span class="s123">并没有闭门造车，</span>Spring <span class="s123">利用了已有的技术比如 </span>ORM <span class="s123">框架、</span>logging <span class="s123">框架、</span>J2EE<span class="s123">、</span>Q uartz <span class="s123">和 </span>JDK Timer<span class="s123">，以及其他视图技术。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s124" style="padding-left: 39pt;text-indent: -18pt;line-height: 127%;text-align: left;">Spring <span class="s123">框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s123" style="padding-left: 39pt;text-indent: -18pt;line-height: 127%;text-align: left;"><a href="http://howtodoinjava.com/2013/04/19/how-to-unit-test-spring-security-authentication-with-junit/" class="s135" target="_blank">要</a><a href="http://howtodoinjava.com/2013/04/19/how-to-unit-test-spring-security-authentication-with-junit/" class="s127" target="_blank">测试一项用 </a><a href="http://howtodoinjava.com/2013/04/19/how-to-unit-test-spring-security-authentication-with-junit/" class="s128" target="_blank">Spring </a><span style=" color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 9.5pt;">开发的应用程序</span>十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用 <span class="s124">JavaBean </span>形式的 <span class="s124">POJO </span>类，可以很方便的利用依赖注入来写入测试数据。</p></li><li data-list-text=""><p class="s124" style="padding-left: 39pt;text-indent: -18pt;line-height: 127%;text-align: left;">Spring <span class="s123">的 </span>Web <span class="s123">框架亦是一个精心设计的 </span>Web MVC <span class="s123">框架，为开发者们在 </span>web <span class="s123">框架的选择上提供了一个除了主流框架比如 </span>Struts<span class="s123">、过度设计的、不流行 </span>web <span class="s123">框架的以外的有力选项。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s124" style="padding-left: 39pt;text-indent: -18pt;line-height: 127%;text-align: left;">Spring <span class="s123">提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单 </span>DB <span class="s123">的环境下）和复杂的共同事物处理（比如利用 </span>JTA <span class="s123">的复杂 </span>DB <span class="s123">环境）。</span></p></li></ul><p class="s125" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">3<span class="s126">、什么是控制反转</span>(IOC)<span class="s126">？什么是依赖注入？</span></p><p class="s123" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业 务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系</p><p class="s123" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">图来决定的，该对象关系图由装配 器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过<span class="s124">“</span>依赖注入<span class="s124">”</span>实现的。</p><p class="s123" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。</p><p class="s123" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: justify;">依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？</p><p class="s123" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">在 <span class="s124">Java </span>中依然注入有以下三种实现方式：</p><ol id="l109"><li data-list-text="1."><p class="s123" style="padding-top: 9pt;padding-left: 22pt;text-indent: -18pt;text-align: left;">构造器注入</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s124" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">Setter <span class="s123">方法注入</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s123" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">接口注入</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">4<span class="s126">、请解释下 </span>Spring <span class="s126">框架中的 </span>IoC<span class="s126">？</span></p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s124">Spring </span>中的 <span class="s129">org.springframework.beans </span>包和 <span class="s129">org.springframework.context 包构成了 Spring 框架 IoC 容器的基础。</span></p><p class="s124" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 120%;text-align: left;">BeanFactory <span class="s123">接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。 </span><span class="s129">ApplicationContex 接口对 BeanFactory</span><span class="s123">（是一个子接口）进行了扩展，在 </span>BeanFactory<a href="http://howtodoinjava.com/category/frameworks/java-spring-tutorials/spring-aop/" class="s135" target="_blank">的基础上添加了其他功能，比如与 </a><a href="http://howtodoinjava.com/category/frameworks/java-spring-tutorials/spring-aop/" class="s128" target="_blank">Spring </a><a href="http://howtodoinjava.com/category/frameworks/java-spring-tutorials/spring-aop/" class="s127" target="_blank">的 </a><span style=" color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 9.5pt;">AOP</span> <a href="http://howtodoinjava.com/2015/02/10/spring-mvc-internationalization-i18n-and-localization-i10n-example/" class="s135" target="_blank">更容易集成，也提供了处理 </a><a href="http://howtodoinjava.com/2015/02/10/spring-mvc-internationalization-i18n-and-localization-i10n-example/" class="s128" target="_blank">message resource</a><span style=" color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 9.5pt;">的机制</span><span class="s123">（用于国际化）、事件传播以及应用层的特别配置，比如针对 </span>Web <span class="s123">应用的 </span>WebApplicationContext<span class="s123">。</span></p><p class="s124" style="padding-left: 23pt;text-indent: 0pt;line-height: 111%;text-align: left;"><span class="s19">org.springframework.beans.factory.BeanFactory </span><span class="s130">是 </span>Spring IoC <span class="s123">容器的具体实现，用来包装和管理前面提到的各种 </span>bean<span class="s123">。</span>BeanFactory <span class="s123">接口是 </span>Spring IoC <span class="s123">容器的核心接口。</span></p><p class="s124" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">IOC:<span class="s123">把对象的创建、初始化、销毁交给 </span>spring <span class="s123">来管理，而不是由开发者控制，实现控制反转。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">5<span class="s126">、</span>BeanFactory <span class="s126">和 </span>ApplicationContext <span class="s126">有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s124" style="padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">BeanFactory <span class="s123">可以理解为含有 </span>bean <span class="s123">集合的工厂类。</span>BeanFactory <span class="s123">包含了种 </span>bean <span class="s123">的定义，以便在接收到客户端请求时将对应的 </span>bean <span class="s123">实例化。</span></p><p class="s124" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">BeanFactory <span class="s123">还能在实例化对象的时生成协作类之间的关系。此举将 </span>bean <span class="s123">自身与 </span>bean <span class="s123">客户端的配置中解放出来。</span>BeanFactory <span class="s123">还包含 了 </span>bean <span class="s123">生命周期的控制，调用客户端的初始化方法</span></p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">（<span class="s124">initialization methods</span>）和销毁方法（<span class="s124">destruction methods</span>）。</p><p class="s123" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">从表面上看，<span class="s124">application context </span>如同 <span class="s124">bean factory </span>一样具有 <span class="s124">bean </span>定义、<span class="s124">bean </span>关联关系的设置，根据请求分发 <span class="s124">bean </span>的功能。但 <span class="s124">applicationcontext </span>在此基础上还提供了其他的功能。</p><ol id="l110"><li data-list-text="1."><p class="s123" style="padding-top: 5pt;padding-left: 22pt;text-indent: -18pt;text-align: left;">提供了支持国际化的文本消息</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s123" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">统一的资源文件读取方式</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s123" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">已在监听器中注册的 <span class="s124">bean </span>的事件</p><p class="s123" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">以下是三种较常见的 <span class="s124">ApplicationContext </span>实现方式：</p><p class="s124" style="padding-top: 9pt;padding-bottom: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">1<span class="s123">、</span>ClassPathXmlApplicationContext<span class="s123">：从 </span>classpath <span class="s123">的 </span>XML <span class="s123">配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中</span></p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s124" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2<span class="s123">、</span>FileSystemXmlApplicationContext <span class="s123">：由文件系统中的 </span>XML <span class="s123">配置文件读取上下文。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s124" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">3<span class="s123">、</span>XmlWebApplicationContext<span class="s123">：由 </span>Web <span class="s123">应用的 </span>XML <span class="s123">文件读取上下文。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s124" style="padding-left: 32pt;text-indent: -9pt;text-align: left;">AnnotationConfigApplicationContext(<span class="s123">基于 </span>Java <span class="s123">配置启动容器</span>)</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">6<span class="s126">、</span>Spring <span class="s126">有几种配置方式？</span></p><p class="s123" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">将 <span class="s124">Spring </span>配置到应用开发中有以下三种方式：</p><ol id="l111"><li data-list-text="1."><p class="s123" style="padding-top: 9pt;padding-left: 22pt;text-indent: -18pt;text-align: left;">基于 <span class="s124">XML </span>的配置</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s123" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">基于注解的配置</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s123" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">基于 <span class="s124">Java </span>的配置</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">7<span class="s126">、如何用基于 </span>XML <span class="s126">配置的方式配置 </span>Spring<span class="s126">？</span></p><p class="s123" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 108%;text-align: left;">在 <span class="s124">Spring </span>框架中，依赖和服务需要在专门的配置文件来实现，我常用的 <span class="s124">XML </span>格式的配置文件。这些配置文件的格式通常用<span class="s129">&lt;beans&gt;开头，然后一系列的 bean 定义和专门的应用配置选项组成。</span></p><p class="s124" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">SpringXML <span class="s123">配置的主要目的时候是使所有的 </span>Spring <span class="s123">组件都可以用 </span>xml <span class="s123">文件的形式来进行配置。这意味着不会出现其他的 </span>Spring <span class="s123">配置类型（比如声明的方式或基于 </span>Java Class <span class="s123">的配置方式）</span></p><p class="s124" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring <span class="s123">的 </span>XML <span class="s123">配置方式是使用被 </span>Spring <span class="s123">命名空间的所支持的一系列的 </span>XML <span class="s123">标签来实现的。</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="250" alt="image" src="整合_files/Image_364.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">beans</span>&gt;</p><p class="s133" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;!-- JSON Support --&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 24pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">name</span>=&quot;viewResolver&quot; <span style=" color: #F00;">class</span>=&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;/&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 24pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">name</span>=&quot;jsonTemplate&quot; <span style=" color: #F00;">class</span>=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonV iew&quot;/&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 24pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">id</span>=&quot;restTemplate&quot; <span style=" color: #F00;">class</span>=&quot;org.springframework.web.client.RestTemplate&quot;/&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">beans</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s124" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 174%;text-align: left;">Spring <span class="s123">有以下主要的命名空间：</span>context<span class="s123">、</span>beans<span class="s123">、</span>jdbc<span class="s123">、</span>tx<span class="s123">、</span>aop<span class="s123">、</span>mvc <span class="s123">和 </span>aso<span class="s123">。如：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="208" alt="image" src="整合_files/Image_365.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">web-app</span>&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">display-name</span>&gt;<span style=" color: #000;">Archetype Created Web Application</span>&lt;/<span style=" color: #800000;">display-name</span>&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">servlet</span>&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">servlet-name</span>&gt;<span style=" color: #000;">spring</span>&lt;/<span style=" color: #800000;">servlet-name</span>&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 48pt;text-align: left;">&lt;<span style=" color: #800000;">servlet- class</span>&gt;<span style=" color: #000;">org.springframework.web.servlet.DispatcherServlet</span>&lt;/<span style=" color: #800000;">servlet- class</span>&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">load-on-startup</span>&gt;<span style=" color: #000;">1</span>&lt;/<span style=" color: #800000;">load-on-startup</span>&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">servlet</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-top: 5pt;padding-bottom: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">下面这个 <span class="s124">web.xml </span>仅仅配置了 <span class="s124">DispatcherServlet</span>，这件最简单的配置便能满足应用程序配置运行时组件的需求。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="182" alt="image" src="整合_files/Image_366.png"/></span></p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">servlet-mapping</span>&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">servlet-name</span>&gt;<span style=" color: #000;">spring</span>&lt;/<span style=" color: #800000;">servlet-name</span>&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">url-pattern</span>&gt;<span style=" color: #000;">/</span>&lt;/<span style=" color: #800000;">url-pattern</span>&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">servlet-mapping</span>&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">web-app</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s125" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">8<span class="s126">、如何用基于 </span>Java <span class="s126">配置的方式配置 </span>Spring<span class="s126">？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s124" style="padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">Spring <span class="s123">对 </span>Java <span class="s123">配置的支持是由</span>@Configuration <span class="s123">注解和</span>@Bean <span class="s123">注解来实现的。由</span>@Bean <span class="s123">注解的方法将会实例化、配置和初始化一个 新对象，这个对象将由 </span>Spring <span class="s123">的 </span>IoC <span class="s123">容器来管理。 </span>@Bean <span class="s123">声明所起到的作用与</span>&lt;bean/&gt; <span class="s123">元素类似。被 </span>@Configuration <span class="s123">所注解的类则表示这个类的主要目的是作为 </span>bean <span class="s123">定义的资源。被</span>@Configuration <span class="s123">声明的类可以通过在同一个类的 内部调用</span>@bean <span class="s123">方法来设置嵌入 </span>bean <span class="s123">的依赖关系。</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="223" alt="image" src="整合_files/Image_367.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">@Configuration</p><p class="s19" style="padding-left: 25pt;text-indent: -24pt;text-align: left;">public class AppConfig{ @Bean</p><p class="s19" style="padding-left: 49pt;text-indent: -24pt;text-align: left;">public MyService myService() { return new MyServiceImpl();</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">}</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">最简单的<span class="s124">@Configuration </span>声明类请参考下面的代码：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">对于上面的<span class="s124">@Beans </span>配置文件相同的 <span class="s124">XML </span>配置文件如下：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">beans</span>&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">id</span>=&quot;myService&quot; <span style=" color: #F00;">class</span>=&quot;com.somnus.services.MyServiceImpl&quot;/&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">beans</span>&gt;</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">上述配置方式的实例化方式如下：利用 <span class="s124">AnnotationConfigApplicationContext </span>类进行实例化</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 25pt;text-indent: -24pt;text-align: left;">public static void main(String[] args) { ApplicationContext ctx = new</p><p class="s19" style="padding-left: 25pt;text-indent: -24pt;text-align: left;">AnnotationConfigApplicationContext(AppConfig.class); MyService myService = ctx.getBean(MyService.class); myService.doStuff();</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">要使用组件组建扫描，仅需用<span class="s124">@Configuration </span>进行注解即可：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">@Configuration</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">@ComponentScan(basePackages = &quot;com.somnus&quot;) public class AppConfig {</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">...</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">在上面的例子中，<span class="s124">com.acme </span>包首先会被扫到，然后再容器内查找被<span class="s124">@Component </span>声明的类，找到后将这些类按照 <span class="s124">Sring bean </span>定义进行注册。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="541" alt="image" src="整合_files/Image_368.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">web-app</span>&gt;</p><p class="s133" style="padding-left: 1pt;text-indent: 24pt;text-align: left;">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext</p><p class="s133" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">instead of the default XmlWebApplicationContext --&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">context-param</span>&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">param-name</span>&gt;<span style=" color: #000;">contextClass</span>&lt;/<span style=" color: #800000;">param-name</span>&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">param-value</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">org.springframework.web.context.support.AnnotationConfigWebApplicatio nContext</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">param-value</span>&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">context-param</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s133" style="padding-left: 1pt;text-indent: 24pt;text-align: left;">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited</p><p class="s133" style="padding-left: 1pt;text-indent: 48pt;text-align: left;">fully-qualified @Configuration classes. Fully-qualified packages may also be</p><p class="s133" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">specified for component-scanning --&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">context-param</span>&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">param-name</span>&gt;<span style=" color: #000;">contextConfigLocation</span>&lt;/<span style=" color: #800000;">param-name</span>&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">param-value</span>&gt;<span style=" color: #000;">com.howtodoinjava.AppConfig</span>&lt;/<span style=" color: #800000;">param-value</span>&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">context-param</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s133" style="padding-left: 1pt;text-indent: 24pt;text-align: left;">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-top: 5pt;padding-bottom: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">如果你要在你的 <span class="s124">web </span>应用开发中选用上述的配置的方式的话，需要用 <span class="s124">AnnotationConfigWebApplicationContext </span>类来读 取配置文件，可以用来配置 <span class="s124">Spring </span>的 <span class="s124">Servlet </span>监听器 <span class="s124">ContextLoaderListener </span>或者 <span class="s124">Spring MVC </span>的 <span class="s124">DispatcherServlet</span>。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="889" alt="image" src="整合_files/Image_369.png"/></span></p><p class="s131" style="padding-top: 2pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">listener</span>&gt;</p><p class="s131" style="padding-left: 23pt;text-indent: 48pt;text-align: left;">&lt;<span style=" color: #800000;">listener- class</span>&gt;<span style=" color: #000;">org.springframework.web.context.ContextLoaderListener</span>&lt;/<span style=" color: #800000;">listener</span></p><p class="s132" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-class<span style=" color: #00F;">&gt;</span></p><p class="s131" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">listener</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s133" style="padding-top: 3pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</p><p class="s131" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">servlet</span>&gt;</p><p class="s131" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">servlet-name</span>&gt;<span style=" color: #000;">dispatcher</span>&lt;/<span style=" color: #800000;">servlet-name</span>&gt;</p><p class="s131" style="padding-left: 23pt;text-indent: 48pt;text-align: left;">&lt;<span style=" color: #800000;">servlet- class</span>&gt;<span style=" color: #000;">org.springframework.web.servlet.DispatcherServlet</span>&lt;/<span style=" color: #800000;">servlet- class</span>&gt;</p><p class="s133" style="padding-left: 23pt;text-indent: 48pt;text-align: left;">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext</p><p class="s133" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">instead of the default XmlWebApplicationContext --&gt;</p><p class="s131" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">init-param</span>&gt;</p><p class="s131" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">param-name</span>&gt;<span style=" color: #000;">contextClass</span>&lt;/<span style=" color: #800000;">param-name</span>&gt;</p><p class="s131" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">param-value</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">org.springframework.web.context.support.AnnotationConfigWebApplicatio nContext</p><p class="s131" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">param-value</span>&gt;</p><p class="s131" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">init-param</span>&gt;</p><p class="s133" style="padding-left: 23pt;text-indent: 48pt;text-align: left;">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited</p><p class="s133" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">and fully-qualified @Configuration classes --&gt;</p><p class="s131" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">init-param</span>&gt;</p><p class="s131" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">param-name</span>&gt;<span style=" color: #000;">contextConfigLocation</span>&lt;/<span style=" color: #800000;">param-name</span>&gt;</p><p class="s131" style="padding-left: 95pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">param-value</span>&gt;<span style=" color: #000;">com.howtodoinjava.web.MvcConfig</span>&lt;/<span style=" color: #800000;">param-</span></p><p class="s132" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">value<span style=" color: #00F;">&gt;</span></p><p class="s131" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">init-param</span>&gt;</p><p class="s131" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">servlet</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s133" style="padding-top: 3pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</p><p class="s131" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">servlet-mapping</span>&gt;</p><p class="s131" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">servlet-name</span>&gt;<span style=" color: #000;">dispatcher</span>&lt;/<span style=" color: #800000;">servlet-name</span>&gt;</p><p class="s131" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">url-pattern</span>&gt;<span style=" color: #000;">/app/*</span>&lt;/<span style=" color: #800000;">url-pattern</span>&gt;</p><p class="s131" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">servlet-mapping</span>&gt;</p><p class="s131" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">web-app</span></p><p class="s125" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">9<span class="s126">、怎样用注解的方式配置 </span>Spring<span class="s126">？</span></p><p class="s124" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: justify;">Spring <span class="s123">在 </span>2.5 <span class="s123">版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代 </span>XML <span class="s123">方式的 </span>bean <span class="s123">描述，可以将 </span>bean <span class="s123">描述转移到组件类的 内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在 </span>XML <span class="s123">注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结 果。</span></p><p class="s123" style="padding-top: 5pt;padding-bottom: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: justify;">注解装配在 <span class="s124">Spring </span>中是默认关闭的。所以需要在 <span class="s124">Spring </span>文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">beans</span>&gt;</p><p class="s131" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">context:annotation-config</span>/&gt;</p><p class="s133" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&lt;!-- bean definitions go here --&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">beans</span>&gt;</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">在 <span class="s124">&lt;context:annotation-config/&gt;</span>标签配置完成以后，就可以用注解的方式在 <span class="s124">Spring </span>中向属性、方法和构造方法中自动装配变量。</p><p class="s123" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">下面是几种比较重要的注解类型：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l112"><li data-list-text="1."><p class="s124" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">@Required<span class="s123">：该注解应用于设值方法。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s124" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">@Autowired<span class="s123">：该注解应用于有值设值方法、非设值方法、构造方法和变量。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s124" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">@Qualifier<span class="s123">：该注解和</span>@Autowired <span class="s123">注解搭配使用，用于消除特定 </span>bean <span class="s123">自动装配的歧义。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s124" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">JSR-250 Annotations<span class="s123">：</span>Spring <span class="s123">支持基于 </span>JSR-250 <span class="s123">注解的以下注解，</span>@Resource<span class="s123">、</span></p></li></ol><p class="s124" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">@PostConstruct <span class="s123">和 </span>@PreDestroy<span class="s123">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">10<span class="s126">、请解释 </span>Spring Bean <span class="s126">的生命周期？</span></p><p class="s124" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">Spring Bean <span class="s123">的生命周期简单易懂。在一个 </span>bean <span class="s123">实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 </span>bean <span class="s123">不在被调用时需要进行相关的析构操作，并从 </span>bean <span class="s123">容器中移除。</span></p><p class="s124" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">Spring bean factory <span class="s123">负责管理在 </span>spring <span class="s123">容器中被创建的 </span>bean <span class="s123">的生命周期。</span>Bean <span class="s123">的生命周期由两组回调（</span>call back<span class="s123">）方法组成。</span></p><ol id="l113"><li data-list-text="1."><p class="s123" style="padding-top: 5pt;padding-left: 22pt;text-indent: -18pt;text-align: left;">初始化之后调用的回调方法。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s123" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">销毁之前调用的回调方法。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s124" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring <span class="s123">框架提供了以下四种方式来管理 </span>bean <span class="s123">的生命周期事件：</span></p><ul id="l114"><li data-list-text=""><p class="s124" style="padding-top: 8pt;padding-left: 39pt;text-indent: -18pt;text-align: left;">InitializingBean <span class="s123">和 </span>DisposableBean <span class="s123">回调接口</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s123" style="padding-left: 39pt;text-indent: -18pt;text-align: left;">针对特殊行为的其他 <span class="s124">Aware </span>接口</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s124" style="padding-left: 39pt;text-indent: -18pt;text-align: left;">Bean <span class="s123">配置文件中的 </span>Custom init()<span class="s123">方法和 </span>destroy()<span class="s123">方法</span></p></li><li data-list-text=""><p class="s124" style="padding-top: 4pt;padding-left: 39pt;text-indent: -18pt;text-align: left;">@PostConstruct <span class="s123">和</span>@PreDestroy <span class="s123">注解方式</span></p></li></ul></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">使用 <span class="s129">customInit()</span>和 <span class="s129">customDestroy()方法管理 bean 生命周期的代码样例如下：</span></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">beans</span>&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 24pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">id</span>=&quot;demoBean&quot; <span style=" color: #F00;">class</span>=&quot;com.somnus.task.DemoBean&quot; <span style=" color: #F00;">init- method</span>=&quot;customInit&quot; <span style=" color: #F00;">destroy-method</span>=&quot;customDestroy&quot;&gt;&lt;/<span style=" color: #800000;">bean</span>&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">beans</span>&gt;</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">11<span class="s126">、</span>Spring Bean <span class="s126">的作用域之间有什么区别？</span></p><p class="s124" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">Spring <span class="s123">容器中的 </span>bean <span class="s123">可以分为 </span>5 <span class="s123">个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：</span></p><ol id="l115"><li data-list-text="1."><p class="s124" style="padding-top: 5pt;padding-left: 22pt;text-indent: -18pt;text-align: left;">singleton<span class="s123">：这种 </span>bean <span class="s123">范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个</span></p><p class="s124" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">bean <span class="s123">的实例，单例的模式由 </span>bean factory <span class="s123">自身来维护。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s124" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">prototype<span class="s123">：原形范围与单例范围相反，为每一个 </span>bean <span class="s123">请求提供一个实例。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s124" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">request<span class="s123">：在请求 </span>bean <span class="s123">范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，</span></p><p class="s124" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">bean <span class="s123">会失效并被垃圾回收器回收。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s124" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">Session<span class="s123">：与请求范围类似，确保每个 </span>session <span class="s123">中有一个 </span>bean <span class="s123">的实例，在 </span>session <span class="s123">过期后，</span>bean</p><p class="s123" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">会随之失效。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5."><p class="s124" style="padding-left: 23pt;text-indent: -18pt;line-height: 128%;text-align: left;">global- session<span class="s123">：</span>global-session <span class="s123">和 </span>Portlet <span class="s123">应用相关。当你的应用部署在 </span>Portlet <span class="s123">容器中工作时，它包含很多 </span>portlet<span class="s123">。如果 你想要声明让所有的 </span>portlet <span class="s123">共用全局的存储变量的话，那么这全局变量需要存储在 </span>global-session <span class="s123">中。</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">全局作用域与 <span class="s124">Servlet </span>中的 <span class="s124">session </span>作用域效果相同。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">12<span class="s126">、什么是 </span>Spring inner beans<span class="s126">？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">在 <span class="s124">Spring </span>框架中，无论何时 <span class="s124">bean </span>被使用时，当仅被调用了一个属性。一个明智的做法是将这个 <span class="s124">bean </span>声明为内部 <span class="s124">bean</span>。内部 <span class="s124">bean </span>可以用 <span class="s124">setter </span>注入<span class="s124">“</span>属性<span class="s124">”</span>和构造方法注入<span class="s124">“</span>构造参数<span class="s124">”</span>的方式来实现。</p><p class="s123" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">比如，在我们的应用程序中，一个 <span class="s124">Customer </span>类引用了一个 <span class="s124">Person </span>类，我们的要做的是创建一个</p><p class="s124" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Person <span class="s123">的实例，然后在 </span>Customer <span class="s123">内部使用。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 25pt;text-indent: -24pt;text-align: left;">public class Customer{ private Person person;</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">//Setters and Getters</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="223" alt="image" src="整合_files/Image_370.png"/></span></p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 25pt;text-indent: -24pt;text-align: left;">public class Person{ private String name; private String address; private int age;</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">//Setters and Getters</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="307" alt="image" src="整合_files/Image_371.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">id</span>=&quot;CustomerBean&quot; <span style=" color: #F00;">class</span>=&quot;com.somnus.common.Customer&quot;&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">property </span><span style=" color: #F00;">name</span>=&quot;person&quot;&gt;</p><p class="s133" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;!-- This is inner bean --&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">class</span>=&quot;com.howtodoinjava.common.Person&quot;&gt;</p><p class="s131" style="padding-left: 73pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">property </span><span style=" color: #F00;">name</span>=&quot;name&quot; <span style=" color: #F00;">value</span>=&quot;lokesh&quot; /&gt;</p><p class="s131" style="padding-left: 73pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">property </span><span style=" color: #F00;">name</span>=&quot;address&quot; <span style=" color: #F00;">value</span>=&quot;India&quot; /&gt;</p><p class="s131" style="padding-left: 73pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">property </span><span style=" color: #F00;">name</span>=&quot;age&quot; <span style=" color: #F00;">value</span>=&quot;34&quot; /&gt;</p><p class="s131" style="text-indent: 0pt;text-align: right;">&lt;/<span style=" color: #800000;">bean</span>&gt;</p><p class="s131" style="text-indent: 0pt;text-align: right;">&lt;/<span style=" color: #800000;">property</span>&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">bean</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">内部 <span class="s124">bean </span>的声明方式如下：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">13<span class="s126">、</span>Spring <span class="s126">框架中的单例 </span>Beans <span class="s126">是线程安全的么？</span></p><p class="s124" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">Spring <a href="http://howtodoinjava.com/2012/10/22/singleton-design-pattern-in-java/" class="s135" target="_blank">框架并没有对</a><a href="http://howtodoinjava.com/2012/10/22/singleton-design-pattern-in-java/" class="s127" target="_blank">单例</a><span class="s123"> </span>bean <span class="s123">进行任何多线程的封装处理。关于单例 </span>bean <a href="http://howtodoinjava.com/2014/06/02/what-is-thread-safety/" class="s135" target="_blank">的</a><span style=" color: black; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 9.5pt;">线程安全</span><span class="s123">和并发问题需要开发者自行去搞定。但实际上，大部分的 </span>Spring bean <span class="s123">并没有可变的状态</span>(<span class="s123">比如 </span>Serview <span class="s123">类和 </span>DAO <span class="s123">类</span>)<span class="s123">，所以在某种程度上说 </span>Spring <span class="s123">的单例 </span>bean <span class="s123">是线程安全的。如果你的 </span>bean <span class="s123">有多种状态的话（比如 </span>View Model <span class="s123">对象），就需要自行保证线程安全。</span></p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">最浅显的解决办法就是将多态 <span class="s124">bean </span>的作用域由<span class="s124">“singleton”</span>变更为<span class="s124">“prototype”</span>。</p><p class="s125" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">14<span class="s126">、请举例说明如何在 </span>Spring <span class="s126">中注入一个 </span>Java Collection<span class="s126">？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s124" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring <span class="s123">提供了以下四种集合类的配置元素：</span></p><ul id="l116"><li data-list-text=""><p class="s124" style="padding-top: 8pt;padding-left: 39pt;text-indent: -18pt;text-align: left;">&lt;list&gt; : <span class="s123">该标签用来装配可重复的 </span>list <span class="s123">值。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s124" style="padding-left: 39pt;text-indent: -18pt;text-align: left;">&lt;set&gt; : <span class="s123">该标签用来装配没有重复的 </span>set <span class="s123">值。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s124" style="padding-left: 39pt;text-indent: -18pt;text-align: left;">&lt;map&gt;: <span class="s123">该标签可用来注入键和值可以为任何类型的键值对。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="666" alt="image" src="整合_files/Image_372.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">beans</span>&gt;</p><p class="s133" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&lt;!-- Definition for javaCollection --&gt;</p><p class="s131" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">id</span>=&quot;javaCollection&quot; <span style=" color: #F00;">class</span>=&quot;com.howtodoinjava.JavaCollection&quot;&gt;</p><p class="s133" style="padding-left: 37pt;text-indent: 0pt;text-align: left;">&lt;!-- java.util.List --&gt;</p><p class="s131" style="padding-left: 37pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">property </span><span style=" color: #F00;">name</span>=&quot;customList&quot;&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">list</span>&gt;</p><p class="s131" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">value</span>&gt;<span style=" color: #000;">INDIA</span>&lt;/<span style=" color: #800000;">value</span>&gt;</p><p class="s131" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">value</span>&gt;<span style=" color: #000;">Pakistan</span>&lt;/<span style=" color: #800000;">value</span>&gt;</p><p class="s131" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">value</span>&gt;<span style=" color: #000;">USA</span>&lt;/<span style=" color: #800000;">value</span>&gt;</p><p class="s131" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">value</span>&gt;<span style=" color: #000;">UK</span>&lt;/<span style=" color: #800000;">value</span>&gt;</p><p class="s131" style="padding-left: 37pt;text-indent: 0pt;text-align: center;">&lt;/<span style=" color: #800000;">list</span>&gt;</p><p class="s131" style="padding-left: 37pt;text-indent: 0pt;text-align: center;">&lt;/<span style=" color: #800000;">property</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s133" style="padding-left: 31pt;text-indent: 0pt;text-align: left;">&lt;!-- java.util.Set --&gt;</p><p class="s131" style="padding-left: 31pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">property </span><span style=" color: #F00;">name</span>=&quot;customSet&quot;&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">set</span>&gt;</p><p class="s131" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">value</span>&gt;<span style=" color: #000;">INDIA</span>&lt;/<span style=" color: #800000;">value</span>&gt;</p><p class="s131" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">value</span>&gt;<span style=" color: #000;">Pakistan</span>&lt;/<span style=" color: #800000;">value</span>&gt;</p><p class="s131" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">value</span>&gt;<span style=" color: #000;">USA</span>&lt;/<span style=" color: #800000;">value</span>&gt;</p><p class="s131" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">value</span>&gt;<span style=" color: #000;">UK</span>&lt;/<span style=" color: #800000;">value</span>&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">set</span>&gt;</p><p class="s131" style="padding-left: 37pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">property</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s133" style="padding-left: 31pt;text-indent: 0pt;text-align: left;">&lt;!-- java.util.Map --&gt;</p><p class="s131" style="padding-left: 31pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">property </span><span style=" color: #F00;">name</span>=&quot;customMap&quot;&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">map</span>&gt;</p><p class="s131" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">entry </span><span style=" color: #F00;">key</span>=&quot;1&quot; <span style=" color: #F00;">value</span>=&quot;INDIA&quot;/&gt;</p><p class="s131" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">entry </span><span style=" color: #F00;">key</span>=&quot;2&quot; <span style=" color: #F00;">value</span>=&quot;Pakistan&quot;/&gt;</p><p class="s131" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">entry </span><span style=" color: #F00;">key</span>=&quot;3&quot; <span style=" color: #F00;">value</span>=&quot;USA&quot;/&gt;</p><p class="s131" style="padding-left: 67pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">entry </span><span style=" color: #F00;">key</span>=&quot;4&quot; <span style=" color: #F00;">value</span>=&quot;UK&quot;/&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">map</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"/></li><li data-list-text=""><p class="s124" style="padding-left: 23pt;text-indent: -1pt;line-height: 221%;text-align: left;">&lt;props&gt; : <span class="s123">该标签支持注入键和值都是字符串类型的键值对。下面看一下具体的例子：</span></p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="327" alt="image" src="整合_files/Image_373.png"/></span></p><p class="s131" style="padding-left: 37pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">property</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s133" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;!-- java.util.Properties --&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">property </span><span style=" color: #F00;">name</span>=&quot;customProperies&quot;&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">props</span>&gt;</p><p class="s131" style="padding-left: 73pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">prop </span><span style=" color: #F00;">key</span><a href="mailto:admin@nospam.com" style=" color: #00F; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt;" target="_blank">=&quot;admin&quot;&gt;</a><span style=" color: #000;">admin@nospam.com</span>&lt;/<span style=" color: #800000;">prop</span>&gt;</p><p class="s131" style="padding-left: 73pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">prop </span><span style=" color: #F00;">key</span><a href="mailto:support@nospam.com" style=" color: #00F; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt;" target="_blank">=&quot;support&quot;&gt;</a><span style=" color: #000;">support@nospam.com</span>&lt;/<span style=" color: #800000;">prop</span>&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">props</span>&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">property</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">bean</span>&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">beans</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s125" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">15<span class="s126">、如何向 </span>Spring Bean <span class="s126">中注入一个 </span>Java.util.Properties<span class="s126">？</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="306" alt="image" src="整合_files/Image_374.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">id</span>=&quot;adminUser&quot; <span style=" color: #F00;">class</span>=&quot;com.somnus.common.Customer&quot;&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s133" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;!-- java.util.Properties --&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">property </span><span style=" color: #F00;">name</span>=&quot;emails&quot;&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">props</span>&gt;</p><p class="s131" style="padding-left: 73pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">prop </span><span style=" color: #F00;">key</span><a href="mailto:admin@nospam.com" style=" color: #00F; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt;" target="_blank">=&quot;admin&quot;&gt;</a><span style=" color: #000;">admin@nospam.com</span>&lt;/<span style=" color: #800000;">prop</span>&gt;</p><p class="s131" style="padding-left: 73pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">prop </span><span style=" color: #F00;">key</span><a href="mailto:support@nospam.com" style=" color: #00F; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt;" target="_blank">=&quot;support&quot;&gt;</a><span style=" color: #000;">support@nospam.com</span>&lt;/<span style=" color: #800000;">prop</span>&gt;</p><p class="s131" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">props</span>&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">property</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">bean</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">第一种方法是使用如下面代码所示的<span class="s124">&lt;props&gt; </span>标签：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">也可用<span class="s124">”util:”</span>命名空间来从 <span class="s124">properties </span>文件中创建出一个 <span class="s124">propertiesbean</span>，然后利用 <span class="s124">setter </span>方法注入 <span class="s124">bean </span>的引用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">16<span class="s126">、请解释 </span>Spring Bean <span class="s126">的自动装配？</span></p><p class="s123" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">在 <span class="s124">Spring </span>框架中，在配置文件中设定 <span class="s124">bean </span>的依赖关系是一个很好的机制，<span class="s124">Spring </span>容器还可以自动装配合作关系 <span class="s124">bean </span>之间的关联关系。这意味着 <span class="s124">Spring </span>可以通过向 <span class="s124">Bean Factory </span>中注入的方式自动搞定 <span class="s124">bean </span>之间的依赖关系。自动装配可以设置在每个 <span class="s124">bean </span>上，也可以设定在特定的 <span class="s124">bean</span>上。</p><p class="s123" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">下面的 <span class="s124">XML </span>配置文件表明了如何根据名称将一个 <span class="s124">bean </span>设置为自动装配：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">id</span>=&quot;employeeDAO&quot; <span style=" color: #F00;">class</span>=&quot;com.howtodoinjava.EmployeeDAOImpl&quot; <span style=" color: #F00;">autowire</span>=&quot;byName&quot; /&gt;</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">除了 <span class="s124">bean </span>配置文件中提供的自动装配模式，还可以使用<span class="s129">@Autowired 注解来自动装配指定的 bean。在使用@Autowired 注解之前需要在按照如下的配置方式在 Spring 配置文件进行配置才可以使用。</span></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">context:annotation-config </span>/&gt;</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 112%;text-align: left;">也可以通过在配置文件中配置 <span class="s129">AutowiredAnnotationBeanPostProcessor </span>达到相同的效果。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">class</span></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBea nPostProcessor&quot;/&gt;</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"><span><img width="563" height="21" alt="image" src="整合_files/Image_375.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">配置好以后就可以使用<span class="s129">@Autowired </span>来标注了。</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">@Autowired</p><p class="s19" style="padding-left: 25pt;text-indent: -24pt;text-align: left;">public EmployeeDAOImpl ( EmployeeManager manager ) { this.manager = manager;</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s125" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">17<span class="s126">、请解释自动装配模式的区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">在 <span class="s124">Spring </span>框架中共有 <span class="s124">5 </span>种自动装配，让我们逐一分析。</p><ol id="l117"><li data-list-text="1."><p class="s124" style="padding-top: 8pt;padding-left: 23pt;text-indent: -18pt;line-height: 128%;text-align: left;">no<span class="s123">：这是 </span>Spring <span class="s123">框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在 </span>bean <span class="s123">定义中用标签明确的设置依赖关系。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s124" style="padding-left: 23pt;text-indent: -18pt;line-height: 128%;text-align: left;">byName<span class="s123">：该选项可以根据 </span>bean <span class="s123">名称设置依赖关系。当向一个 </span>bean <span class="s123">中自动装配一个属性时，容器将根据 </span>bean <span class="s123">的名称自动在在配置文件中查询一个匹配的 </span>bean<span class="s123">。如果找到的话，就装配这个属性，如果没找到的话就报错。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s124" style="padding-left: 23pt;text-indent: -18pt;line-height: 128%;text-align: justify;">byType<span class="s123">：该选项可以根据 </span>bean <span class="s123">类型设置依赖关系。当向一个 </span>bean <span class="s123">中自动装配一个属性时，容器将根据 </span>bean <span class="s123">的类型自动在在配置文件中查询一个匹配的 </span>bean<span class="s123">。如果找到的话，就装配这个属性，如果没找到的话就报错。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s124" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">constructor<span class="s123">：造器的自动装配和 </span>byType <span class="s123">模式类似，但是仅仅适用于与有构造器相同参数的</span></p><p class="s124" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">bean<span class="s123">，如果在容器中没有找到与构造器参数类型一致的 </span>bean<span class="s123">，那么将会抛出异常。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5."><p class="s124" style="padding-left: 23pt;text-indent: -18pt;line-height: 128%;text-align: left;">autodetect<span class="s123">：该模式自动探测使用构造器自动装配或者 </span>byType <span class="s123">自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在 </span>bean <span class="s123">内部没有找到相应的构造器或者是无参构造器，容器就会自动选择 </span>byTpe <span class="s123">的自动装配方式。</span></p></li></ol><p class="s125" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">18<span class="s126">、如何开启基于注解的自动装配？</span></p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">要使用 <span class="s129">@Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现：</span></p><p class="s124" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">1<span class="s123">、引入配置文件中的</span>&lt;bean&gt;<span class="s123">下引入 </span><span class="s129">&lt;context:annotation-config&gt;</span></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">beans</span>&gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">context:annotation-config </span>/&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">beans</span>&gt;</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s124" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2<span class="s123">、在 </span>bean <span class="s123">配置文件中直接引入 </span><span class="s129">AutowiredAnnotationBeanPostProcessor</span></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">beans</span>&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 24pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">class</span>=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotati onBeanPostProcessor&quot;/&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">beans</span>&gt;</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p class="s125" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">19<span class="s126">、请举例解释</span>@Required <span class="s126">注解？</span></p><p class="s123" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">在产品级别的应用中，<span class="s124">IoC </span>容器可能声明了数十万了 <span class="s124">bean</span>，<span class="s124">bean </span>与 <span class="s124">bean </span>之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在</p><p class="s124" style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">&lt;bean&gt;<span class="s123">中设置</span>“dependency-check”<span class="s123">来解决这个问题。</span></p><p class="s123" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;line-height: 121%;text-align: left;">在应用程序的生命周期中，你可能不大愿意花时间在验证所有 <span class="s124">bean </span>的属性是否按照上下文文件正确配置。或者你宁可验证某个 <span class="s124">bean </span>的特定属性是否被正确的设置。即使是用<span class="s124">“dependency- check”</span>属性也不能很好的解决这个问题，在这种情况下，你需要使用<span class="s129">@Required </span>注解。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="270" alt="image" src="整合_files/Image_376.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 25pt;text-indent: -24pt;text-align: left;"><span style=" color: #000;">public class EmployeeFactoryBean extends AbstractFactoryBean</span>&lt;<span style=" color: #800000;">Object</span>&gt;<span style=" color: #000;">{ private String designation;</span></p><p class="s19" style="padding-left: 49pt;text-indent: -24pt;text-align: left;">public String getDesignation() { return designation;</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">}</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">@Required</p><p class="s19" style="padding-left: 49pt;text-indent: -24pt;text-align: left;">public void setDesignation(String designation) { this.designation = designation;</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">}</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">//more code here</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">需要用如下的方式使用来标明 <span class="s124">bean </span>的设值方法。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"><span><img width="560" height="21" alt="image" src="整合_files/Image_377.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s19">RequiredAnnotationBeanPostProcessor </span><span class="s130">是 </span><span class="s124">Spring </span>中的后置处理用来验证被 <span class="s129">@Required </span>注解的 <span class="s124">bean </span>属性是否被正确的设置了。在使用 <span class="s129">RequiredAnnotationBeanPostProcesso </span>来验证 <span class="s129">bean </span>属性之前，首先要在 <span class="s129">IoC </span>容器中对其进行注册：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">class</span>=&quot;org.springframework.beans.factory.annotation.RequiredAnnotatio nBeanPostProcessor&quot; /&gt;</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"><span><img width="549" height="21" alt="image" src="整合_files/Image_378.png"/></span></p><p class="s123" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">但是如果没有属性被用 <span class="s129">@Required </span>注解过的话，后置处理器会抛出一个</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">BeanInitializationException <span class="s130">异常。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">20<span class="s126">、请举例解释</span>@Autowired <span class="s126">注解？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s124" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">@Autowired <span class="s123">注解对自动装配何时何处被实现提供了更多细粒度的控制。</span><span class="s129">@Autowired 注解可</span></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">以像@Required 注解、构造器一样被用于在 bean 的设值方法上自动装配 bean</p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">的属性，一个参数或者带有任意名称或带有多个参数的方法。</p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">比如，可以在设值方法上使用<span class="s129">@Autowired 注解来替代配置文件中的 &lt;property&gt;元</span></p><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">素。当 Spring 容器在 setter 方法上找到@Autowired 注解时，会<span style=" color: #F00;">尝试用 </span><span class="s137">byType</span></p><p class="s123" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">自动装配。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="306" alt="image" src="整合_files/Image_379.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">public class TextEditor {</p><p class="s19" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">private SpellChecker spellChecker; @Autowired</p><p class="s19" style="padding-left: 37pt;text-indent: -18pt;text-align: left;">public TextEditor(SpellChecker spellChecker){ System.out.println(&quot;Inside TextEditor constructor.&quot; ); this.spellChecker = spellChecker;</p><p class="s19" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p class="s19" style="padding-left: 37pt;text-indent: -18pt;text-align: left;">public void spellCheck(){ spellChecker.checkSpelling();</p><p class="s19" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">}</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">当然我们也可以在构造方法上使用<span class="s129">@Autowired </span>注解。带有<span class="s129">@Autowired </span>注解的构造方法意味着在创建一个 <span class="s124">bean </span>时将会被自动装配，即便在配置文件中使用<span class="s129">&lt;constructor-arg&gt; </span>元素。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="229" alt="image" src="整合_files/Image_380.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">beans</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">context:annotation-config</span>/&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s133" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&lt;!-- Definition for textEditor bean without constructor-arg --&gt;</p><p class="s131" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">id</span>=&quot;textEditor&quot; <span style=" color: #F00;">class</span>=&quot;com.howtodoinjava.TextEditor&quot;/&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s133" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&lt;!-- Definition for spellChecker bean --&gt;</p><p class="s131" style="padding-left: 19pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">id</span>=&quot;spellChecker&quot; <span style=" color: #F00;">class</span>=&quot;com.howtodoinjava.SpellChecker&quot;/&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">下面是没有构造参数的配置方式：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="98" alt="image" src="整合_files/Image_381.png"/></span></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">beans</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s125" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">21<span class="s126">、请举例说明</span>@Qualifier <span class="s126">注解？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s124" style="padding-left: 23pt;text-indent: 0pt;line-height: 111%;text-align: left;"><span class="s19">@Qualifier 注解意味着可以在被标注 bean 的字段上可以自动装配。</span>Qualifier <span class="s123">注解可以用来取消 </span>Spring <span class="s123">不能取消的 </span>bean <span class="s123">应用。</span></p><p class="s123" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">下面的示例将会在 <span class="s124">Customer </span>的 <span class="s124">person </span>属性中自动装配 <span class="s124">person </span>的值。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 25pt;text-indent: -24pt;text-align: left;">public class Customer{ @Autowired</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">private Person person;</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="229" alt="image" src="整合_files/Image_382.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">id</span>=&quot;customer&quot; <span style=" color: #F00;">class</span>=&quot;com.somnus.common.Customer&quot; /&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">id</span>=&quot;personA&quot; <span style=" color: #F00;">class</span>=&quot;com.somnus.common.Person&quot; &gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">property </span><span style=" color: #F00;">name</span>=&quot;name&quot; <span style=" color: #F00;">value</span>=&quot;lokesh&quot; /&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">bean</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">bean </span><span style=" color: #F00;">id</span>=&quot;personB&quot; <span style=" color: #F00;">class</span>=&quot;com.somnus.common.Person&quot; &gt;</p><p class="s131" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">&lt;<span style=" color: #800000;">property </span><span style=" color: #F00;">name</span>=&quot;name&quot; <span style=" color: #F00;">value</span>=&quot;alex&quot; /&gt;</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">&lt;/<span style=" color: #800000;">bean</span>&gt;</p><p style="text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">下面我们要在配置文件中来配置 <span class="s124">Person </span>类。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"><span><img width="549" height="21" alt="image" src="整合_files/Image_383.png"/></span></p><p class="s19" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring 会知道要自动装配哪个 person bean 么？不会的，但是运行上面的示例时，会抛出下面的异常：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException:</p><p class="s19" style="padding-left: 49pt;text-indent: -24pt;text-align: left;">No unique bean of type [com.howtodoinjava.common.Person] is defined: expected single matching bean but found 2: [personA, personB]</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">要解决上面的问题，需要使用 <span class="s129">@Quanlifier </span>注解来告诉 <span class="s124">Spring </span>容器要装配哪个 <span class="s124">bean</span>：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 25pt;text-indent: -24pt;text-align: left;">public class Customer{ @Autowired @Qualifier(&quot;personA&quot;) private Person person;</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"><span><img width="563" height="21" alt="image" src="整合_files/Image_384.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">22<span class="s126">、构造方法注入和设值注入有什么区别？</span></p><p class="s123" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">请注意以下明显的区别：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l118"><li data-list-text="1."><p class="s123" style="padding-left: 23pt;text-indent: -18pt;line-height: 128%;text-align: left;">在设值注入方法支持大部分的依赖注入，如果我们仅需 要注入 <span class="s124">int</span>、<span class="s124">string </span>和 <span class="s124">long </span>型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法 注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s123" style="padding-left: 23pt;text-indent: -18pt;line-height: 128%;text-align: justify;">设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s123" style="padding-left: 23pt;text-indent: -18pt;line-height: 128%;text-align: justify;">在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s123" style="padding-left: 23pt;text-indent: -18pt;line-height: 106%;text-align: left;">在设值注入时如果对象 <span class="s124">A </span>和对象 <span class="s124">B </span>互相依赖，在创建对象 <span class="s124">A </span>时 <span class="s124">Spring </span>会抛出 <span class="s124">s</span><span class="s19">ObjectCurrentlyInCreationException 异常，因为在 B 对象被创建之前 A 对象是不能被创建的，反之亦然。所以 Spring 用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。</span></p></li></ol><p class="s125" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">23<span class="s126">、</span>Spring <span class="s126">框架中有哪些不同类型的事件？</span></p><p class="s123" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="s124">Spring </span>的 <span class="s129">ApplicationContext </span>提供了支持事件和代码中监听器的功能。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="265" alt="image" src="整合_files/Image_385.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">public class AllApplicationEventListener implements ApplicationListener</p><p class="s131" style="padding-left: 25pt;text-indent: -24pt;text-align: left;">&lt; <span style=" color: #800000;">ApplicationEvent </span>&gt;<span style=" color: #000;">{ @Override</span></p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">public void onApplicationEvent(ApplicationEvent applicationEvent)</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">{</p><p class="s19" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">//process event</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">}</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"/><p class="s123" style="padding-bottom: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">我们可以创建 <span class="s124">bean </span>用来监听在 <span class="s129">ApplicationContext </span>中发布的事件。<span class="s129">ApplicationEven</span><span class="s124">t</span>类和在 <span class="s129">ApplicationContext 接口</span>中处理的事件，如果一个 <span class="s124">bean </span>实现了 <span class="s129">ApplicationListener </span>接口，当一个 <span class="s129">ApplicationEvent </span>被发布以后，<span class="s124">bean </span>会自动被通知。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s124" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring <span class="s123">提供了以下 </span>5 <span class="s123">中标准的事件：</span></p><ol id="l119"><li data-list-text="1."><p class="s123" style="padding-top: 9pt;padding-left: 23pt;text-indent: -18pt;line-height: 128%;text-align: left;">上下文更新事件（<span class="s124">ContextRefreshedEvent</span>）：该事件会在 <span class="s124">ApplicationContext </span>被初始化或者更新时发布。也可以在调用 <span class="s124">ConfigurableApplicationContext </span>接口中的 <span class="s124">refresh()</span>方法时被触发。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s123" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">上下文开始事件（<span class="s124">ContextStartedEvent</span>）：当容器调用 <span class="s124">ConfigurableApplicationContext </span>的</p><p class="s124" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Start()<span class="s123">方法开始</span>/<span class="s123">重新开始容器时触发该事件。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s123" style="padding-left: 22pt;text-indent: -18pt;text-align: left;">上下文停止事件（<span class="s124">ContextStoppedEvent</span>）：当容器调用 <span class="s124">ConfigurableApplicationContext </span>的</p><p class="s124" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Stop()<span class="s123">方法停止容器时触发该事件。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s123" style="padding-left: 23pt;text-indent: -18pt;line-height: 128%;text-align: left;">上下文关闭事件（<span class="s124">ContextClosedEvent</span>）：当 <span class="s124">ApplicationContext </span>被关闭时触发该事件。容器被关闭时，其管理的所有单例 <span class="s124">Bean </span>都被销毁。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5."><p class="s123" style="padding-left: 23pt;text-indent: -18pt;line-height: 128%;text-align: left;">请求处理事件（<span class="s124">RequestHandledEvent</span>）：在 <span class="s124">Web </span>应用中，当一个 <span class="s124">http </span>请求（<span class="s124">request</span>）结束触发该事件。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">除了上面介绍的事件以外，还可以通过扩展 <span class="s129">ApplicationEvent </span>类来开发自定义的事件。</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">public class CustomApplicationEvent extends ApplicationEvent{</p><p class="s19" style="padding-left: 49pt;text-indent: -24pt;text-align: left;">public CustomApplicationEvent ( Object source, final String msg ){ super(source);</p><p class="s19" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">System.out.println(&quot;Created a Custom event&quot;);</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">}</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"><span><img width="558" height="49" alt="image" src="整合_files/Image_386.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-top: 3pt;padding-bottom: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">为了监听这个事件，还需要创建一个监听器：</p><p class="s131" style="padding-left: 1pt;text-indent: 0pt;text-align: left;"><span style=" color: #000;">public class CustomEventListener implements ApplicationListener </span>&lt; <span style=" color: #800000;">CustomApplicationEvent </span>&gt;<span style=" color: #000;">{</span></p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">@Override</p><p class="s19" style="padding-left: 1pt;text-indent: 24pt;text-align: left;">public void onApplicationEvent(CustomApplicationEvent applicationEvent) {</p><p class="s19" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">//handle event</p><p class="s19" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">}</p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s123" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">之后通过 <span class="s124">applicationContext </span>接口的 <span class="s129">publishEvent()方法来发布自定义事件。</span></p><p class="s19" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">CustomApplicationEvent customEvent = new CustomApplicationEvent(applicationContext, &quot;Test message&quot;); applicationContext.publishEvent(customEvent);</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s125" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">24<span class="s126">、</span>FileSystemResource <span class="s126">和 </span>ClassPathResource <span class="s126">有何区别？</span></p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">在 <span class="s129">FileSystemResource </span>中需要给出 <span class="s129">spring-config.xml </span>文件在你项目中的相对路径或者绝对路径。在 <span class="s129">ClassPathResource </span>中 <span class="s124">spring </span>会在 <span class="s124">ClassPath </span>中自动搜寻配置文件，所以要把 <span class="s129">ClassPathResource </span>文件放在 <span class="s124">ClassPath </span>下。</p><p class="s123" style="padding-left: 23pt;text-indent: 0pt;line-height: 111%;text-align: justify;">如果将 <span class="s129">spring-config.xml </span>保存在了 <span class="s124">src </span>文件夹下的话，只需给出配置文件的名称即可，因为 <span class="s124">src </span>文件夹是默认。</p><p class="s123" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: justify;">简而言之，<span class="s124">ClassPathResource </span>在环境变量中读取配置文件，<span class="s124">FileSystemResource </span>在配置文件中读取配置文件。</p><p class="s125" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">25<span class="s126">、</span>Spring <span class="s126">框架中都用到了哪些设计模式？</span></p><p class="s124" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring <span class="s123">框架中使用到了大量的设计模式，下面列举了比较有代表性的：</span></p><ul id="l120"><li data-list-text="o"><p class="s123" style="padding-top: 9pt;padding-left: 56pt;text-indent: -18pt;text-align: left;">代理模式<span class="s124">—</span>在 <span class="s124">AOP </span>和 <span class="s124">remoting </span>中被用的比较多。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="o"><p class="s123" style="padding-left: 56pt;text-indent: -18pt;text-align: left;">单例模式<span class="s124">—</span>在 <span class="s124">spring </span>配置文件中定义的 <span class="s124">bean </span>默认为单例模式。</p></li><li data-list-text="o"><p class="s124" style="padding-top: 2pt;padding-left: 56pt;text-indent: -18pt;text-align: left;"><span class="s123">模板方法</span>—<span class="s123">用来解决代码重复的问题。比如</span><a href="http://howtodoinjava.com/2015/02/20/spring-restful-client-resttemplate-example/" style=" color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt;" target="_blank">. </a><span style=" color: black; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 9.5pt;">RestTemplate</span>, <span class="s19">JmsTemplate</span>, <span class="s19">JpaTempl ate。</span></p></li><li data-list-text="o"><p class="s123" style="padding-left: 56pt;text-indent: -18pt;text-align: left;">前端控制器<span class="s124">—Spring </span>提供了 <span class="s129">DispatcherServlet 来对请求进行分发。</span></p></li><li data-list-text="o"><p class="s123" style="padding-top: 1pt;padding-left: 56pt;text-indent: -18pt;line-height: 125%;text-align: left;">视图帮助<span class="s124">(View Helper )—Spring </span>提供了一系列的 <span class="s124">JSP </span>标签，高效宏来辅助将分散的代码整合在视图里。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="o"><p class="s123" style="padding-left: 56pt;text-indent: -18pt;text-align: left;">依赖注入<span class="s124">—</span>贯穿于 <span class="s129">BeanFactory </span><span class="s124">/ </span><span class="s19">ApplicationContext 接口的核心理念。</span></p></li><li data-list-text="o"><p class="s123" style="padding-top: 1pt;padding-left: 56pt;text-indent: -18pt;text-align: left;">工厂模式<span class="s124">—BeanFactory </span>用来创建对象的实例</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l121"><li data-list-text="1."><p class="s138" style="padding-left: 37pt;text-indent: -14pt;text-align: left;">开发中主要使用 <span class="s139">Spring </span>的什么技术 <span class="s139">?</span></p><p class="s123" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">①<span class="s124">. IOC </span>容器管理各层的组件</p><p class="s123" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">②<span class="s124">. </span>使用 <span class="s124">AOP </span>配置声明式事务</p><p class="s123" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">③<span class="s124">. </span>整合其他框架<span class="s124">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s138" style="padding-left: 37pt;text-indent: -14pt;text-align: left;">简述 <span class="s139">AOP </span>和 <span class="s139">IOC </span>概念 <span class="s139">AOP:</span></p><p class="s124" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">Aspect Oriented Program, <span class="s123">面向</span>(<span class="s123">方面</span>)<span class="s123">切面的编程</span>;Filter(<span class="s123">过滤器</span>) <span class="s123">也是一种 </span>AOP. AOP <span class="s123">是一种新的方法论</span>, <span class="s123">是对传统 </span>OOP(Object-Oriented Programming, <span class="s123">面向对象编程</span>) <span class="s123">的补充</span>. AOP <span class="s123">的主要编程对象是切面</span>(aspect), <span class="s123">而切面模块化横切关注点</span>.<span class="s123">可以举例通过事务说明</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s124" style="padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">IOC: Invert Of Control, <span class="s123">控制反转</span>. <span class="s123">也成为 </span>DI(<span class="s123">依赖注入</span>)<span class="s123">其思想是反转 资源获取的方向</span>. <span class="s123">传统的资源查找方式要求组件向容器发起请求查找资源</span>.<span class="s123">作为 回应</span>, <span class="s123">容器适时的返回资源</span>. <span class="s123">而应用了 </span>IOC <span class="s123">之后</span>, <span class="s123">则是容器主动地将资源推送 给它所管理的组件</span>,<span class="s123">组件所要做的仅是选择一种合适的方式来接受资源</span>. <span class="s123">这种行 为也被称为查找的被动形式</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s138" style="padding-top: 9pt;padding-left: 37pt;text-indent: -14pt;text-align: left;">在 <span class="s139">Spring </span>中如何配置 <span class="s139">Bean ?</span></p><p class="s124" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Bean <span class="s123">的配置方式</span>: <span class="s123">通过全类名（反射）、通过工厂方法（静态工厂方法 </span>&amp; <span class="s123">实 例工厂方法）、</span></p><p class="s124" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">FactoryBean</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s139" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">IOC <span class="s138">容器对 </span>Bean <span class="s138">的生命周期</span>:</p></li></ol></li></ol><p class="s123" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">①<span class="s124">. </span>通过构造器或工厂方法创建 <span class="s124">Bean </span>实例</p><p class="s123" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">②<span class="s124">. </span>为 <span class="s124">Bean </span>的属性设置值和对其他 <span class="s124">Bean </span>的引用</p><p class="s123" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 128%;text-align: left;">③ <span class="s124">. </span>将 <span class="s124">Bean </span>实 例 传 递 给 <span class="s124">Bean </span>后 置 处 理 器 的 <span class="s124">postProcessBeforeInitialization </span>方法</p><p class="s123" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">④<span class="s124">. </span>调用 <span class="s124">Bean </span>的初始化方法<span class="s124">(init-method)</span></p><p class="s123" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">⑤ <span class="s124">. </span>将 <span class="s124">Bean </span>实 例 传 递 给 <span class="s124">Bean </span>后 置 处 理 器 的 <span class="s124">postProcessAfterInitialization </span>方法</p><p class="s123" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">⑦<span class="s124">. Bean </span>可以使用了</p><p class="s123" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">⑧<span class="s124">. </span>当容器关闭时<span class="s124">, </span>调用 <span class="s124">Bean </span>的销毁方法<span class="s124">(destroy-method)</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">1<span class="p">、一张表，里面有 </span>ID <span class="p">自增主键，当 </span>insert <span class="p">了 </span>17 <span class="p">条记录之后，删除了第 </span>15,16,17 <span class="p">条记录，再把 </span>Mysql <span class="p">重启，再 </span>insert <span class="p">一条记录，这条记录的 </span>ID <span class="p">是 </span>18 <span class="p">还是 </span>15 <span class="p">？</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">(1)<span class="p">如果表的类型是 </span>MyISAM<span class="p">，那么是 </span>18</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">因为 <span class="s84">MyISAM </span>表会把自增主键的最大 <span class="s84">ID </span>记录到数据文件里，重启 <span class="s84">MySQL </span>自增主键的最大 <span class="s84">ID </span>也不会丢失</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">（<span class="s84">2</span>）如果表的类型是 <span class="s84">InnoDB</span>，那么是 <span class="s84">15</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">InnoDB <span class="p">表只是把自增主键的最大 </span>ID <span class="p">记录到内存中，所以重启数据库或者是对表进行 </span>OPTIMIZE <span class="p">操作，都会导致最大 </span>ID <span class="p">丢失</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">2<span class="p">、</span>Mysql <span class="p">的技术特点是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mysql <span class="p">数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程 </span>SQL <span class="p">服务器、不同的后端、广泛的应用程序编程接口和管理工具。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">3<span class="p">、</span>Heap <span class="p">表是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">HEAP <span class="p">表存在于内存中，用于临时高速存储。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">BLOB <span class="p">或 </span>TEXT <span class="p">字段是不允许的</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">只能使用比较运算符<span class="s84">=</span>，<span class="s84">&lt;</span>，<span class="s84">&gt;</span>，<span class="s84">=&gt;</span>，<span class="s84">= &lt;</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">HEAP <span class="p">表不支持 </span>AUTO_INCREMENT</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">索引不可为 <span class="s84">NULL</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">4<span class="p">、</span>Mysql <span class="p">服务器默认端口是什么？ </span>Mysql <span class="p">服务器的默认端口是 </span>3306<span class="p">。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">5<span class="p">、与 </span>Oracle <span class="p">相比，</span>Mysql <span class="p">有什么优势？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mysql <span class="p">是开源软件，随时可用，无需付费。 </span>Mysql <span class="p">是便携式的</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">带有命令提示符的 <span class="s84">GUI</span>。</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">使用 <span class="s84">Mysql </span>查询浏览器支持管理 <span class="s84">6</span>、如何区分 <span class="s84">FLOAT </span>和 <span class="s84">DOUBLE</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">以下是 <span class="s84">FLOAT </span>和 <span class="s84">DOUBLE </span>的区别：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">浮点数以 <span class="s84">8 </span>位精度存储在 <span class="s84">FLOAT </span>中，并且有四个字节。浮点数存储在 <span class="s84">DOUBLE </span>中，精度为 <span class="s84">18 </span>位，有八个字节。 <span class="s84">7</span>、区分 <span class="s84">CHAR_LENGTH </span>和 <span class="s84">LENGTH</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">CHAR_LENGTH <span class="p">是字符数，而 </span>LENGTH <span class="p">是字节数。</span>Latin <span class="p">字符的这两个数据是相同的，但是对于 </span>Unicode <span class="p">和其他编码，它们是不同的。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">8<span class="p">、请简洁描述 </span>Mysql <span class="p">中 </span>InnoDB <span class="p">支持的四种事务隔离级别名称，以及逐级之间的区别？</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">SQL <span class="p">标准定义的四个隔离级别为：</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">read uncommited <span class="p">：读到未提交数据 </span>read committed<span class="p">：脏读，不可重复读 </span>repeatable read<span class="p">：可重读</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">serializable <span class="p">：串行事物</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">9<span class="p">、在 </span>Mysql <span class="p">中 </span>ENUM <span class="p">的用法是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">ENUM <span class="p">是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 242%;text-align: left;">Create table size(name ENUM(&#39;Smail,&#39;Medium&#39;,&#39;Large&#39;); 10<span class="p">、如何定义 </span>REGEXP<span class="p">？</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">REGEXP <span class="p">是模式匹配，其中匹配模式在搜索值的任何位置。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">11<span class="p">、</span>CHAR <span class="p">和 </span>VARCHAR <span class="p">的区别？ 以下是 </span>CHAR <span class="p">和 </span>VARCHAR <span class="p">的区别：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">CHAR <span class="p">和 </span>VARCHAR <span class="p">类型在存储和检索方面有所不同</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">CHAR <span class="p">列长度固定为创建表时声明的长度，长度值范围是 </span>1 <span class="p">到 </span>255</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">当 <span class="s84">CHAR </span>值被存储时，它们被用空格填充到特定长度，检索 <span class="s84">CHAR </span>值时需删除尾随空格。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">12<span class="p">、列的字符串类型可以是什么？字符串类型是：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">SET BLOB ENUM CHAR TEXT</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">VARCHAR</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">13<span class="p">、如何获取当前的 </span>Mysql <span class="p">版本？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">SELECT VERSION();<span class="p">用于获取当前 </span>Mysql <span class="p">的版本。 </span>14<span class="p">、</span>Mysql <span class="p">中使用什么存储引擎？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">存储引擎称为表类型，数据使用各种技术存储在文件中。技术涉及：</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">Storage mechanism Locking levels Indexing</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Capabilities and functions.</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">15<span class="p">、</span>Mysql <span class="p">驱动程序是什么？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">以下是 <span class="s84">Mysql </span>中可用的驱动程序： <span class="s84">PHP </span>驱动程序</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 117%;text-align: left;">JDBC <span class="p">驱动程序 </span>ODBC <span class="p">驱动程序 </span>CWRAPPER</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">PYTHON <span class="p">驱动程序 </span>PERL <span class="p">驱动程序 </span>RUBY <span class="p">驱动程序 </span>CAP11PHP <span class="p">驱动程序 </span>Ado.net5.mxj</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">16<span class="p">、</span>TIMESTAMP <span class="p">在 </span>UPDATE CURRENT_TIMESTAMP <span class="p">数据类型上做什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">创建表时 <span class="s84">TIMESTAMP </span>列用 <span class="s84">Zero </span>更新。只要表中的其他字段发生更改，<span class="s84">UPDATE CURRENT_TIMESTAMP </span>修饰符就将时间戳字段更新为当前时间。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">17<span class="p">、主键和候选键有什么区别？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">表格的每一行都由主键唯一标识<span class="s84">,</span>一个表只有一个主键。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">18<span class="p">、如何使用 </span>Unix shell <span class="p">登录 </span>Mysql<span class="p">？我们可以通过以下命令登录：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 120%;text-align: left;">[mysql dir]/bin/mysql -h hostname -u 19<span class="p">、 </span>myisamchk <span class="p">是用来做什么的？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">它用来压缩 <span class="s84">MyISAM </span>表，这减少了磁盘或内存使用。 <span class="s84">20</span>、<span class="s84">MYSQL </span>数据库服务器性能分析的方法命令有哪些<span class="s84">?</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">21<span class="p">、如何控制 </span>HEAP <span class="p">表的最大尺寸？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">Heal <span class="p">表的大小可通过称为 </span>max_heap_table_size <span class="p">的 </span>Mysql <span class="p">配置变量来控制。 </span>22<span class="p">、</span>MyISAM Static <span class="p">和 </span>MyISAM Dynamic <span class="p">有什么区别？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">在 <span class="s84">MyISAM  Static </span>上的所有字段有固定宽度。动态 <span class="s84">MyISAM </span>表将具有像 <span class="s84">TEXT</span>，<span class="s84">BLOB </span>等字段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">MyISAM Static <span class="p">在受损情况下更容易恢复。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">23<span class="p">、</span>federated <span class="p">表是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">federated <span class="p">表，允许访问位于其他服务器数据库上的表。 </span>24<span class="p">、如果一个表有一列定义为 </span>TIMESTAMP<span class="p">，将发生什么？每当行被更改时，时间戳字段将获取当前时间戳。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">25<span class="p">、列设置为 </span>AUTO INCREMENT <span class="p">时，如果在表中达到最大值，会发生什么情况？它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">26<span class="p">、怎样才能找出最后一次插入时分配了哪个自动增量？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">LAST_INSERT_ID <span class="p">将返回由 </span>Auto_increment <span class="p">分配的最后一个值，并且不需要指定表名称。 </span>27<span class="p">、你怎么看到为表格定义的所有索引？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">索引是通过以下方式为表格定义的：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">SHOW INDEX FROM</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">28.<span class="p">、</span>LIKE <span class="p">声明中的％和</span>_<span class="p">是什么意思？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">％对应于 <span class="s84">0 </span>个或更多字符，<span class="s84">_</span>只是 <span class="s84">LIKE </span>语句中的一个字符。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">29<span class="p">、如何在 </span>Unix <span class="p">和 </span>Mysql <span class="p">时间戳之间进行转换？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">UNIX_TIMESTAMP <span class="p">是从 </span>Mysql <span class="p">时间戳转换为 </span>Unix <span class="p">时间戳的命令 </span>FROM_UNIXTIME <span class="p">是从 </span>Unix <span class="p">时间戳转换为 </span>Mysql <span class="p">时间戳的命令 </span>30<span class="p">、列对比运算符是什么？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">在 <span class="s84">SELECT </span>语句的列比较中使用<span class="s84">=</span>，<span class="s84">&lt;&gt;</span>，<span class="s84">&lt;=</span>，<span class="s84">&lt;</span>，<span class="s84">&gt; =</span>，<span class="s84">&gt;</span>，<span class="s84">&lt;&lt;</span>，<span class="s84">&gt;&gt;</span>，<span class="s84">&lt;=&gt;</span>，<span class="s84">AND</span>，<span class="s84">OR </span>或 <span class="s84">LIKE </span>运算符。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">31<span class="p">、我们如何得到受查询影响的行数？行数可以通过以下代码获得：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 237%;text-align: justify;">SELECT COUNT(user_id)FROM users; 32<span class="p">、</span>Mysql <span class="p">查询是否区分大小写？不区分</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">SELECT VERSION(), CURRENT_DATE;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 243%;text-align: left;">SeLect version(), current_date; seleCt vErSiOn(), current_DATE;</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">所有这些例子都是一样的，<span class="s84">Mysql </span>不区分大小写。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">33.<span class="p">、</span>LIKE <span class="p">和 </span>REGEXP <span class="p">操作有什么区别？ </span>LIKE <span class="p">和 </span>REGEXP <span class="p">运算符用于表示</span>^<span class="p">和％。</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 121%;text-align: left;">SELECT * FROM employee WHERE emp_name REGEXP &quot;^b&quot;; SELECT * FROM employee WHERE emp_name LIKE &quot;%b&quot;; 34.<span class="p">、</span>BLOB <span class="p">和 </span>TEXT <span class="p">有什么区别？</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">BLOB <span class="p">是一个二进制对象，可以容纳可变数量的数据。有四种类型的 </span>BLOB - TINYBLOB</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 119%;text-align: left;">BLOB MEDIUMBLOB <span class="p">和 </span>LONGBLOB</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">它们只能在所能容纳价值的最大长度上有所不同。</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">TEXT <span class="p">是一个不区分大小写的 </span>BLOB<span class="p">。四种 </span>TEXT <span class="p">类型 </span>TINYTEXT</p><p class="s84" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 119%;text-align: left;">TEXT MEDIUMTEXT <span class="p">和 </span>LONGTEXT</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">它们对应于四种 <span class="s84">BLOB </span>类型，并具有相同的最大长度和存储要求。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">BLOB <span class="p">和 </span>TEXT <span class="p">类型之间的唯一区别在于对 </span>BLOB <span class="p">值进行排序和比较时区分大小写，对 </span>TEXT</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">值不区分大小写。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">35<span class="p">、</span>mysql_fetch_array <span class="p">和 </span>mysql_fetch_object <span class="p">的区别是什么？以下是 </span>mysql_fetch_array <span class="p">和 </span>mysql_fetch_object <span class="p">的区别：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">mysql_fetch_array<span class="p">（） </span>- <span class="p">将结果行作为关联数组或来自数据库的常规数组返回。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">mysql_fetch_object - <span class="p">从数据库返回结果行作为对象。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 233%;text-align: left;">36<span class="p">、我们如何在 </span>mysql <span class="p">中运行批处理模式？以下命令用于在批处理模式下运行： </span>mysql;</p><p class="s84" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">mysql mysql.out</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">37<span class="p">、</span>MyISAM <span class="p">表格将在哪里存储，并且还提供其存储格式？每个 </span>MyISAM <span class="p">表格以三种格式存储在磁盘上：</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">·“<span class="s84">.frm</span>”文件存储表定义</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">·数据文件具有“<span class="s84">.MYD</span>”（<span class="s84">MYData</span>）扩展名索引文件具有“<span class="s84">.MYI</span>”（<span class="s84">MYIndex</span>）扩展名 <span class="s84">38.</span>、<span class="s84">Mysql </span>中有哪些不同的表格？</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">共有 <span class="s84">5 </span>种类型的表格：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">MyISAM</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">Heap Merge INNODB ISAM</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">MyISAM <span class="p">是 </span>Mysql <span class="p">的默认存储引擎。 </span>39<span class="p">、</span>ISAM <span class="p">是什么？</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">ISAM <span class="p">简称为索引顺序访问方法。它是由 </span>IBM <span class="p">开发的，用于在磁带等辅助存储系统上存储和检索数据。</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">40<span class="p">、</span>InnoDB <span class="p">是什么？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">lnnoDB <span class="p">是一个由 </span>Oracle <span class="p">公司开发的 </span>Innobase Oy <span class="p">事务安全存储引擎。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">41<span class="p">、</span>Mysql <span class="p">如何优化 </span>DISTINCT<span class="p">？</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">DISTINCT <span class="p">在所有列上转换为 </span>GROUP BY<span class="p">，并与 </span>ORDER BY <span class="p">子句结合使用。 </span>1</p><p class="s84" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 120%;text-align: left;">SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a; 42<span class="p">、如何输入字符为十六进制数字？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（<span class="s84">X</span>），或者只用（<span class="s84">Ox</span>）前缀输入十六进制数字。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">43<span class="p">、如何显示前 </span>50 <span class="p">行？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 234%;text-align: left;">在 <span class="s84">Mysql </span>中，使用以下代码查询显示前 <span class="s84">50 </span>行： <span class="s84">SELECT*FROM</span></p><p class="s84" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">LIMIT 0,50;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">44<span class="p">、可以使用多少列创建索引？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">任何标准表最多可以创建 <span class="s84">16 </span>个索引列。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">45<span class="p">、</span>NOW<span class="p">（）和 </span>CURRENT_DATE<span class="p">（）有什么区别？   </span>NOW<span class="p">（）命令用于显示当前年份，月份，日期，小时，分钟和秒。 </span>CURRENT_DATE<span class="p">（）仅显示当前年份，月份和日期。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">46<span class="p">、什么样的对象可以使用 </span>CREATE <span class="p">语句创建？以下对象是使用 </span>CREATE <span class="p">语句创建的：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">DATABASE EVENT FUNCTION INDEX</p><p class="s84" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">PROCEDURE TABLE TRIGGER USER</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">VIEW</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">47<span class="p">、</span>Mysql <span class="p">表中允许有多少个 </span>TRIGGERS<span class="p">？</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">在 <span class="s84">Mysql </span>表中允许有六个触发器，如下： <span class="s84">BEFORE INSERT</span></p><p class="s84" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">AFTER INSERT BEFORE UPDATE AFTER UPDATE BEFORE DELETE AFTER DELETE</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">48<span class="p">、什么是非标准字符串类型？以下是非标准字符串类型：</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">TINYTEXT TEXT MEDIUMTEXT LONGTEXT</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">49<span class="p">、什么是通用 </span>SQL <span class="p">函数？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">CONCAT(A, B) - <span class="p">连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">FORMAT(X, D)- <span class="p">格式化数字 </span>X <span class="p">到 </span>D <span class="p">有效数字。 </span>CURRDATE(), CURRTIME()- <span class="p">返回当前日期或时间。 </span>NOW<span class="p">（） </span>- <span class="p">将当前日期和时间作为一个值返回。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">MONTH<span class="p">（），</span>DAY<span class="p">（），</span>YEAR<span class="p">（），</span>WEEK<span class="p">（），</span>WEEKDAY<span class="p">（） </span>- <span class="p">从日期值中提取给定数据。</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">HOUR<span class="p">（），</span>MINUTE<span class="p">（），</span>SECOND<span class="p">（） </span>- <span class="p">从时间值中提取给定数据。 </span>DATEDIFF<span class="p">（</span>A<span class="p">，</span>B<span class="p">） </span>- <span class="p">确定两个日期之间的差异，通常用于计算年龄 </span>SUBTIMES<span class="p">（</span>A<span class="p">，</span>B<span class="p">） </span>- <span class="p">确定两次之间的差异。</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">FROMDAYS<span class="p">（</span>INT<span class="p">） </span>- <span class="p">将整数天数转换为日期值。</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">50<span class="p">、解释访问控制列表</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">ACL<span class="p">（访问控制列表）是与对象关联的权限列表。这个列表是 </span>Mysql <span class="p">服务器安全模型的基础，它有助于排除用户无法连接的问题。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mysql <span class="p">将 </span>ACL<span class="p">（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，</span>Mysql <span class="p">会按照预定的顺序检查 </span>ACL <span class="p">的认证信息和权限。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">51<span class="p">、</span>MYSQL <span class="p">支持事务吗？</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">在缺省模式下，<span class="s84">MYSQL </span>是 <span class="s84">autocommit </span>模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，<span class="s84">mysql </span>是不支持事务的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">但是如果你的 <span class="s84">MYSQL </span>表类型是使用 <span class="s84">InnoDB Tables </span>或 <span class="s84">BDB tables </span>的话，你的 <span class="s84">MYSQL </span>就可以使用事务处理<span class="s84">,</span>使用 <span class="s84">SET AUTOCOMMIT=0 </span>就可以使 <span class="s84">MYSQL </span>允许在非 <span class="s84">autocommit </span>模式，在非 <span class="s84">autocommit </span>模式下，你必须使用 <span class="s84">COMMIT </span>来提交你的更改，或者用 <span class="s84">ROLLBACK </span>来回滚你的更改。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">示例如下：一</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">START TRANSACTION;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 243%;text-align: left;">SELECT @A:=SUM(salary) FROM table1 WHERE type=1; UPDATE table2 SET summmary=@A WHERE type=1; COMMIT;</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">52<span class="p">、</span>mysql <span class="p">里记录货币用什么字段类型好</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">NUMERIC <span class="p">和 </span>DECIMAL <span class="p">类型被 </span>Mysql <span class="p">实现为同样的类型，这在 </span>SQL92 <span class="p">标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被</span>(<span class="p">并且通常是</span>)<span class="p">指定；点击这里有一套最全阿里面试题总</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">结。 例如：</p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">salary DECIMAL(9,2)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">在这个例子中，<span class="s84">9(precision)</span>代表将被用于存储值的总的小数位数，而 <span class="s84">2(scale)</span>代表将被用于存储小数点后的位数。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">因此，在这种情况下，能被存储在 <span class="s84">salary </span>列中的值的范围是从<span class="s84">-9999999.99 </span>到 <span class="s84">9999999.99</span>。在 <span class="s84">ANSI/ISO SQL92 </span>中，句法 <span class="s84">DECIMAL(p)</span>等价于 <span class="s84">DECIMAL(p,0)</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">同样，句法 <span class="s84">DECIMAL </span>等价于 <span class="s84">DECIMAL(p,0)</span>，这里实现被允许决定值 <span class="s84">p</span>。<span class="s84">Mysql </span>当前不支持 <span class="s84">DECIMAL/NUMERIC </span>数据类型的这些变种形式的任一种。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">DECIMAL <span class="p">和 </span>NUMERIC <span class="p">值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">一个字符用于值的每一位、小数点<span class="s84">(</span>如果 <span class="s84">scale&gt;0)</span>和“<span class="s84">-</span>”符号<span class="s84">(</span>对于负值<span class="s84">)</span>。如果 <span class="s84">scale </span>是 <span class="s84">0</span>， <span class="s84">DECIMAL </span>和 <span class="s84">NUMERIC </span>值不包含小数点或小数部分。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">DECIMAL <span class="p">和 </span>NUMERIC <span class="p">值得最大的范围与 </span>DOUBLE <span class="p">一样，但是对于一个给定的 </span>DECIMAL <span class="p">或</span></p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">NUMERIC <span class="p">列，实际的范围可由制由给定列的 </span>precision <span class="p">或 </span>scale <span class="p">限制。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">当这样的列赋给了小数点后面的位超过指定 <span class="s84">scale </span>所允许的位的值，该值根据 <span class="s84">scale </span>四舍五入。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">当一个 <span class="s84">DECIMAL </span>或 <span class="s84">NUMERIC </span>列被赋给了其大小超过指定<span class="s84">(</span>或缺省的）<span class="s84">precision </span>和 <span class="s84">scale </span>隐含的范围的值，<span class="s84">Mysql </span>存储表示那个范围的相应的端点值。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困境的第一步。</p><p class="s84" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">53<span class="p">、</span>MYSQL <span class="p">数据表在什么情况下容易损坏？服务器突然断电导致数据文件损坏。</span></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 12pt;text-align: left;">强制关机，没有先关闭 <span class="s84">mysql </span>服务等。</p><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">54<span class="p">、</span>mysql <span class="p">有关权限的表都有哪几个？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mysql <span class="p">服务器通过权限表来控制用户对数据库的访问，权限表存放在 </span>mysql <span class="p">数据库里，由 </span>mysql_install_db <span class="p">脚本初始化。这些权限表分别 </span>user<span class="p">，</span>db<span class="p">，</span>table_priv<span class="p">，</span>columns_priv <span class="p">和 </span>host<span class="p">。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">55<span class="p">、</span>Mysql <span class="p">中有哪几种锁？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">MyISAM <span class="p">支持表锁，</span>InnoDB <span class="p">支持表锁和行锁，默认为行锁</span></p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高</p><p class="s140" style="padding-left: 23pt;text-indent: 0pt;line-height: 21pt;text-align: left;">1<span class="s141">、</span>Tomcat <span class="s141">的缺省端口是多少，怎么修改？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 202%;text-align: left;">1<span class="s17">）找到 </span>Tomcat <span class="s17">目录下的 </span>conf <span class="s17">文件夹 </span>2<span class="s17">）进入 </span>conf <span class="s17">文件夹里面找到 </span>server.xml <span class="s17">文件 </span>3<span class="s17">）打开 </span>server.xml <span class="s17">文件</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">4<span class="s17">）在 </span>server.xml <span class="s17">文件里面找到下列信息</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 112%;text-align: left;">&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">port=&quot;8080&quot;<span class="s17">改成你想要的端口</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s140" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">2<span class="s141">、</span>tomcat <span class="s141">有哪几种 </span>Connector <span class="s141">运行模式</span>(<span class="s141">优化</span>)<span class="s141">？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">bio<span class="s17">：传统的 </span>Java I/O <span class="s17">操作，同步且阻塞 </span>IO<span class="s17">。 </span>maxThreads=<span class="s17">”</span>150<span class="s17">”</span>//Tomcat <span class="s17">使用线程来处理接收的每个请求。这个值表示</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Tomcat <span class="s17">可创建的最大的线程数。默认值 </span>200<span class="s17">。可以根据机器的时期性能和内存大小调整，一般可以在 </span>400-500<span class="s17">。最大可以在 </span>800 <span class="s17">左右。 </span>minSpareThreads=<span class="s17">”</span>25<span class="s17">”—</span>Tomcat <span class="s17">初始化时创建的线程数。默认值 </span>4<span class="s17">。如果当前没有空闲线程，且没有超过 </span>maxThreads<span class="s17">，一次性创建的空闲线程数量。 </span>Tomcat <span class="s17">初始化时创建的线程数量也由此值设置。 </span>maxSpareThreads=<span class="s17">”</span>75<span class="s17">”–一旦创建的线程超过这个值，</span>Tomcat <span class="s17">就会关闭不再需要的 </span>socket <span class="s17">线程。默认值 </span>50<span class="s17">。一旦创建的线程超过此数值，</span>Tomcat <span class="s17">会关闭不再需要的线程。线程数可以大致上用 “同时在线人数每秒用户操作次数系统平均操作时间” 来计算。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">acceptCount=<span class="s17">”</span>100<span class="s17">”—</span>-<span class="s17">指定当所有可以使用的处理请求的线程数都被使用 时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值 </span>10<span class="s17">。如果当前可用线程数为 </span>0<span class="s17">，则将请求放入处理队列中。这个值限定了请求队列的大小，超过这个数值的请求将不予处理。 </span>connectionTimeout=<span class="s17">”</span>20000<span class="s17">”  –网络连接超时，默认值 </span>20000<span class="s17">，单位：毫秒。设置为 </span>0 <span class="s17">表示永不超时，这样设置有隐患的。通常可设置为 </span>30000 <span class="s17">毫秒。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">nio<span class="s17">：</span>JDK1.4 <span class="s17">开始支持，同步阻塞或同步非阻塞 </span>IO<span class="s17">。指定使用 </span>NIO <span class="s17">模型来接受 </span>HTTP <span class="s17">请求</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">protocol=<span class="s17">”</span>org.apache.coyote.http11.Http11NioProtocol<span class="s17">” 指定使用 </span>NIO <span class="s17">模型来接受 </span>HTTP <span class="s17">请求。默认是 </span>BlockingIO<span class="s17">，配置为 </span>protocol=<span class="s17">”</span>HTTP/1.1<span class="s17">” </span>acceptorThreadCount=<span class="s17">”</span>2<span class="s17">” 使用 </span>NIO <span class="s17">模型时接收线程的数目</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">aio(nio.2)<span class="s17">：</span>JDK7 <span class="s17">开始支持，异步非阻塞 </span>IO<span class="s17">。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">apr<span class="s17">：</span>Tomcat <span class="s17">将以 </span>JNI <span class="s17">的形式调用 </span>Apache  HTTP <span class="s17">服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高 </span>Tomcat <span class="s17">对静态文件的处理性能。</span></p><p class="s142" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;!--</p><p class="s142" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">&lt;Connector      connectionTimeout=&quot;20000&quot;      port=&quot;8000&quot;</p><p class="s142" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; uriEncoding=&quot;utf-8&quot;/&gt;</p><p class="s142" style="padding-top: 1pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">--&gt;</p><p class="s142" style="padding-top: 1pt;padding-left: 23pt;text-indent: 24pt;text-align: left;">&lt;!-- protocol <span class="s17">启用 </span>nio <span class="s17">模式，</span>(tomcat8 <span class="s17">默认使用的是 </span>nio)(apr <span class="s17">模式利用系统级异步 </span>io) --&gt;</p><p class="s142" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;!-- minProcessors <span class="s17">最小空闲连接线程数</span>--&gt;</p><p class="s142" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;!-- maxProcessors <span class="s17">最大连接线程数</span>--&gt;</p><p class="s142" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;!-- acceptCount <span class="s17">允许的最大连接数，应大于等于 </span>maxProcessors--&gt;</p><p class="s142" style="padding-left: 23pt;text-indent: 24pt;text-align: left;">&lt;!-- enableLookups <span class="s17">如果为 </span>true,requst.getRemoteHost <span class="s17">会执行 </span>DNS <span class="s17">查找，反向解析 </span>ip <span class="s17">对应域名或主机名</span>--&gt;</p><p class="s142" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">&lt;Connector                             port=&quot;8080&quot;</p><p class="s142" style="padding-top: 1pt;padding-left: 71pt;text-indent: -48pt;line-height: 112%;text-align: left;">protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443</p><p class="s142" style="padding-left: 71pt;text-indent: 0pt;line-height: 112%;text-align: left;">maxThreads=“500” minSpareThreads=“100” maxSpareThreads=“200” acceptCount=&quot;200&quot; enableLookups=&quot;false&quot;</p><p class="s142" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">/&gt;</p><p class="s17" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">其他配置</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">maxHttpHeaderSize=&quot;8192&quot;  http <span class="s17">请求头信息的最大程度，超过此长度的部分不予处理。一般 </span>8K<span class="s17">。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">URIEncoding=&quot;UTF-8&quot; <span class="s17">指定 </span>Tomcat <span class="s17">容器的 </span>URL <span class="s17">编码格式。 </span>disableUploadTimeout=&quot;true&quot; <span class="s17">上传时是否使用超时机制 </span>enableLookups=&quot;false&quot;--<span class="s17">是否反查域名，默认值为 </span>true<span class="s17">。为了提高处理能力，应设置为 </span>false</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">compression=&quot;on&quot; <span class="s17">打开压缩功能</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">compressionMinSize=&quot;10240&quot; <span class="s17">启用压缩的输出内容大小，默认为 </span>2KB noCompressionUserAgents=&quot;gozilla, traviata&quot; <span class="s17">对于以下的浏览器，不启用压缩 </span>compressableMimeType=&quot;text/html,text/xml,text/javascript,text/css,text/plain&quot;<span class="s17">哪些资源类型需要压缩</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s140" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">3<span class="s141">、</span>Tomcat <span class="s141">有几种部署方式？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l122"><li data-list-text="1）"><p class="s17" style="padding-left: 41pt;text-indent: -18pt;text-align: left;">直接把 <span class="s142">Web </span>项目放在 <span class="s142">webapps </span>下，<span class="s142">Tomcat </span>会自动将其部署</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2）"><p class="s17" style="padding-left: 41pt;text-indent: -18pt;text-align: left;">在 <span class="s142">server.xml </span>文件上配置<span class="s142">&lt;Context&gt;</span>节点，设置相关的属性即可</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3）"><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">通过 <span class="s142">Catalina </span>来进行配置<span class="s142">:</span>进入到 <span class="s142">conf\Catalina\localhost </span>文件下，创建一个 <span class="s142">xml </span>文件，该文件的名字就是站点的名字。</p><p class="s17" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">编写 <span class="s142">XML </span>的方式来进行设置。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s140" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">4<span class="s141">、</span>tomcat <span class="s141">容器是如何创建 </span>servlet <span class="s141">类实例？用到了什么原理？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">当容器启动时，会读取在 <span class="s142">webapps </span>目录下所有的 <span class="s142">web </span>应用中的 <span class="s142">web.xml </span>文件，然后对 <span class="s142">xml </span>文件进行解析，</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">并读取 <span class="s142">servlet </span>注册信息。然后，将每个应用中注册的 <span class="s142">servlet </span>类都进行加载，并通过反射的方式实例化。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">（有时候也是在第一次请求时实例化）在 <span class="s142">servlet </span>注册时加上如果为正数，则在一开始就实例化，</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">如果不写或为负数，则第一次请求实例化。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l123"><li data-list-text="5."><p class="s140" style="padding-left: 33pt;text-indent: -10pt;text-align: left;">tomcat <span class="s141">如何优化？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">1<span class="s17">、优化连接配置</span>.<span class="s17">这里以 </span>tomcat7 <span class="s17">的参数配置为例，需要修改 </span>conf/server.xml</p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;line-height: 202%;text-align: left;">文件，修改连接数，关闭客户端 <span class="s142">dns </span>查询。参数解释：</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">URIEncoding=<span class="s17">”</span>UTF-8<span class="s17">″ </span>:<span class="s17">使得 </span>tomcat <span class="s17">可以解析含有中文名的文件的 </span>url<span class="s17">，真方便，不像 </span>apache <span class="s17">里还有搞个 </span>mod_encoding<span class="s17">，还要手工编译</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">maxSpareThreads : <span class="s17">如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">minSpareThreads : <span class="s17">最小备用线程数，</span>tomcat <span class="s17">启动时的初始化的线程数。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">enableLookups : <span class="s17">这个功效和 </span>Apache <span class="s17">中的 </span>HostnameLookups <span class="s17">一样，设为关闭。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">connectionTimeout : connectionTimeout <span class="s17">为网络连接超时时间毫秒数。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">maxThreads : maxThreads Tomcat <span class="s17">使用线程来处理接收的每个请求。这个值表示 </span>Tomcat <span class="s17">可创建的最大的线程数，即最大并发数。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">acceptCount : acceptCount <span class="s17">是当线程数达到 </span>maxThreads <span class="s17">后，后续请求会被放入一个等待队列，这个 </span>acceptCount <span class="s17">是这个队列的大小，如果这个队列也满 了，就直接 </span>refuse connection</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">maxProcessors <span class="s17">与 </span>minProcessors : <span class="s17">在 </span>Java <span class="s17">中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同</span></p><p class="s17" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">的地址空间。多线程帮助程序员写出 <span class="s142">CPU </span>最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">通常 <span class="s142">Windows </span>是 <span class="s142">1000 </span>个左右，<span class="s142">Linux </span>是 <span class="s142">2000 </span>个左右。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">useURIValidationHack:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">我们来看一下 <span class="s142">tomcat </span>中的一段源码：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">【<span class="s142">security</span>】</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 225%;text-align: left;">if (connector.getUseURIValidationHack()) { String uri = validate(request.getRequestURI()); if (uri == null) {</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 225%;text-align: left;">res.setStatus(400); res.setMessage(“Invalid URI”);</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">throw new IOException(“Invalid URI”);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 225%;text-align: left;">} else { req.requestURI().setString(uri);</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 225%;text-align: left;">// Redoing the URI decoding req.decodedURI().duplicate(req.requestURI()); req.getURLDecoder().convert(req.decodedURI(), true);</p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">可以看到如果把 <span class="s142">useURIValidationHack </span>设成”<span class="s142">false</span>”，可以减少它对一些 <span class="s142">url</span></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">的不必要的检查从而减省开销。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">enableLookups=<span class="s17">”</span>false<span class="s17">” ： 为了消除 </span>DNS <span class="s17">查询对性能的影响我们可以关闭</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">DNS <span class="s17">查询，方式是修改 </span>server.xml <span class="s17">文件中的 </span>enableLookups <span class="s17">参数值。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 202%;text-align: left;">disableUploadTimeout <span class="s17">：类似于 </span>Apache <span class="s17">中的 </span>keeyalive <span class="s17">一样给 </span>Tomcat <span class="s17">配置 </span>gzip <span class="s17">压缩</span>(HTTP <span class="s17">压缩</span>)<span class="s17">功能 </span>compression=<span class="s17">”</span>on<span class="s17">” </span>compressionMinSize=<span class="s17">”</span>2048<span class="s17">″</span></p><p class="s142" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">compressableMimeType=”text/html,text/xml,text/JavaScript,text/css,text/plain”</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">HTTP <span class="s17">压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的浏览过程 </span>HTML,CSS,javascript , Text <span class="s17">，它可以节省 </span>40%<span class="s17">左右的流量。更为重要的是，它可以对动态生成的，包括 </span>CGI<span class="s17">、</span>PHP  , JSP , ASP , Servlet,SHTML <span class="s17">等输出的网页也能进行压缩，压缩效率惊人。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l124"><li data-list-text="1)"><p class="s142" style="padding-left: 33pt;text-indent: -10pt;text-align: left;">compression=<span class="s17">”</span>on<span class="s17">” 打开压缩功能</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2)"><p class="s142" style="padding-left: 33pt;text-indent: -10pt;text-align: left;">compressionMinSize=<span class="s17">”</span>2048<span class="s17">″ 启用压缩的输出内容大小，这里面默认为</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">2KB</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3)"><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">noCompressionUserAgents=<span class="s17">”</span>gozilla, traviata<span class="s17">” 对于以下的浏览器，不启用压缩</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4)"><p class="s142" style="padding-left: 33pt;text-indent: -10pt;text-align: left;">compressableMimeType=<span class="s17">”</span>text/html,text/xml<span class="s17">” 压缩类型</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">最后不要忘了把 <span class="s142">8443 </span>端口的地方也加上同样的配置，因为如果我们走 <span class="s142">https </span>协议的话，我们将会用到 <span class="s142">8443 </span>端口这个段的配置，对吧？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;!–enable tomcat ssl–&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">&lt;Connector port=<span class="s17">”</span>8443<span class="s17">″ </span>protocol=<span class="s17">”</span>HTTP/1.1<span class="s17">″</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">URIEncoding=<span class="s17">”</span>UTF-8<span class="s17">″ </span>minSpareThreads=<span class="s17">”</span>25<span class="s17">″ </span>maxSpareThreads=<span class="s17">” </span>75<span class="s17">″</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">enableLookups=<span class="s17">”</span>false<span class="s17">”        </span>disableUploadTimeout=<span class="s17">”</span>true<span class="s17">” </span>connectionTimeout=<span class="s17">”</span>20000<span class="s17">″</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">acceptCount=<span class="s17">”</span>300<span class="s17">″  </span>maxThreads=<span class="s17">”</span>300<span class="s17">″  </span>maxProcessors=<span class="s17">”</span>1000<span class="s17">″ </span>minProcessors=<span class="s17">”</span>5<span class="s17">″</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">useURIValidationHack=”false”</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 217%;text-align: left;">compression=<span class="s17">”</span>on<span class="s17">” </span>compressionMinSize=<span class="s17">”</span>2048<span class="s17">″ </span>compressableMimeType=”text/html,text/xml,text/javascript,text/css,text/plain” SSLEnabled=”true”</p><p class="s142" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">scheme=”https” secure=”true”</p><p class="s142" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 225%;text-align: left;">clientAuth=”false” sslProtocol=”TLS” keystoreFile=”d:/tomcat2/conf/shnlap93.jks” keystorePass=”aaaaaa”</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">/&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">好了，所有的 <span class="s142">Tomcat </span>优化的地方都加上了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="6."><p class="s141" style="padding-left: 33pt;text-indent: -10pt;text-align: left;">内存调优</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">内存方式的设置是在 <span class="s142">catalina.sh </span>中，调整一下 <span class="s142">JAVA_OPTS </span>变量即可，因为后面的启动参数会把 <span class="s142">JAVA_OPTS </span>作为 <span class="s142">JVM </span>的启动参数来处理。</p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">具体设置如下：</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">JAVA_OPTS=&quot;$JAVA_OPTS  -Xmx3550m  -Xms3550m  -Xss128k  -</p><p class="s142" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">XX:NewRatio=4 -XX:SurvivorRatio=4&quot;</p><p class="s17" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">其各项参数如下：</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-Xmx3550m<span class="s17">：设置 </span>JVM <span class="s17">最大可用内存为 </span>3550M<span class="s17">。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-Xms3550m<span class="s17">：设置 </span>JVM <span class="s17">促使内存为 </span>3550m<span class="s17">。此值可以设置与</span>-Xmx <span class="s17">相同，以避免每次垃圾回收完成后 </span>JVM <span class="s17">重新分配内存。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-Xmn2g<span class="s17">：设置年轻代大小为 </span>2G<span class="s17">。整个堆大小</span>=<span class="s17">年轻代大小 </span>+ <span class="s17">年老代大小 </span>+<span class="s17">持久代大小。持久代一般固定大小为 </span>64m<span class="s17">，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，</span>Sun <span class="s17">官方推荐配置为整个堆的 </span>3/8<span class="s17">。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-Xss128k<span class="s17">：设置每个线程的堆栈大小。</span>JDK5.0 <span class="s17">以后每个线程堆栈大小为 </span>1M<span class="s17">，以前每个线程堆栈大小为 </span>256K<span class="s17">。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 </span>3000~5000 <span class="s17">左右。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:NewRatio=4:<span class="s17">设置年轻代（包括 </span>Eden <span class="s17">和两个 </span>Survivor <span class="s17">区）与年老代的比值（除去持久代）。设置为 </span>4<span class="s17">，则年轻代与年老代所占比值为 </span>1<span class="s17">：</span>4<span class="s17">，年轻代占整个堆栈的 </span>1/5</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:SurvivorRatio=4<span class="s17">：设置年轻代中 </span>Eden <span class="s17">区与 </span>Survivor <span class="s17">区的大小比值。设置为 </span>4<span class="s17">，则两个 </span>Survivor <span class="s17">区与一个 </span>Eden <span class="s17">区的比值为 </span>2:4<span class="s17">，一个 </span>Survivor <span class="s17">区占整个年轻代的 </span>1/6</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:MaxPermSize=16m:<span class="s17">设置持久代大小为 </span>16m<span class="s17">。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:MaxTenuringThreshold=0<span class="s17">：设置垃圾最大年龄。如果设置为 </span>0 <span class="s17">的话，则年轻代对象不经过 </span>Survivor <span class="s17">区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在 </span>Survivor <span class="s17">区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</span></p></li><li data-list-text="7."><p class="s141" style="padding-left: 33pt;text-indent: -10pt;line-height: 18pt;text-align: left;">垃圾回收策略调优</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">垃圾回收的设置也是在 <span class="s142">catalina.sh </span>中，调整 <span class="s142">JAVA_OPTS </span>变量。具体设置如下：</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">JAVA_OPTS=&quot;$JAVA_OPTS  -Xmx3550m  -Xms3550m  -Xss128k  -</p><p class="s142" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">XX:+UseParallelGC -XX:MaxGCPauseMillis=100&quot;<span class="s17">具体的垃圾回收策略及相应策略的各项参数如下：串行收集器（</span>JDK1.5 <span class="s17">以前主要的回收方式）</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:+UseSerialGC:<span class="s17">设置串行收集器并行收集器（吞吐量优先）</span></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">示例：</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 112%;text-align: left;">java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  - XX:MaxGCPauseMillis=100</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:+UseParallelGC<span class="s17">：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:ParallelGCThreads=20<span class="s17">：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:+UseParallelOldGC<span class="s17">：配置年老代垃圾收集方式为并行收集。</span>JDK6.0 <span class="s17">支持对年老代并行收集</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:MaxGCPauseMillis=100:<span class="s17">设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，</span>JVM <span class="s17">会自动调整年轻代大小，以满足此值。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:+UseAdaptiveSizePolicy<span class="s17">：设置此选项后，并行收集器会自动选择年轻代区大小和相应的 </span>Survivor <span class="s17">区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</span></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">并发收集器（响应时间优先）</p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;line-height: 106%;text-align: left;">示例：<span class="s142">java   -Xmx3550m   -Xms3550m   -Xmn2g   -Xss128k   - XX:+UseConcMarkSweepGC</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">-XX:+UseConcMarkSweepGC<span class="s17">：设置年老代为并发收集。测试中配置这个以后，</span>-XX:NewRatio=4 <span class="s17">的配置失效了，原因不明。所以，此时年轻代大小最好用</span>-Xmn <span class="s17">设置。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:+UseParNewGC: <span class="s17">设置年轻代为并行收集。可与 </span>CMS <span class="s17">收集同时使用。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">JDK5.0 <span class="s17">以上，</span>JVM <span class="s17">会根据系统配置自行设置，所以无需再设置此值。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:CMSFullGCsBeforeCompaction<span class="s17">：由于并发收集器不对内存空间进行压 缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次 </span>GC <span class="s17">以后对内存空间进行压缩、整理。</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:+UseCMSCompactAtFullCollection<span class="s17">：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="8."><p class="s141" style="padding-left: 33pt;text-indent: -10pt;text-align: left;">共享 <span class="s140">session </span>处理</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">目前的处理方式有如下几种：</p><ol id="l125"><li data-list-text="1)."><p class="s17" style="padding-left: 37pt;text-indent: -14pt;text-align: left;">使用 <span class="s142">Tomcat </span>本身的 <span class="s142">Session </span>复制功能</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://ajita.iteye.com/blog/1715312" style=" color: #333; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt;" target="_blank">参考 </a>http://ajita.iteye.com/blog/1715312<span class="s17">（</span>Session <span class="s17">复制的配置）</span></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">方案的有点是配置简单，缺点是当集群数量较多时，<span class="s142">Session </span>复制的时间会比较长，影响响应的效率</p></li><li data-list-text="2)."><p class="s17" style="padding-left: 37pt;text-indent: -14pt;text-align: left;">使用第三方来存放共享 <span class="s142">Session</span></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">目前用的较多的是使用 <span class="s142">memcached </span>来管理共享 <span class="s142">Session</span>，借助于 <span class="s142">memcached-sesson-manager </span>来进行 <span class="s142">Tomcat </span>的 <span class="s142">Session </span>管理</p><p class="s142" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://ajita.iteye.com/blog/1716320" style=" color: #333; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt;" target="_blank">参考 </a>http://ajita.iteye.com/blog/1716320<span class="s17">（使用 </span>MSM <span class="s17">管理 </span>Tomcat <span class="s17">集群 </span>session<span class="s17">）</span></p></li><li data-list-text="3)."><p class="s17" style="padding-left: 37pt;text-indent: -14pt;text-align: left;">使用黏性 <span class="s142">session </span>的策略</p></li></ol><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">对于会话要求不太强（不涉及到计费，失败了允许重新请求下等）的场合，同一个用户的 <span class="s142">session </span>可以由 <span class="s142">nginx </span>或者 <span class="s142">apache </span>交给同一个 <span class="s142">Tomcat </span>来处理，这就是所谓的 <span class="s142">session sticky </span>策略，目前应用也比较多</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://ajita.iteye.com/blog/1848665" style=" color: #333; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt;" target="_blank">参考：</a>http://ajita.iteye.com/blog/1848665<span class="s17">（</span>tomcat session sticky<span class="s17">）</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">nginx <span class="s17">默认不包含 </span>session sticky <span class="s17">模块，需要重新编译才行（</span>windows <span class="s17">下我也不知道怎么重新编译）</span></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;line-height: 14pt;text-align: left;">优点是处理效率高多了，缺点是强会话要求的场合不合适</p><ol id="l126"><li data-list-text="8."><p class="s141" style="padding-left: 33pt;text-indent: -10pt;line-height: 20pt;text-align: left;">添加 <span class="s140">JMS </span>远程监控</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">对于部署在局域网内其它机器上的 <span class="s142">Tomcat</span>，可以打开 <span class="s142">JMX </span>监控端口，局域网其它机器就可以通过这个端口查看一些常用的参数（但一些比较复杂的功能不支持），同样是在 <span class="s142">JVM </span>启动参数中配置即可，配置如下：</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 112%;text-align: left;">-Dcom.sun.management.jmxremote.ssl=false                  - Dcom.sun.management.jmxremote.authenticate=false</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">-Djava.rmi.server.hostname=192.168.71.38 <span class="s17">设置 </span>JVM <span class="s17">的 </span>JMS <span class="s17">监控监听的 </span>IP</p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">地址，主要是为了防止错误的监听成 <span class="s142">127.0.0.1 </span>这个内网地址</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-Dcom.sun.management.jmxremote.port=1090 <span class="s17">设置 </span>JVM <span class="s17">的 </span>JMS <span class="s17">监控的端口</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 106%;text-align: left;">-Dcom.sun.management.jmxremote.ssl=false <span class="s17">设置 </span>JVM <span class="s17">的 </span>JMS <span class="s17">监控不实用 </span>SSL</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-Dcom.sun.management.jmxremote.authenticate=false <span class="s17">设置 </span>JVM <span class="s17">的 </span>JMS <span class="s17">监控不需要认证</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="9."><p class="s141" style="padding-left: 33pt;text-indent: -10pt;text-align: left;">专业点的分析工具有</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">IBM ISA<span class="s17">，</span>JProfiler<span class="s17">、</span>probe <span class="s17">等，具体监控及分析方式去网上搜索即可</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="10."><p class="s141" style="padding-left: 39pt;text-indent: -16pt;text-align: left;">关于 <span class="s140">Tomcat </span>的 <span class="s140">session </span>数目</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">这个可以直接从 <span class="s142">Tomcat </span>的 <span class="s142">web </span>管理界面去查看即可 ；</p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">或者借助于第三方工具 <span class="s142">Lambda  Probe </span>来查看，它相对于 <span class="s142">Tomcat </span>自带的管理稍微多了点功能，但也不多 ；</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="11."><p class="s141" style="padding-left: 39pt;text-indent: -16pt;text-align: left;">监视 <span class="s140">Tomcat </span>的内存使用情况</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">使用 <span class="s142">JDK </span>自带的 <span class="s142">jconsole </span>可以比较明了的看到内存的使用情况，线程的状态，当前加载的类的总量等；</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">JDK <span class="s17">自带的 </span>jvisualvm <span class="s17">可以下载插件（如 </span>GC <span class="s17">等），可以查看更丰富的信息。如果是分析本地的 </span>Tomcat <span class="s17">的话，还可以进行内存抽样等，检查每个类的使用情况</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="12."><p class="s141" style="padding-left: 39pt;text-indent: -16pt;text-align: left;">打印类的加载情况及对象的回收情况</p><p class="s17" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">这个可以通过配置 <span class="s142">JVM </span>的启动参数，打印这些信息（到屏幕（默认也会到 <span class="s142">catalina.log </span>中）或者文件），具体参数如下：</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 106%;text-align: justify;">-XX:+PrintGC<span class="s17">：输出形式：</span>[GC  118250K-&gt;113543K(130112K),  0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 111%;text-align: justify;">-XX:+PrintGCDetails<span class="s17">：输出形式：</span>[GC   [DefNew:   8614K-&gt;781K(9088K), 0.0123035  secs]  118250K-&gt;113543K(130112K),  0.0124633  secs]  [GC [DefNew:    8614K-&gt;8614K(9088K),    0.0000665    secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K),</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">0.0436268 secs]</p><p class="s142" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">-XX:+PrintGCTimeStamps -XX:+PrintGC<span class="s17">：</span>PrintGCTimeStamps <span class="s17">可与上面两个混合使用，输出形式：</span>11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">secs]</p><p class="s142" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:+PrintGCApplicationConcurrentTime<span class="s17">：打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式：</span>Application  time:  0.5291524 seconds</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:+PrintGCApplicationStoppedTime<span class="s17">：打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：</span>Total time for which application threads were stopped: 0.0468229 seconds</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-XX:PrintHeapAtGC: <span class="s17">打印 </span>GC <span class="s17">前后的详细堆栈信息</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-Xloggc:filename:<span class="s17">与上面几个配合使用，把相关日志信息记录到文件以便分析</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-verbose:class <span class="s17">监视加载的类的情况</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-verbose:gc <span class="s17">在虚拟机发生内存回收时在输出设备显示信息</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-verbose:jni <span class="s17">输出 </span>native <span class="s17">方法调用的相关情况，一般用于诊断 </span>jni <span class="s17">调用错误信息</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="13."><p class="s140" style="padding-left: 39pt;text-indent: -16pt;text-align: left;">Tomcat <span class="s141">一个请求的完整过程</span></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">Ng:(nginx) upstream yy_001{</p><p class="s142" style="padding-left: 71pt;text-indent: 0pt;line-height: 12pt;text-align: left;">server 10.99.99.99:8080;</p><p class="s142" style="padding-top: 1pt;padding-left: 71pt;text-indent: 0pt;text-align: left;">server 10.99.99.100:8080;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">hash $**;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 71pt;text-indent: 0pt;line-height: 112%;text-align: left;">healthcheck_enabled; healthcheck_delay 3000;</p><p class="s142" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">healthcheck_timeout 1000;</p><p class="s142" style="padding-top: 1pt;padding-left: 71pt;text-indent: 0pt;text-align: left;">healthcheck_failcount 2;</p><p class="s142" style="padding-top: 1pt;padding-left: 23pt;text-indent: 48pt;line-height: 112%;text-align: left;">healthcheck_send &#39;GET /healthcheck.html HTTP/1.0&#39; &#39;Host: wo.com&#39; &#39;Connection: close&#39;;</p><p class="s142" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">server {</p><p class="s142" style="padding-top: 4pt;padding-left: 71pt;text-indent: 0pt;line-height: 112%;text-align: left;">include base.conf; server_name wo.de.tian;</p><p class="s142" style="padding-left: 77pt;text-indent: 0pt;text-align: left;">...</p><p class="s142" style="padding-top: 1pt;padding-left: 71pt;text-indent: 0pt;text-align: left;">location /yy/ {</p><p class="s142" style="padding-top: 1pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">proxy_pass http://yy_001;</p><p class="s142" style="padding-top: 1pt;padding-left: 71pt;text-indent: 0pt;text-align: left;">}</p><p class="s17" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">首先 <span class="s142">dns </span>解析 <span class="s142">wo.de.tian </span>机器，一般是 <span class="s142">ng </span>服务器 <span class="s142">ip </span>地址</p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">然后 <span class="s142">ng </span>根据 <span class="s142">server </span>的配置，寻找路径为 <span class="s142">yy/</span>的机器列表，<span class="s142">ip </span>和端口最后 选择其中一台机器进行访问—<span class="s142">-&gt;</span>下面为详细过程</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l127"><li data-list-text="1)"><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">请求被发送到本机端口 <span class="s142">8080</span>，被在那里侦听的 <span class="s142">Coyote   HTTP/1.1 Connector </span>获得</p></li><li data-list-text="2)"><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Connector <span class="s17">把该请求交给它所在的 </span>Service <span class="s17">的 </span>Engine <span class="s17">来处理，并等待来自 </span>Engine <span class="s17">的回应</span></p></li><li data-list-text="3)"><p class="s142" style="padding-left: 37pt;text-indent: -14pt;text-align: left;">Engine <span class="s17">获得请求 </span>localhost/yy/index.jsp<span class="s17">，匹配它所拥有的所有虚拟主机 </span>Host</p></li><li data-list-text="4)"><p class="s142" style="padding-left: 46pt;text-indent: -23pt;text-align: left;">Engine <span class="s17">匹配到名为 </span>localhost <span class="s17">的 </span>Host<span class="s17">（即使匹配不到也把请求交给该 </span>Host</p><p class="s17" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">处理，因为该 <span class="s142">Host </span>被定义为该 <span class="s142">Engine </span>的默认主机）</p></li><li data-list-text="5)"><p class="s142" style="padding-left: 37pt;text-indent: -14pt;text-align: left;">localhost Host <span class="s17">获得请求</span>/yy/index.jsp<span class="s17">，匹配它所拥有的所有 </span>Context</p></li><li data-list-text="6)"><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Host <span class="s17">匹配到路径为</span>/yy <span class="s17">的 </span>Context<span class="s17">（如果匹配不到就把该请求交给路径名为”“的 </span>Context <span class="s17">去处理）</span></p></li><li data-list-text="7)"><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">path=<span class="s17">”</span>/yy<span class="s17">”的 </span>Context <span class="s17">获得请求</span>/index.jsp<span class="s17">，在它的 </span>mapping table <span class="s17">中寻找对应的 </span>servlet</p></li><li data-list-text="8)"><p class="s142" style="padding-left: 37pt;text-indent: -14pt;text-align: left;">Context <span class="s17">匹配到 </span>URL PATTERN <span class="s17">为</span>*.jsp <span class="s17">的 </span>servlet<span class="s17">，对应于 </span>JspServlet <span class="s17">类</span></p></li><li data-list-text="9)"><p class="s17" style="padding-left: 39pt;text-indent: -16pt;text-align: left;">构造 <span class="s142">HttpServletRequest </span>对象和 <span class="s142">HttpServletResponse </span>对象，作为参数调用</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">JspServlet <span class="s17">的 </span>doGet <span class="s17">或 </span>doPost <span class="s17">方法</span></p></li><li data-list-text="10)"><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Context <span class="s17">把执行完了之后的 </span>HttpServletResponse <span class="s17">对象返回给 </span>Host 11)Host <span class="s17">把 </span>HttpServletResponse <span class="s17">对象返回给 </span>Engine</p></li></ol><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">12)Engine <span class="s17">把 </span>HttpServletResponse <span class="s17">对象返回给 </span>Connector 13)Connector <span class="s17">把 </span>HttpServletResponse <span class="s17">对象返回给客户 </span>browser</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="14."><p class="s140" style="padding-left: 39pt;text-indent: -16pt;text-align: left;">Tomcat <span class="s141">工作模式？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Tomcat <span class="s17">是一个 </span>JSP/Servlet <span class="s17">容器。其作为 </span>Servlet <span class="s17">容器，有三种工作模式：独立的 </span>Servlet <span class="s17">容器、进程内的 </span>Servlet <span class="s17">容器和进程外的 </span>Servlet <span class="s17">容器。</span></p><p class="s17" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 31pt;text-align: left;">进入 <span class="s142">Tomcat </span>的请求可以根据 <span class="s142">Tomcat </span>的工作模式分为如下两类： <span class="s142">Tomcat </span>作为应用程序服务器：请求来自于前端的 <span class="s142">web </span>服务器，这可能是</p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Apache, IIS, Nginx <span class="s17">等；</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s142" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Tomcat <span class="s17">作为独立服务器：请求来自于 </span>web <span class="s17">浏览器；</span></p><ol id="l128"><li data-list-text="1."><p class="s144" style="padding-left: 40pt;text-indent: -17pt;line-height: 38pt;text-align: left;">ZooKeeper 是什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_387.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">ZooKeeper 是一个<span class="s145">分布式</span>的，开放源码的分布式<span class="s145">应用程序协调服务</span>，是 Google 的 Chubby 一个开源的实现，它是<span class="s145">集群的管理者</span>，<span class="s145">监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作</span>。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">客户端的<span class="s145">读请求</span>可以被集群中的<span class="s145">任意一台机器处理</span>，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于<span class="s145">写请求</span>，这些请求会同<span class="s145">时发给其他zookeeper 机器并且达成一致后，请求才会返回成功</span>。因此，随着 <span class="s145">zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降</span>。有序性是 zookeeper 中非常重要的一个特性，所有的<span class="s145">更新都是全局有序的</span>，每个更新都有一个<span class="s145">唯一的时间戳</span>，这个时间戳称为 <span class="s145">zxid（Zookeeper Transaction Id）</span>。而<span class="s145">读请求只会相对于更新有序</span>，也就是读请求的返回结果中会带有这个 <span class="s145">zookeeper 最新的zxid</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s144" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">ZooKeeper 提供了什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="552" height="1" alt="image" src="整合_files/Image_388.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">1、<span class="s145">文件系统</span></p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">2、<span class="s145">通知机制</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s144" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">Zookeeper 文件系统</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_389.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">Zookeeper 提供一个多层级的节点命名空间（节点称为 znode）。与文件系统不同的是，这些节点<span class="s145">都可以设置关联的数据</span>，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper 为了保证高吞吐和低延 迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper <span class="s145">不能用于存放大量的数据</span>，每个节点的存放数据上限为 <span class="s145">1M</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s144" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">四种类型的 znode</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_390.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">1、<span class="s145">PERSISTENT-持久化目录节点</span></p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">客户端与 zookeeper 断开连接后，该节点依旧存在</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">2、<span class="s145">PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</span></p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">3、<span class="s145">EPHEMERAL-临时目录节点</span></p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">客户端与 zookeeper 断开连接后，该节点被删除</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">4、<span class="s145">EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</span></p><p class="s60" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">客户端与 zookeeper 断开连接后，该节点被删除，只是 Zookeeper 给该节点名称进行顺序编号</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 32pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5."><p class="s144" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">Zookeeper 通知机制</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_392.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">client 端会对某个 znode 建立一个 <span class="s145">watcher 事件</span>，当该 znode 发生变化时，这些 client 会收到 zk 的通知，然后 client 可以根据 znode 变化来做出业务上的改变等。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="6."><p class="s144" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">Zookeeper 做了什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="552" height="1" alt="image" src="整合_files/Image_393.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">1、命名服务</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">2、配置管理</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">3、集群管理</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">4、分布式锁</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">5、队列管理</p></li><li data-list-text="7."><p class="s144" style="padding-left: 40pt;text-indent: -17pt;line-height: 38pt;text-align: left;">zk 的命名服务（文件系统）</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_394.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">命名服务是指通过指定的名字来<span class="s145">获取资源</span>或者<span class="s145">服务的地址</span>，利用 zk 创建一个全局的路径，即是<span class="s145">唯一</span>的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="8."><p class="s144" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">zk 的配置管理（文件系统、通知机制）</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_395.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">程序分布式的部署在不同的机器上，将程序的配置信息放在 zk 的 <span class="s145">znode </span>下，当有配置发生改变时，也就是 znode 发生变化时，可以通过改变 zk 中某个目录节点的内容，利用 <span class="s145">watcher </span>通知给各个客户端，从而更改配置。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="9."><p class="s144" style="padding-bottom: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 121%;text-align: left;">Zookeeper 集群管理（文件系统、通知机制）</p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_396.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">所谓集群管理无在乎两点：<span class="s145">是否有机器退出和加入、选举master</span>。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">对于第一点，所有机器约定在父目录下<span class="s145">创建临时目录节点</span>，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与   zookeeper  的连接断开，其所创建的临时目录节点被删除，<span class="s145">所有其他机器都收到通知：某个兄弟目录被删除</span>，于是，所有人都知道：它上船了。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">新机器加入也是类似，<span class="s145">所有机器收到通知：新兄弟目录加入</span>，highcount 又有了，对于第二点，我们稍微改变一下，<span class="s145">所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master 就好</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="10."><p class="s144" style="padding-bottom: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 121%;text-align: left;">Zookeeper 分布式锁（文件系统、通知机制）</p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="552" height="1" alt="image" src="整合_files/Image_397.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是<span class="s145">保持独占</span>，另一个是<span class="s145">控制时序</span>。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">对于第一类，我们将 zookeeper 上的一个 <span class="s145">znode 看作是一把锁</span>，通过 createznode 的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">distribute_lock 节点就释放出锁。</p><p class="s60" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">master 一样，<span class="s145">编号最小的获得锁</span>，用完删除，依次方便。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="11."><p class="s144" style="padding-left: 52pt;text-indent: -29pt;text-align: left;">获取分布式锁的流程</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_398.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 26pt;text-indent: 0pt;text-align: left;"><span></span></p><p class="s60" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">在获取分布式锁的时候在 locker 节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">createNode 方法在 locker 下创建临时顺序节点，</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">然后调用 getChildren(“locker”)来获取 locker 下面的所有子节点，注意此时不用设置任何 Watcher。客户端获取到所有的子节点 path 之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非 locker 所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到<span class="s145">比自己小的那个节点</span>，然后对其调用 <span class="s145">exist()</span>方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的 Watcher 会收到相应通知，此时再次判断自己创建的节点是否是 locker 子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当</p><p class="s60" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">前这个过程中还需要许多的逻辑判断。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 26pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">代码的实现主要是基于互斥锁，获取分布式锁的重点逻辑在于 <span class="s145">BaseDistributedLock</span>，实现了基于</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Zookeeper 实现分布式锁的细节。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="12."><p class="s144" style="padding-bottom: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 121%;text-align: left;">Zookeeper 队列管理（文件系统、通知机制）</p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_401.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">两种类型的队列：</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">2、队列按照 FIFO 方式进行入队和出队操作。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建  <span class="s145">PERSISTENT_SEQUENTIAL </span>节点，创建成功时 <span class="s145">Watcher </span>通知等待的队列，队列删除<span class="s145">序列号最小的节点</span>用以消费。此场景下 Zookeeper 的 znode 用于消息存储，znode 存储的数据就是消息队列中的消息内容，  SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以<span class="s145">不必担心队列消息的丢失问题</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="13."><p class="s144" style="padding-left: 52pt;text-indent: -29pt;text-align: left;">Zookeeper 数据复制</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="552" height="1" alt="image" src="整合_files/Image_402.png"/></span></p><p class="s60" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Zookeeper 作为一个集群提供一致的数据服务，自然，它要在<span class="s145">所有机器间</span>做数据复制。数据复制的好处：</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力；</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">3、提高性能：让<span class="s145">客户端本地访问就近的节点，提高用户访问速度</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">从客户端读写访问的透明度来看，数据复制集群系统分下面两种：</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">1、<span class="s145">写主</span>(WriteMaster) ：对数据的<span class="s145">修改提交给指定的节点</span>。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称<span class="s145">读写分离</span>；</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">2、<span class="s145">写任意</span>(Write Any)：对数据的<span class="s145">修改可提交给任意的节点</span>，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">对  zookeeper  来说，它采用的方式是<span class="s145">写任意</span>。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立  observer  的原因），而响应能力则取决于具体实现方式，是<span class="s145">延迟复制保持最终一致性</span>，还是<span class="s145">立即复制快速响应</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="14."><p class="s144" style="padding-left: 52pt;text-indent: -29pt;text-align: left;">Zookeeper 工作原理</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_403.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">Zookeeper  的核心是<span class="s145">原子广播</span>，这个机制保证了<span class="s145">各个Server 之间的同步</span>。实现这个机制的协议叫做 <span class="s145">Zab 协议</span>。Zab 协议有两种模式，它们分别是<span class="s145">恢复模式（选主）</span>和<span class="s145">广播模式（同步）</span>。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和  leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="15."><p class="s144" style="padding-bottom: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 121%;text-align: left;">zookeeper 是如何保证事务的顺序一致性的？</p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="552" height="1" alt="image" src="整合_files/Image_404.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">zookeeper 采用了<span class="s145">递增的事务 Id </span>来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（时期; 纪元; 世; 新时代）用来标识 leader 是否发生改变，如果有新的 leader 产生出来，epoch 会自增，<span class="s145">低 32 位用来递增计数</span>。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="16."><p class="s144" style="padding-left: 52pt;text-indent: -29pt;text-align: left;">Zookeeper 下 Server 工作状态</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="552" height="1" alt="image" src="整合_files/Image_405.png"/></span></p><p class="s60" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">每个 Server 在工作过程中有三种状态：  LOOKING：当前 Server <span class="s145">不知道leader 是谁</span>，正在搜寻 LEADING：当前 Server 即为选举出来的 leader</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">FOLLOWING：leader 已经选举出来，当前 Server 与之同步</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="17."><p class="s144" style="padding-left: 52pt;text-indent: -29pt;text-align: left;">zookeeper 是如何选取主 leader 的？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_406.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">当 leader 崩溃或者 leader 失去大多数的 follower，这时 zk 进入恢复模式，恢复模式需要重新选举出一个新的</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">leader，让所有的 Server 都恢复到一个正确的状态。Zk 的选举算法有两种：一种是基于 basic paxos 实现的，另外一种是基于 fast paxos 算法实现的。系统默认的选举算法为 <span class="s145">fast paxos</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">1、Zookeeper 选主流程(basic paxos)</p><ol id="l129"><li data-list-text="（1）"><p class="s60" style="padding-left: 45pt;text-indent: -22pt;line-height: 16pt;text-align: left;">选举线程由当前 Server 发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Server；</p></li><li data-list-text="（2）"><p class="s60" style="padding-left: 45pt;text-indent: -22pt;line-height: 16pt;text-align: left;">选举线程首先向所有 Server 发起一次询问(包括自己)；</p></li><li data-list-text="（3）"><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">选举线程收到回复后，验证是否是自己发起的询问(验证 zxid 是否一致)，然后获取对方的 id(myid)，并存储到当前询问对象列表中，最后获取对方提议的 leader 相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</p></li><li data-list-text="（4）"><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">收到所有 Server 回复以后，就计算出 zxid 最大的那个 Server，并将这个 Server 相关信息设置成下一次要投票的 Server；</p></li><li data-list-text="（5）"><p class="s60" style="padding-left: 45pt;text-indent: -22pt;line-height: 16pt;text-align: left;">线程将当前 zxid 最大的 Server 设置为当前 Server 要推荐的 Leader，如果此时获胜的 Server 获得 n/2</p></li></ol><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">+ 1 的 Server 票数，设置当前推荐的 leader 为获胜的 Server，将根据获胜的 Server 相关信息设置自己的状 态，否则，继续这个过程，直到 leader 被选举出来。 通过流程分析我们可以得出：要使 Leader 获得多数 Server 的支持，则 Server 总数必须是奇数 2n+1，且存活的 Server 的数目不得少于 n+1. 每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数</p><p class="s60" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">2、Zookeeper 选主流程(basic paxos)</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">fast paxos 流程是在选举过程中，某 Server 首先向所有 Server 提议自己要成为 leader，当其它 Server 收到提议以后，解决 epoch 和 zxid 的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流</p><p class="s60" style="padding-top: 1pt;padding-bottom: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">程，最后一定能选举出 Leader。</p><p style="padding-left: 24pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="18."><p class="s144" style="padding-left: 52pt;text-indent: -29pt;text-align: left;">Zookeeper 同步流程</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_409.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">选完 Leader 以后，zk 就进入状态同步过程。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">1、Leader 等待 server 连接；</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">2、Follower 连接 leader，将最大的 zxid 发送给 leader； 3、Leader 根据 follower 的 zxid 确定同步点；</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">4、完成同步后通知 follower 已经成为 uptodate 状态；</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">5、Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 26pt;text-indent: 0pt;text-align: left;"><span></span></p></li><li data-list-text="19."><p class="s144" style="padding-left: 52pt;text-indent: -29pt;line-height: 38pt;text-align: left;">分布式通知和协调</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_411.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">对于系统调度来说：操作人员发送通知实际是通过控制台<span class="s145">改变某个节点的状态</span>，<span class="s145">然后zk 将这些变化发送给注册了这个节点的watcher 的所有客户端</span>。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">对于执行情况汇报：每个工作进程都在某个目录下<span class="s145">创建一个临时节点</span>。<span class="s145">并携带工作的进度数据</span>，这样<span class="s145">汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="20."><p class="s144" style="padding-left: 52pt;text-indent: -29pt;text-align: left;">机器中为什么会有 leader？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="552" height="1" alt="image" src="整合_files/Image_412.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，<span class="s145">其他的机器可以共享这个结果</span>，这样可以大大<span class="s145">减少重复计算</span>，<span class="s145">提高性能</span>，于是就需要进行 leader 选举。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="21."><p class="s144" style="padding-left: 52pt;text-indent: -29pt;text-align: left;">zk 节点宕机如何处理？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_413.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Zookeeper 本身也是集群，推荐配置不少于 3 个服务器。Zookeeper 自身也要保证当一个节点宕机时，其他节点会继续提供服务。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">如果是一个 Follower 宕机，还有 2 台服务器提供访问，因为 Zookeeper 上的数据是有多个副本的，数据并不会丢失；</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">如果是一个 Leader 宕机，Zookeeper 会选举出新的 Leader。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">ZK 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZK 节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">所以</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">3 个节点的 cluster 可以挂掉 1 个节点(leader 可以得到 2 票&gt;1.5)</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">2 个节点的 cluster 就不能挂掉任何 1 个节点了(leader 可以得到 1 票&lt;=1)</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="22."><p class="s144" style="padding-bottom: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 121%;text-align: left;">zookeeper 负载均衡和 nginx 负载均衡区别</p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_414.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">zk 的负载均衡是可以调控，nginx 只是能调权重，其他需要可控的都需要自己写插件；但是 nginx 的吞吐量比</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">zk 大很多，应该说按业务选择用哪种方式。</p></li><li data-list-text="23."><p class="s144" style="padding-left: 52pt;text-indent: -29pt;line-height: 38pt;text-align: left;">zookeeper watch 机制</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 21pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="560" height="1" alt="image" src="整合_files/Image_415.png"/></span></p><p class="s60" style="padding-top: 17pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Watch 机制官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch 的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Zookeeper 机制的特点：</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">1、一次性触发数据发生改变时，一个 watcher event 会被发送到 client，但是 client <span class="s145">只会收到一次这样的信息</span>。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 94%;text-align: left;">2、watcher event 异步发送 watcher 的通知事件从 server 发送到 client 是<span class="s145">异步</span>的，这就存在一个问题，不同的客户端和服务器之间通过 socket 进行通信，由于<span class="s145">网络延迟或其他因素导致客户端在不通的时刻监听到事件</span>，由于 Zookeeper 本身提供了 <span class="s145">ordering guarantee，即客户端监听事件后，才会感知它所监视znode 发生了变化</span>。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。Zookeeper <span class="s145">只能保证最终的一致性，而无法保证强一致性</span>。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">3、数据监视 Zookeeper 有数据监视和子数据监视 getdata() and exists()设置数据监视，getchildren()设置了子节点监视。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 15pt;text-align: left;">4、注册 watcher <span class="s145">getData、exists、getChildren</span></p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;line-height: 16pt;text-align: left;">5、触发 watcher <span class="s145">create、delete、setData</span></p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">6、<span class="s145">setData()</span>会触发 znode 上设置的 data watch（如果 set 成功的话）。一个成功的 <span class="s145">create() </span>操作会触发被创建的 znode 上的数据 watch，以及其父节点上的 child watch。而一个成功的 <span class="s145">delete()</span>操作将会同时触发一个 znode 的 data watch 和 child watch（因为这样就没有子节点了），同时也会触发其父节点的 child watch。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">7、当一个客户端<span class="s145">连接到一个新的服务器上</span>时，watch 将会被以任意会话事件触发。当<span class="s145">与一个服务器失去连接</span>的时候，是无法接收到 watch 的。而当 client <span class="s145">重新连接</span>时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，<span class="s145">watch 可能会丢失</span>：对于一个未创建的 znode 的 exist  watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 watch 事件可能会被丢失。</p><p class="s60" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">8、Watch 是轻量级的，其实就是本地 JVM 的 <span class="s145">Callback</span>，服务器端只是存了是否有设置了 Watcher 的布尔类型</p><ol id="l130"><li data-list-text="1)"><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">现在有 <span class="s84">T1</span>、<span class="s84">T2</span>、<span class="s84">T3 </span>三个线程，你怎样保证 <span class="s84">T2 </span>在 <span class="s84">T1 </span>执行完后执行，<span class="s84">T3 </span>在 <span class="s84">T2 </span>执行完后执行？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”<span class="s84">join</span>”方法是否熟悉。这个多线程问题比较简单，可以用 <span class="s84">join </span>方法实现。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2)"><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">在 <span class="s84">Java </span>中 <span class="s84">Lock </span>接口比 <span class="s84">synchronized </span>块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">lock <span class="p">接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像 </span>ConcurrentHashMap <span class="p">这样的高性能数据结构和有条件的阻塞。</span>Java <span class="p">线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下 </span>Locks<span class="p">，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3)"><p style="padding-left: 31pt;text-indent: -8pt;text-align: left;">在 <span class="s84">java </span>中 <span class="s84">wait </span>和 <span class="s84">sleep </span>方法的不同？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">通常会在电话面试中经常被问到的 <span class="s84">Java </span>线程面试问题。最大的不同是在等待时 <span class="s84">wait </span>会释放锁，而 <span class="s84">sleep </span>一直持有锁。<span class="s84">Wait </span>通常被用于线程间交互，<span class="s84">sleep </span>通常被用于暂停执行。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">用 <span class="s84">Java </span>实现阻塞队列。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用 <span class="s84">Java </span>线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用 <span class="s84">wait()</span>和 <span class="s84">notify()</span>方法来实现阻塞队列，你可以要求他用最新的 <span class="s84">Java 5 </span>中的并发类来再写一次。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">用 <span class="s84">Java </span>写代码来解决生产者——消费者问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在 <span class="s84">Java </span>中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="6）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">用 <span class="s84">Java </span>编程一个会导致死锁的程序，你将怎么解决？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这是我最喜欢的 <span class="s84">Java </span>线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写 <span class="s84">deadlock free code</span>（无死锁代码？），他们很挣扎。只要告诉他们，你有 <span class="s84">N </span>个资源和 <span class="s84">N </span>个线程，并且你需要所有的资源来完成一个操作。为了简单这里的 <span class="s84">n </span>可以替换为 <span class="s84">2</span>，越大的数据会使问题看起来更复杂。通过避免 <span class="s84">Java </span>中的死锁来得到关于死锁的更多信息。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l131"><li data-list-text="7)"><p style="padding-left: 33pt;text-indent: -10pt;text-align: left;">什么是原子操作，<span class="s84">Java </span>中的原子操作是什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">非常简单的 <span class="s84">java </span>线程面试问题，接下来的问题是你需要同步一个原子操作。</p></li><li data-list-text="8)"><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Java <span class="p">中的 </span>volatile <span class="p">关键是什么作用？怎样使用它？在 </span>Java <span class="p">中它跟 </span>synchronized <span class="p">方法有什么不同？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">自从 <span class="s84">Java  5 </span>和 <span class="s84">Java </span>内存模型改变以后，基于 <span class="s84">volatile </span>关键字的线程问题越来越流行。应该准备好回答关于 <span class="s84">volatile </span>变量怎样在并发环境中确保可见性。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="9)"><p style="padding-left: 33pt;text-indent: -10pt;text-align: left;">什么是竞争条件？你怎样发现和解决竞争？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于 <span class="s84">Java </span>竞争条件的文章。在我看来这是最好的 <span class="s84">java </span>线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，<span class="s84">or writing code which is free of data race or anyother race condition</span>。关于这方面最好的书是《<span class="s84">Concurrency practices in Java</span>》。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="10)"><p style="padding-left: 39pt;text-indent: -16pt;text-align: left;">你将如何使用 <span class="s84">threaddump</span>？你将如何分析 <span class="s84">Thread dump</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">在 <span class="s84">UNIX </span>中你可以使用 <span class="s84">kill  -3</span>，然后 <span class="s84">thread  dump </span>将会打印日志，在 <span class="s84">windows </span>中你可以使用”<span class="s84">CTRL+Break</span>”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="11)"><p style="padding-left: 39pt;text-indent: -16pt;text-align: left;">为什么我们调用 <span class="s84">start()</span>方法时会执行 <span class="s84">run()</span>方法，为什么我们不能直接调用 <span class="s84">run()</span>方法？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">这是另一个非常经典的 <span class="s84">java </span>多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级 <span class="s84">Java </span>面试的第一轮被问到。这个问题的回答应该是这样的，当你调用 <span class="s84">start()</span>方法时你将创建新的线程，并且执行在 <span class="s84">run()</span>方法里的代码。但是如果你直接调用 <span class="s84">run()</span>方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《<span class="s84">start </span>与 <span class="s84">run </span>方法的区别》这篇文章来获得更多信息。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="12)"><p class="s84" style="padding-left: 39pt;text-indent: -16pt;text-align: left;">Java <span class="p">中你怎样唤醒一个阻塞的线程？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了 <span class="s84">IO </span>阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用 <span class="s84">wait()</span>、<span class="s84">sleep()</span>、或者 <span class="s84">join()</span>方法而导致的阻塞，你可以中断线程，并且通过抛出 <span class="s84">InterruptedException </span>来唤醒它。我之前写的</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">《<span class="s84">How to deal with blocking methods in java</span>》有很多关于处理线程阻塞的信息。 <span class="s84">13)</span>在 <span class="s84">Java </span>中 <span class="s84">CycliBarriar </span>和 <span class="s84">CountdownLatch </span>有什么区别？</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">这个线程问题主要用来检测你是否熟悉 <span class="s84">JDK5 </span>中的并发包。这两个的区别是 <span class="s84">CyclicBarrier </span>可以重复使用已经通过的障碍，而 <span class="s84">CountdownLatch </span>不能重复使用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l132"><li data-list-text="14)"><p style="padding-left: 39pt;text-indent: -16pt;text-align: left;">什么是不可变对象，它对写并发应用有什么帮助？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个 <span class="s84">java </span>面试问题</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么 <span class="s84">String </span>是不可变的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="15)"><p style="padding-left: 39pt;text-indent: -16pt;text-align: left;">你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">多线程和并发程序中常遇到的有 <span class="s84">Memory-interface</span>、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的 <span class="s84">Java </span>线程问题。</p><p class="s146" style="padding-left: 29pt;text-indent: 0pt;text-align: justify;">Synchronized 相关问题</p><p class="s147" style="padding-top: 8pt;padding-left: 29pt;text-indent: 0pt;text-align: justify;">问题一： <span class="s148">Synchronized 用过吗， 其原理是什么？</span></p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">这是一道 Java 面试中几乎百分百会问到的问题， 因为没有任何写过并发程序的开发者会没听说或者没接触过 Synchronized。</p><p class="s150" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">Synchronized  是由  JVM 实现的一种实现互斥同步的一种方式， 如果你查看被  Synchronized 修饰过的程序块编译后的字节码， 会发现，被    Synchronized    修饰过的程序块， 在编译前后被编译器生成了 monitorenter 和 monitorexit 两个字节码指令。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">这两个指令是什么意思呢？</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">在虚拟机执行到 monitorenter 指令时， 首先要尝试获取对象的锁：如果这个对象没有锁定， 或者当前线程已经拥有了这个对象的锁， 把锁</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">的计数器  + 1 ； 当执行 monitorexit 指令时将锁计数器  - 1 ； 当计数器为 0 时， 锁就被释放了。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">如果获取对象失败了， 那当前线程就要阻塞等待， 直到对象锁被另外一个线程释放为止。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">Java  中  Synchronize  通过在对象头设置标记， 达到了获取锁和释放锁的目的。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">问题二： <span class="s148">你刚才提到获取对象的锁， 这个“ 锁” 到底是什么？ 如何确定对象的锁？</span></p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">“ 锁” 的本质其实是 monitorenter 和 monitorexit 字节码指令的一个 Reference 类型的参数， 即要锁定和解锁的对象。 我们知道， 使用</p><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">Synchronized 可以修饰不同的对象， 因此， 对应的对象锁可以这么确定。</p><ol id="l133"><li data-list-text="1."><p class="s149" style="padding-left: 23pt;text-indent: -18pt;line-height: 22pt;text-align: left;">如果 Synchronized 明确指定了锁对象， 比如 Synchronized（ 变量</p><p class="s149" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">名） 、 Synchronized( this) 等， 说明加解锁对象为该对象。</p></li><li data-list-text="2."><p class="s149" style="padding-top: 10pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">如果没有明确指定：</p><p class="s149" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 161%;text-align: justify;">若  Synchronized 修饰的方法为非静态方法， 表示此方法对应的对象为锁对象；</p><p class="s149" style="padding-left: 23pt;text-indent: 0pt;line-height: 161%;text-align: justify;">若  Synchronized 修饰的方法为静态方法， 则表示此方法对应的类对象为锁对象。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">注意， 当一个对象被锁住时， 对象里面所有用  Synchronized 修饰的方法都将产生堵塞， 而对象里非  Synchronized 修饰的方法可正常被调用， 不受锁影响。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">问题三： <span class="s148">什么是可重入性， 为什么说 Synchronized 是可重入锁？</span><span class="s149">可重入性是锁的一个基本要求， 是为了解决自己锁死自己的情况。 比如下面的伪代码， 一个类中的同步方法调用另一个同步方法， 假如</span></p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">Synchronized 不支持重入， 进入  method 2 方法时当前线程获得锁， method 2 方法里面执行  method 1 时当前线程又要去尝试获取锁， 这时如果不支持重入， 它就要等释放， 把自己阻塞， 导致自己锁死自己。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s151" style="padding-left: 38pt;text-indent: 0pt;text-align: center;">· 点 击 图 片 ， 放 大 查 看 ·</p><p class="s149" style="padding-top: 5pt;padding-left: 29pt;text-indent: 0pt;text-align: justify;">对  Synchronized 来说， 可重入性是显而易见的， 刚才提到， 在执行</p><p class="s149" style="padding-top: 11pt;padding-left: 39pt;text-indent: 0pt;text-align: center;">monitorenter 指令时， 如果这个对象没有锁定， 或者当前线程已经拥</p><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">有了这个对象的锁<span style=" color: #B2B2B2;">（ 而不是已拥有了锁则不能继续获取） </span>， 就把锁的计数器 + 1 ， 其实本质上就通过这种方式实现了可重入性。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">问题四： <span class="s148">JVM 对 Java 的原生锁做了哪些优化？</span></p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">在  Java 6  之前， Monitor 的实现完全依赖底层操作系统的互斥锁来实现， 也就是我们刚才在问题二中所阐述的获取/ 释放锁的逻辑。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">由于  Java 层面的线程与操作系统的原生线程有映射关系， 如果要将一个线程进行阻塞或唤起都需要操作系统的协助， 这就需要从用户态切换到内核态来执行， 这种切换代价十分昂贵， 很耗处理器时间， 现代  JDK中做了大量的优化。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">— 种优化是使用自旋锁， 即在把线程进行阻塞操作之前先让线程自旋等待一段时间， 可能在等待期间其他线程已经解锁， 这时就无需再让线程执行阻塞操作， 避免了用户态到内核态的切换。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">现代  JDK 中还提供了三种不同的  Monitor 实现， 也就是三种不同的锁：</p></li></ol></li></ul></li><li data-list-text=""><p class="s149" style="padding-left: 23pt;text-indent: -18pt;text-align: justify;">偏向锁（ Biased Locking）</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 23pt;text-indent: -18pt;text-align: justify;">轻量级锁</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">重量级锁</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">这三种锁使得  JDK 得以优化  Synchronized 的运行， 当  JVM  检测到不同的竞争状况时， 会自动切换到适合的锁实现， 这就是锁的升级、降级。</p></li><li data-list-text=""><p class="s149" style="padding-left: 23pt;text-indent: -18pt;text-align: left;">当没有竞争出现时， 默认会使用偏向锁。</p><p class="s150" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">JVM  会利用  CAS 操作， 在对象头上的  Mark Word 部分设置线程 ID， 以表示这个对象偏向于当前线程， 所以并不涉及真正的互斥锁， 因为在很多应用场景中， 大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p><ul id="l134"><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">如果有另一线程试图锁定某个被偏斜过的对象， JVM  就撤销偏斜锁，切换到轻量级锁实现。</p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁， 如果重试成功，就使用普通的轻量级锁； 否则， 进一步升级为重量级锁。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;text-align: justify;">问题五： <span class="s148">为什么说 Synchronized 是非公平锁？</span></p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">非公平主要表现在获取锁的行为上， 并非是按照申请锁的时间前后给等待线程分配锁的， 每当锁被释放后， 任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能， 缺点是可能会产生线程饥饿现象。<span class="s147">问题六： </span><span style=" color: #FFA900;">什么是锁消除和锁粗化？</span></p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">锁消除： 指虚拟机即时编译器在运行时， 对一些代码上要求同步， 但被检测到不可能存在共享数据竞争的锁进行消除。 主要根据逃逸分析。 程序员怎么会在明知道不存在数据竞争的情况下使用同步呢？ 很多不是程序员自己加入的。</p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: justify;">锁粗化： 原则上， 同步块的作用范围要尽量小。 但是如果一系列的连续操作都对同一个对象反复加锁和解锁， 甚至加锁操作在循环体内， 频繁地进行互斥同步操作也会导致不必要的性能损耗。</p></li></ul></li></ul><p class="s149" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">锁粗化就是增大锁的作用域。</p><p class="s147" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">问题七： <span class="s148">为什么说  Synchronized  是一个悲观锁？ 乐观锁的实现原理又是什么？ 什么是 CAS， 它有什么特性？</span></p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">Synchronized 显然是一个悲观锁， 因为它的并发策略是悲观的：</p><p class="s150" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">不管是否会产生竞争， 任何的数据操作都必须要加锁、 用户态核心态转换、 维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">随着硬件指令集的发展， 我们可以使用基于冲突检测的乐观并发策略。先进行操作， 如果没有其他线程征用数据， 那操作就成功了；</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">如果共享数据有征用， 产生了冲突， 那就再进行其他的补偿措施。 这种乐观的并发策略的许多实现不需要线程挂起， 所以被称为非阻塞同步。乐观锁的核心算法是  CAS（ Compareand Swap， 比较并交换） ， 它涉及到三个操作数： 内存值、 预期值、 新值。 当且仅当预期值和内存值相等时才将内存值修改为新值。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">这样处理的逻辑是， 首先检查某块内存的值是否跟之前我读取时的一 样， 如不一样则表示期间此内存值已经被别的线程更改过， 舍弃本次操作， 否则说明期间没有其他线程对此内存值操作， 可以把新值设置给此块内存。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">CAS  具有原子性， 它的原子性由  CPU 硬件指令实现保证， 即使用 JNI  调用  Native 方法调用由  C++ 编写的硬件级别指令， JDK  中提供了  Unsafe 类执行这些操作。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">问题八： <span class="s148">乐观锁一定就是好的吗？</span></p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">乐观锁避免了悲观锁独占对象的现象， 同时也提高了并发性能， 但它也有缺点：</p><ol id="l135"><ol id="l136"><li data-list-text="1."><p class="s149" style="padding-left: 29pt;text-indent: -18pt;line-height: 137%;text-align: left;">乐观锁只能保证一个共享变量的原子操作。 如果多一个或几个变量， 乐观锁将变得力不从心， 但互斥锁能轻易解决， 不管对象数量多少及对象</p><p class="s149" style="padding-top: 4pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">颗粒度大小。</p></li><li data-list-text="2."><p class="s149" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 137%;text-align: left;">长时间自旋可能导致开销大。 假如  CAS  长时间不成功而一直自旋， 会给 CPU 带来很大的开销。</p></li><li data-list-text="3."><p class="s149" style="padding-top: 3pt;padding-left: 29pt;text-indent: -18pt;line-height: 137%;text-align: left;">ABA  问题。 CAS  的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过， 但这个判断逻辑不严谨， 假如内存值原来是  A，</p></li></ol></ol><p class="s149" style="padding-top: 4pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">后来被一条线程改为 B， 最后又被改成了 A， 则 CAS 认为此内存值并没有发生改变， 但实际上是有被其他线程改过的， 这种情况对依赖过程值的情景的运算结果影响很大。 解决的思路是引入版本号， 每次变量更新都把版本号加一。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s146" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">可重入锁 ReentrantLock 及其他显式锁相关问题</p><p class="s147" style="padding-top: 9pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">问题一： <span class="s148">跟  Synchronized  相比， 可重入锁  Reentrant Lock 其实现原理有什么不同？</span></p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">其实， 锁的实现原理基本是为了达到一个目的：让所有的线程都能看到某种标记。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">Synchronized 通过在对象头中设置标记实现了这一目的， 是一种  JVM原生的锁实现方式， 而  Reentrant Lock 以及所有的基于  Lock 接口的实现类， 都是通过用一个  volitile  修饰的  int 型变量， 并保证每个线程都能拥有对该  int 的可见性和原子修改， 其本质是基于所谓的  AQS框架。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;text-align: justify;">问题二： <span class="s148">那么请谈谈 AQS 框架是怎么回事儿？</span></p><p class="s150" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">AQS（ Abstract Queued Synchronizer  类） 是一个用来构建锁和同步器的框架， 各种    Lock    包中的锁（ 常用的有    Reentrant Lock、 Read Write Lock） ， 以及其他如  Semaphore、 Count Down Latch， 甚至是早期的  Future Task 等， 都是基于  AQS 来构建。</p><ol id="l137"><li data-list-text="1."><p class="s149" style="padding-left: 23pt;text-indent: -18pt;line-height: 22pt;text-align: left;">AQS  在内部定义了一个  volatile int state  变量， 表示同步状态： 当线</p><p class="s149" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 161%;text-align: justify;">程调用  lock 方法时  ， 如果  state= 0 ， 说明没有任何线程占有共享资源的锁， 可以获得锁并将  state= 1 ； 如果  state= 1 ， 则说明有线程目前正在使用共享变量， 其他线程必须加入同步队列进行等待。</p></li><li data-list-text="2."><p class="s149" style="padding-left: 23pt;text-indent: -18pt;line-height: 22pt;text-align: left;">AQS 通过 Node 内部类构成的一个双向链表结构的同步队列， 来完成线</p><p class="s149" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">程获取锁的排队工作， 当有线程获取锁失败后， 就被添加到队列末尾。</p><ul id="l138"><li data-list-text="o"><p class="s149" style="padding-top: 11pt;padding-left: 23pt;text-indent: -18pt;line-height: 161%;text-align: justify;">Node  类是对要访问同步代码的线程的封装， 包含了线程本身及其状态叫 wait Status（ 有五种不同   取值， 分别表示是否被阻塞， 是否等待唤醒，是否已经被取消等） ， 每个  Node  结点关联其  prev  结点和  next  结点， 方便线程释放锁后快速唤醒下一个在等待的线程， 是一个  FIFO  的过程。</p></li><li data-list-text="o"><p class="s149" style="padding-left: 23pt;text-indent: -18pt;line-height: 161%;text-align: left;">Node 类有两个常量， SHARED 和 EXCLUSIVE， 分别代表共享模式和独占模式。 所谓共享模式是一个锁允许多条线程同时操作（ 信号量</p></li></ul><p class="s149" style="padding-left: 23pt;text-indent: 0pt;line-height: 161%;text-align: left;">Semaphore 就是基于 AQS 的共享模式实现的） ， 独占模式是同一个时间段只能有一个线程对共享资源进行操作， 多余的请求线程需要排队等待</p><p class="s149" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">（ 如 Reentran Lock） 。</p></li><li data-list-text="3."><p class="s149" style="padding-top: 10pt;padding-left: 23pt;text-indent: -18pt;text-align: left;">AQS  通过内部类  Condition Object  构建等待队列（ 可有多个） ， 当</p><p class="s149" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Condition   调用   wait()   方法后， 线程将会加入等待队列中， 而当</p><p class="s149" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 161%;text-align: left;">Condition 调用 signal() 方法后， 线程将从等待队列转移动同步队列中进行锁竞争。</p></li><li data-list-text="4."><p class="s149" style="padding-left: 23pt;text-indent: -18pt;line-height: 22pt;text-align: left;">AQS   和   Condition   各自维护了不同的队列， 在使用   Lock   和</p><p class="s149" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Condition 的时候， 其实就是两个队列的互相移动。</p><p class="s147" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">问题三： <span class="s148">请尽可能详尽地对比下  Synchronized  和  Reentrant Lock</span></p><p class="s148" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">的异同。</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">Reentrant Lock 是 Lock 的实现类， 是一个互斥的同步锁。</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">从功能角度， Reentrant Lock  比  Synchronized 的同步操作更精细</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">（ 因为可以像普通对象一样使用） ， 甚至实现  Synchronized 没有的高级功能， 如：</p><ul id="l139"><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">等待可中断： 当持有锁的线程长期不释放锁的时候， 正在等待的线程可以选择放弃等待， 对处理执行时间非常长的同步块很有用。</p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">带超时的获取锁尝试： 在指定的时间范围内获取锁， 如果时间到了仍然无法获取则返回。</p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;text-align: left;">可以判断是否有线程在排队等待获取锁。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">可以响应中断请求： 与  Synchronized  不同， 当获取到锁的线程被中断时， 能够响应中断， 中断异常将会被抛出， 同时锁会被释放。</p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;text-align: left;">可以实现公平锁。</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">从锁释放角度， Synchronized  在  JVM  层面上实现的， 不但可以通过一些监控工具监控  Synchronized  的锁定， 而且在代码执行出现异常时， JVM 会自动释放锁定； 但是使用  Lock 则不行， Lock 是通过代</p><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: justify;">码实现的， 要保证锁定一定会被释放， 就必须将   un Lock()   放到</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: justify;">f inally{} 中。</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: justify;">从性能角度， Synchronized 早期实现比较低效， 对比</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: justify;">Reentrant Lock， 大多数场景性能都相差较大。</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">但是在   Java   6 中对其进行了非常多的改进， 在竞争不激烈时， Synchronized 的性能要优于    Reetrant Lock； 在高竞争情况下， Synchronized  的性能会下降几十倍， 但是  Reetrant Lock  的性能能维持常态。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;text-align: justify;">问题四： <span class="s148">Reentrant Lock 是如何实现可重入性的？</span></p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">Reentrant Lock  内部自定义了同步器  Sync（ Sync 既实现了  AQS，又实现了  AOS， 而  AOS 提供了一种互斥锁持有的方式） ， 其实就是加锁的时候通过  CAS 算法， 将线程对象放到一个双向链表中， 每次获取锁的时候， 看下当前维护的那个线程  ID 和当前请求的线程  ID 是否一样， 一样就可重入了。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">问题五： <span class="s148">除了  Reetrant Lock， 你还接触过  JUC 中的哪些并发工具？</span><span class="s149">通常所说的并发包（ JUC） 也就是  java. util. concurrent 及其子包， 集中了  Java 并发的各种基础工具类， 具体主要包括几个方面：</span></p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;text-align: left;">提供了   Count Down Latch、 Cyclic Barrier、 Semaphore   等， 比</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: justify;">Synchronized 更加高级， 可以实现更加丰富多线程操作的同步结构。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: justify;">提供了 Concurrent Hash Map、 有序的 Concunrrent Skip List Map， 或者通过类似快照机制实现线程安全的动态数组  Copy On Write Array List等， 各种线程安全的容器。</p></li><li data-list-text=""><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">提供了 Array Blocking Queue、 Synchorous Queue 或针对特定场景的</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">Priority Blocking Queue 等， 各种并发队列实现。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">强大的 Executor 框架， 可以创建各种不同类型的线程池， 调度任务运行等。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">问题六： <span class="s148">请谈谈 Read Write Lock 和 Stamped Lock。</span></p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">虽然  Reentrant Lock  和  Synchronized 简单实用， 但是行为上有一定局限性， 要么不占， 要么独占。 实际应用场景中， 有时候不需要大量竞争的写操作， 而是以并发读取为主， 为了进一步优化并发操作的粒</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">度， Java 提供了读写锁。</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">读写锁基于的原理是多个读操作不需要互斥， 如果读锁试图锁定时， 写锁是被某个线程持有， 读锁将无法获得， 而只好等待对方操作结束， 这样就可以自动保证不会读取到有争议的数据。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">Read Write Lock 代表了一对锁， 下面是一个基于读写锁实现的数据结构， 当数据量较大， 并发读多、 并发写少的时候， 能够比纯同步版本凸显出优势：</p><p style="padding-left: 30pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s151" style="padding-top: 3pt;text-indent: 0pt;text-align: center;">·</p><p class="s149" style="padding-top: 5pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">读写锁看起来比   Synchronized  的粒度似乎细一些， 但在实际应用中， 其表现也并不尽如人意， 主要还是因为相对比较大的开销。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">所以， JDK  在后期引入了  Stamped Lock， 在提供类似读写锁的同时，还支持优化读模式。 优化读基于假设， 大多数情况下读操作并不会和写操作冲突， 其逻辑是先试着修改， 然后通过  validate 方法确认是否进入了写模式， 如果没有进入， 就成功避免了开销； 如果进入， 则尝试获取读锁。</p><p style="padding-left: 30pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s151" style="padding-top: 3pt;text-indent: 0pt;text-align: center;">·</p><p class="s147" style="padding-top: 5pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">问题七： <span class="s148">如何让 Java 的线程彼此同步？ 你了解过哪些同步器？ 请分别介绍下。</span></p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">JUC   中的同步器三个主要的成员： Count Down Latch、 Cyclic Barrier和 Semaphore， 通过它们可以方便地实现很多线程之间协作的功能。 Count Down Latch 叫倒计数， 允许一个或多个线程等待某些操作完成。 看几个场景：</p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;text-align: left;">跑步比赛， 裁判需要等到所有的运动员（ “ 其他线程” ） 都跑到终点</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（ 达到目标） ， 才能去算排名和颁奖。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">模拟并发， 我需要启动  100  个线程去同时访问某一个地址， 我希望它们能同时并发， 而不是一个一个的去执行。</p><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">用法： Count Down Latch 构造方法指明计数数量， 被等待线程调用 count Down  将计数器减  1 ， 等待线程使用  await 进行线程等待。 一个简单的例子：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">Cyclic Barrier 叫循环栅栏， 它实现让一组线程等待至某个状态之后再全部同时执行， 而且当所有等待线程被释放后， Cyclic Barrier 可以被重复使用。 Cyclic Barrier 的典型应用场景是用来等待并发线程结束。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">Cyclic Barrier 的主要方法是  await()， await() 每被调用一次， 计数便会减少  1 ， 并阻塞住当前线程。 当计数减至  0  时， 阻塞解除， 所有在此  Cyclic Barrier 上面阻塞的线程开始运行。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">在这之后， 如果再次调用  await()， 计数就又会变成  N- 1 ， 新一轮重新开始， 这便是  Cyclic 的含义所在。 Cyclic Barrier. await() 带有返回值， 用来表示当前线程是第几个到达这个  Barrier 的线程。</p><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">举例说明如下：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 30pt;text-indent: 0pt;text-align: left;"><span></span></p><p class="s151" style="padding-top: 9pt;text-indent: 0pt;text-align: center;">·</p><p class="s149" style="padding-top: 5pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">Semaphore， Java 版本的信号量实现， 用于控制同时访问的线程个数， 来达到限制通用资源访问的目的， 其原理是通过  acquire() 获取一个许可， 如果没有就等待， 而 release() 释放一个许可。</p><p style="padding-left: 30pt;text-indent: 0pt;text-align: left;"><span></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s149" style="padding-top: 2pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">如果  Semaphore 的数值被初始化为  1 ， 那么一个线程就可以通过 acquire 进入互斥状态， 本质上和互斥锁是非常相似的。 但是区别也非常明显， 比如互斥锁是有持有者的， 而对于  Semaphore 这种计数器结构， 虽然有类似功能， 但其实不存在真正意义的持有者， 除非我们进行扩展包装。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">问题八： <span class="s148">Cyclic Barrier  和  Count Down Latch 看起来很相似， 请对比下呢？</span></p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">它们的行为有一定相似度， 区别主要在于：</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">Count Down Latch 是不可以重置的， 所以无法重用， Cyclic Barrier 没有这种限制， 可以重用。</p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">Count Down Latch   的基本操作组合是    count Down/ await， 调用 await  的线程阻塞等待  count Down  足够的次数， 不管你是在一个线</p><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">程还是多个线程里  count Down， 只要次数足够即可。  Cyclic Barrier的基本操作组合就是  await， 当所有的伙伴都调用了  await， 才会继续进行任务， 并自动进行重置。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">Count Down Latch  目的是让一个线程等待其他  N 个线程达到某个条件后， 自己再去做某个事（ 通过   Cyclic Barrier 的第二个构造方法 public Cyclic Barrier( int parties, Runnable barrier Action)， 在新线程里做事可以达到同样的效果） 。 而  Cyclic Barrier 的目的是让  N  多线程互相等待直到所有的都达到某个状态， 然后这  N 个线程再继续执行各自后续（ 通过   Count Down Latch  在某些场合也能完成类似的效果） 。</p><p class="s146" style="padding-left: 29pt;text-indent: 0pt;line-height: 23pt;text-align: justify;">Java 线程池相关问题</p><p class="s147" style="padding-top: 9pt;padding-left: 29pt;text-indent: 0pt;text-align: justify;">问题一： <span class="s148">Java 中的线程池是如何实现的？</span></p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: justify;">在  Java  中， 所谓的线程池中的“ 线程” ， 其实是被抽象为了一个静态内部类     Worker， 它基于     AQS     实现， 存放在线程池的 Hash Set&lt;Worker&gt; workers 成员变量中；</p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;text-align: justify;">而需要执行的任务则存放在成员变量               work Queue</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">（ Blocking Queue&lt;Runnable&gt; work Queue） 中。</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">这样， 整个线程池实现的基本思想就是： 从  work Queue 中不断取出需要执行的任务， 放在 Workers 中进行处理。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">问题二： <span class="s148">创建线程池的几个核心构造参数？</span></p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">Java 中的线程池的创建其实非常灵活， 我们可以通过配置不同的参数， 创建出行为不同的线程池， 这几个参数包括：</p></li><li data-list-text=""><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">core Pool Size： 线程池的核心线程数。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">maximum Pool Size： 线程池允许的最大线程数。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">keep Alive Time： 超过核心线程数时闲置线程的存活时间。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">work Queue： 任务执行前保存任务的队列， 保存由  execute 方法提交的 Runnable 任务。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">问题三： <span class="s148">线程池中的线程是怎么创建的？ 是一开始就随着线程池的启动创建好的吗？</span></p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">显然不是的。 线程池默认初始化后不启动  Worker， 等待有请求时才启动。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">每当我们调用  execute()  方法添加一个任务时， 线程池会做如下判断：</p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">如果正在运行的线程数量小于  core Pool Size， 那么马上创建线程运行这个任务；</p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">如果正在运行的线程数量大于或等于  core Pool Size， 那么将这个任务放入队列；</p></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;text-align: left;">如果这时候队列满了， 而且正在运行的线程数量小于</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">maximum Pool Size， 那么还是要创建非核心线程立刻运行这个任务；</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">如果队列满了， 而且正在运行的线程数量大于或等于</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">maximum Pool Size， 那么线程池会抛出异常 Reject Execution Exception。</p><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">当一个线程完成任务时， 它会从队列中取下一个任务来执行。  当一个线程无事可做， 超过一定的时间（ keep Alive Time） 时， 线程池会判</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">断。</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">如果当前运行的线程数大于  core Pool Size， 那么这个线程就被停掉。所以线程池的所有任务完成后， 它最终会收缩到  core Pool Size  的大小。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;text-align: justify;">问题四： <span class="s148">既然提到可以通过配置不同参数创建出不同的线程池， 那么</span></p><p class="s148" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: justify;">Java 中默认实现好的线程池又有哪些呢？ 请比较它们的异同。</p><ol id="l140"><li data-list-text="1."><p class="s152" style="padding-top: 11pt;padding-left: 45pt;text-indent: -16pt;text-align: justify;">. Single Thread Executor 线程池</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">这个线程池只有一个核心线程在工作， 也就是相当于单线程串行执行所有任务。 如果这个唯一的线程因为异常结束， 那么会有一个新的线程来替代它。 此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p></li></ol></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;text-align: justify;">core Pool Size： 1 ， 只有一个核心线程在工作。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: justify;">maximum Pool Size： 1 。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">keep Alive Time： 0 L。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">work Queue： new Linked Blocking Queue&lt;Runnable&gt;()， 其缓冲队列是无界的。</p><ol id="l141"><li data-list-text="2."><p class="s152" style="padding-left: 45pt;text-indent: -16pt;text-align: left;">. Fixed Thread Pool 线程池</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">Fixed Thread Pool 是固定大小的线程池， 只有核心线程。 每次提交一个任务就创建一个线程， 直到线程达到线程池的最大大小。 线程池的大小一旦达到最大值就会保持不变， 如果某个线程因为执行异常而结束， 那么线程池会补充一个新线程。</p><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">Fixed Thread Pool 多数针对一些很稳定很固定的正规并发线程， 多用于服务器。</p></li></ol></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;text-align: left;">core Pool Size： n Threads</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">maximum Pool Size： n Threads</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">keep Alive Time： 0 L</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">work Queue： new Linked Blocking Queue&lt;Runnable&gt;()， 其缓冲队列是无界的。</p><ol id="l142"><li data-list-text="3."><p class="s152" style="padding-left: 45pt;text-indent: -16pt;text-align: left;">. Cached Thread Pool 线程池</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">Cached Thread Pool 是无界线程池， 如果线程池的大小超过了处理任务所需要的线程， 那么就会回收部分空闲（ 60 秒不执行任务） 线程， 当任务数增加时， 此线程池又可以智能的添加新线程来处理任务。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">线程池大小完全依赖于操作系统（ 或者说 JVM） 能够创建的最大线程大小。 Synchronous Queue 是一个是缓冲区为 1 的阻塞队列。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">缓存型池子通常用于执行一些生存期很短的异步型任务， 因此在一些面向连接的 daemon 型 SERVER 中用得不多。 但对于生存期短的异步任务， 它是 Executor 的首选。</p></li></ol></li><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;text-align: justify;">core Pool Size： 0</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: justify;">maximum Pool Size： Integer. MAX_VALUE</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">keep Alive Time： 60 L</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">work Queue： new Synchronous Queue&lt;Runnable&gt;()， 一个是缓冲区为 1 的阻塞队列。</p><ol id="l143"><li data-list-text="4."><p class="s152" style="padding-left: 45pt;text-indent: -16pt;text-align: left;">. Scheduled Thread Pool 线程池</p></li></ol></li></ul></li></ol><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">Scheduled Thread Pool： 核心线程池固定， 大小无限的线程池。 此线程池支持定时以及周期性执行任务的需求。 创建一个周期性执行任务的线程池。 如果闲置， 非核心线程池会在  DEFAULT_KEEPALIVEMILLIS  时间内回收。</p><ul id="l144"><li data-list-text=""><p class="s149" style="padding-left: 29pt;text-indent: -18pt;text-align: justify;">core Pool Size： core Pool Size</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: justify;">maximum Pool Size： Integer. MAX_VALUE</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">keep Alive Time： DEFAULT_KEEPALIVE_MILLIS</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">work Queue： new Delayed Work Queue()<span class="s147">问题六： </span><span style=" color: #FFA900;">如何在 Java 线程池中提交线程？</span>线程池最常用的提交任务的方法有两种：</p><p style="text-indent: 0pt;text-align: left;"><span></span></p><ol id="l145"><li data-list-text="1."><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">. execute()： Executor Service. execute 方法接收一个 Runable 实例， 它用来执行一个任务：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s151" style="text-indent: 0pt;text-align: center;">·</p></li><li data-list-text="2."><p class="s149" style="padding-top: 5pt;padding-left: 44pt;text-indent: -15pt;text-align: left;">. submit()： Executor Service. submit() 方法返回的是 Future 对</p></li></ol><p style="text-indent: 0pt;text-align: left;"><span></span></p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">象。 可以用  is Done() 来查询  Future 是否已经完成， 当任务完成时，它具有一个结果， 可以调用  get() 来获取结果。 也可以不用  is Done()进行检查就直接调用  get()， 在这种情况下， get() 将阻塞， 直至结果准备就绪。</p><p class="s146" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">Java 内存模型相关问题</p><p class="s147" style="padding-top: 8pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">问题一： <span class="s148">什么是  Java 的内存模型， Java 中各个线程是怎么彼此看到对方的变量的？</span></p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">Java 的内存模型定义了程序中各个变量的访问规则， 即在虚拟机中将变量存储到内存和从内存中取出这样的底层细节。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">此处的变量包括实例字段、 静态字段和构成数组对象的元素， 但是不包括局部变量和方法参数， 因为这些是线程私有的， 不会被共享， 所以不存在竞争问题。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">Java 中各个线程是怎么彼此看到对方的变量的呢？ Java 中定义了主内存与工作内存的概念：</p><p class="s150" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">所有的变量都存储在主内存， 每条线程还有自己的工作内存， 保存了被该线程使用到的变量的主内存副本拷贝。</p><p class="s150" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">线程对变量的所有操作（ 读取、 赋值） 都必须在工作内存中进行， 不能直接读写主内存的变量。 不同的线程之间也无法直接访问对方工作内存的变量， 线程间变量值的传递需要通过主内存。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">问题二： <span class="s148">请谈谈 volatile 有什么特点， 为什么它能保证变量对所有线程的可见性？</span></p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。 当一个变量被定义成 volatile 之后， 具备两种特性：</p><ol id="l146"><li data-list-text="1."><p class="s149" style="padding-left: 29pt;text-indent: -18pt;line-height: 22pt;text-align: left;">保证此变量对所有线程的可见性。 当一条线程修改了这个变量的值， 新</p><p class="s149" style="padding-top: 8pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">值对于其他线程是可以立即得知的。 而普通变量做不到这一点。</p></li><li data-list-text="2."><p class="s149" style="padding-left: 29pt;text-indent: -18pt;line-height: 137%;text-align: left;">禁止指令重排序优化。 普通变量仅仅能保证在该方法执行过程中， 得到正确结果， 但是不保证程序代码的执行顺序。</p><p class="s152" style="padding-top: 4pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">Java 的内存模型定义了 8 种内存间操作：</p><p class="s152" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">lock 和 unlock</p></li></ol></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">把一个变量标识为一条线程独占的状态。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 161%;text-align: left;">把一个处于锁定状态的变量释放出来， 释放之后的变量才能被其他线程锁定。</p><p class="s152" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">read 和 write</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">把一个变量值从主内存传输到线程的工作内存， 以便 load。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">把 store 操作从工作内存得到的变量的值， 放入主内存的变量中。</p><p class="s152" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">load 和 store</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">把 read 操作从主内存得到的变量值放入工作内存的变量副本中。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">把工作内存的变量值传送到主内存， 以便 write。</p><p class="s152" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">use 和 assgin</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">把工作内存变量值传递给执行引擎。</p></li><li data-list-text=""><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">将执行引擎值传递给工作内存变量值。</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">volatile 的实现基于这 8 种内存间操作， 保证了一个线程对某个</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">volatile 变量的修改， 一定会被另一个线程看见， 即保证了可见性。<span class="s147">问题三： </span><span style=" color: #FFA900;">既然 volatile 能够保证线程间的变量可见性， 是不是就意味着基于 volatile 变量的运算就是并发安全的？</span></p><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: justify;">显然不是的。 基于 volatile 变量的运算在并发下不一定是安全的。</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">volatile 变量在各个线程的工作内存， 不存在一致性问题（ 各个线程的工作内存中 volatile 变量， 每次使用前都要刷新到主内存） 。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">但是 Java 里面的运算并非原子操作， 导致 volatile 变量的运算在并发下一样是不安全的。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;text-align: justify;">问题四： <span class="s148">请对比下 volatile 对比 Synchronized 的异同。</span></p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">Synchronized 既能保证可见性， 又能保证原子性， 而 volatile 只能保证可见性， 无法保证原子性。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: justify;">Thread Local 和 Synchonized 都用于解决多线程并发访问， 防止任务在共享资源上产生冲突。 但是 Thread Local 与 Synchronized 有本质的区别。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">Synchronized 用于实现同步机制， 是利用锁的机制使变量或代码块在某一时该只能被一个线程访问， 是一种 “ 以时间换空间” 的方式。 而 Thread Local 为每一个线程都提供了变量的副本， 使得每个线程在某一时间访问到的并不是同一个对象， 根除了对变量的共享， 是一种 “ 以空间换时间” 的方式。</p><p class="s147" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">问题五： <span class="s148">请谈谈 Thread Local 是怎么解决并发安全的？</span></p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">Thread Local 这是 Java 提供的一种保存线程私有信息的机制， 因为其在整个线程生命周期内有效， 所以可以方便地在一个线程关联的不同业务模块之间传递信息， 比如事务 ID、 Cookie 等上下文相关信息。</p><p class="s149" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">Thread Local 为每一个线程维护变量的副本， 把共享数据的可见范围限制在同一个线程之内， 其实现原理是， 在 Thread Local 类中有一个</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">Map， 用于存储每一个线程的变量的副本。</p><p class="s147" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">问题六： <span class="s148">很多人都说要慎用 Thread Local， 谈谈你的理解， 使用 Thread Local 需要注意些什么？</span></p><p class="s152" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">使用 Thread Local 要注意 remove！</p><p class="s149" style="padding-top: 11pt;padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">Thread Local 的实现是基于一个所谓的 Thread Local Map， 在 Thread Local Map 中， 它的 key 是一个弱引用。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">通常弱引用都会和引用队列配合清理机制使用， 但是 Thread Local 是个例外， 它并没有这么做。</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">这意味着， 废弃项目的回收依赖于显式地触发， 否则就要等待线程结 束， 进而回收相应 Thread Local Map！ 这就是很多 OOM 的来源， 所</p><p class="s149" style="padding-left: 29pt;text-indent: 0pt;line-height: 161%;text-align: left;">以通常都会建议， 应用一定要自己负责 remove， 并且不要和线程池配合， 因为 worker 线程往往是不会退出的。</p><ol id="l147"><ol id="l148"><li data-list-text="1)"><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">现在有 <span class="s84">T1</span>、<span class="s84">T2</span>、<span class="s84">T3 </span>三个线程，你怎样保证 <span class="s84">T2 </span>在 <span class="s84">T1 </span>执行完后执行，<span class="s84">T3 </span>在 <span class="s84">T2 </span>执行完后执行？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”<span class="s84">join</span>”方法是否熟悉。这个多线程问题比较简单，可以用 <span class="s84">join </span>方法实现。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2)"><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">在 <span class="s84">Java </span>中 <span class="s84">Lock </span>接口比 <span class="s84">synchronized </span>块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">lock <span class="p">接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像 </span>ConcurrentHashMap <span class="p">这样的高性能数据结构和有条件的阻塞。</span>Java <span class="p">线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下 </span>Locks<span class="p">，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3)"><p style="padding-left: 31pt;text-indent: -8pt;text-align: left;">在 <span class="s84">java </span>中 <span class="s84">wait </span>和 <span class="s84">sleep </span>方法的不同？</p></li></ol></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">通常会在电话面试中经常被问到的 <span class="s84">Java </span>线程面试问题。最大的不同是在等待时 <span class="s84">wait </span>会释放锁，而 <span class="s84">sleep </span>一直持有锁。<span class="s84">Wait </span>通常被用于线程间交互，<span class="s84">sleep </span>通常被用于暂停执行。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l149"><li data-list-text="4）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">用 <span class="s84">Java </span>实现阻塞队列。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用 <span class="s84">Java </span>线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用 <span class="s84">wait()</span>和 <span class="s84">notify()</span>方法来实现阻塞队列，你可以要求他用最新的 <span class="s84">Java 5 </span>中的并发类来再写一次。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">用 <span class="s84">Java </span>写代码来解决生产者——消费者问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在 <span class="s84">Java </span>中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="6）"><p style="padding-left: 38pt;text-indent: -15pt;text-align: left;">用 <span class="s84">Java </span>编程一个会导致死锁的程序，你将怎么解决？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这是我最喜欢的 <span class="s84">Java </span>线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写 <span class="s84">deadlock free code</span>（无死锁代码？），他们很挣扎。只要告诉他们，你有 <span class="s84">N </span>个资源和 <span class="s84">N </span>个线程，并且你需要所有的资源来完成一个操作。为了简单这里的 <span class="s84">n </span>可以替换为 <span class="s84">2</span>，越大的数据会使问题看起来更复杂。通过避免 <span class="s84">Java </span>中的死锁来得到关于死锁的更多信息。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l150"><li data-list-text="7)"><p style="padding-left: 33pt;text-indent: -10pt;text-align: left;">什么是原子操作，<span class="s84">Java </span>中的原子操作是什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">非常简单的 <span class="s84">java </span>线程面试问题，接下来的问题是你需要同步一个原子操作。</p></li><li data-list-text="8)"><p class="s84" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Java <span class="p">中的 </span>volatile <span class="p">关键是什么作用？怎样使用它？在 </span>Java <span class="p">中它跟 </span>synchronized <span class="p">方法有什么不同？</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">自从 <span class="s84">Java  5 </span>和 <span class="s84">Java </span>内存模型改变以后，基于 <span class="s84">volatile </span>关键字的线程问题越来越流行。应该准备好回答关于 <span class="s84">volatile </span>变量怎样在并发环境中确保可见性。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="9)"><p style="padding-left: 33pt;text-indent: -10pt;text-align: left;">什么是竞争条件？你怎样发现和解决竞争？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于 <span class="s84">Java </span>竞争条件的文章。在我看来这是最好的 <span class="s84">java </span>线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，<span class="s84">or writing code which is free of data race or anyother race condition</span>。关于这方面最好的书是《<span class="s84">Concurrency practices in Java</span>》。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="10)"><p style="padding-left: 39pt;text-indent: -16pt;text-align: left;">你将如何使用 <span class="s84">threaddump</span>？你将如何分析 <span class="s84">Thread dump</span>？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">在 <span class="s84">UNIX </span>中你可以使用 <span class="s84">kill  -3</span>，然后 <span class="s84">thread  dump </span>将会打印日志，在 <span class="s84">windows </span>中你可以使用”<span class="s84">CTRL+Break</span>”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="11)"><p style="padding-left: 39pt;text-indent: -16pt;text-align: left;">为什么我们调用 <span class="s84">start()</span>方法时会执行 <span class="s84">run()</span>方法，为什么我们不能直接调用 <span class="s84">run()</span>方法？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">这是另一个非常经典的 <span class="s84">java </span>多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级 <span class="s84">Java </span>面试的第一轮被问到。这个问题的回答应该是这样的，当你调用 <span class="s84">start()</span>方法时你将创建新的线程，并且执行在 <span class="s84">run()</span>方法里的代码。但是如果你直接调用 <span class="s84">run()</span>方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《<span class="s84">start </span>与 <span class="s84">run </span>方法的区别》这篇文章来获得更多信息。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="12)"><p class="s84" style="padding-left: 39pt;text-indent: -16pt;text-align: left;">Java <span class="p">中你怎样唤醒一个阻塞的线程？</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了 <span class="s84">IO </span>阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用 <span class="s84">wait()</span>、<span class="s84">sleep()</span>、或者 <span class="s84">join()</span>方法而导致的阻塞，你可以中断线程，并且通过抛出 <span class="s84">InterruptedException </span>来唤醒它。我之前写的</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 231%;text-align: left;">《<span class="s84">How to deal with blocking methods in java</span>》有很多关于处理线程阻塞的信息。 <span class="s84">13)</span>在 <span class="s84">Java </span>中 <span class="s84">CycliBarriar </span>和 <span class="s84">CountdownLatch </span>有什么区别？</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">这个线程问题主要用来检测你是否熟悉 <span class="s84">JDK5 </span>中的并发包。这两个的区别是 <span class="s84">CyclicBarrier </span>可以重复使用已经通过的障碍，而 <span class="s84">CountdownLatch </span>不能重复使用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l151"><li data-list-text="14)"><p style="padding-left: 39pt;text-indent: -16pt;text-align: left;">什么是不可变对象，它对写并发应用有什么帮助？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个 <span class="s84">java </span>面试问题</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么 <span class="s84">String </span>是不可变的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="15)"><p style="padding-left: 39pt;text-indent: -16pt;text-align: left;">你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">多线程和并发程序中常遇到的有 <span class="s84">Memory-interface</span>、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的 <span class="s84">Java </span>线程问题。</p><p class="s153" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">BeanFactory 和 ApplicationContext 有什么区别</p><ul id="l152"><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 33pt;text-indent: -10pt;line-height: 13pt;text-align: justify;">提供了支持国际化的文本消息</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: justify;">统一的资源文件读取方式</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: justify;">已在监听器中注册的 bean 的事件</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring Bean 的生命周期</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 33pt;text-indent: -10pt;line-height: 13pt;text-align: left;">初始化之后调用的回调方法。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">销毁之前调用的回调方法。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">InitializingBean 和 DisposableBean 回调接口</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">针对特殊行为的其他 Aware 接口</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">Bean 配置文件中的 Custom init()方法和 destroy()方法</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">@PostConstruct 和@PreDestroy 注解方式</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring IOC 如何实现</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Spring 中的 org.springframework.beans 包和 org.springframework.context 包构成了 Spring 框架 IoC 容器的基础。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。 ApplicationContex 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource 的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的 WebApplicationContext。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">org.springframework.beans.factory.BeanFactory 是 Spring IoC 容器的具体实现，用来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="915" alt="image" src="整合_files/Image_423.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="895" alt="image" src="整合_files/Image_424.png"/></span></p><p class="s153" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">说说 Spring AOP</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有 update*方法的执行时间时间，操作人等等信息，记录到日志，</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 33pt;text-indent: -10pt;line-height: 13pt;text-align: left;">通过 spring 的 AOP 技术，就可以在不修改 update*的代码的情况下完成该需求。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring AOP 实现原理</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理。JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 31pt;text-indent: -8pt;line-height: 13pt;text-align: left;">如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。CGLIB</p><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final，那么它是无法使用 CGLIB 做动态代理的。</p><p class="s153" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">动态代理（cglib 与 JDK）</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">JDK 动态代理类和委托类需要都实现同一个接口。也就是说只有实现了某个接口的类可以使用 Java 动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接 口。因此，对于没有实现接口的类，就不能使用该机制。而 CGLIB 则可以实现对类的动态代理。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring 事务实现方式</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">1、编码方式</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">所谓编程式事务指的是通过编码方式实现事务，即类似于 JDBC 编程实现事务管理。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">2、声明式事务管理方式</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">声明式事务管理又有两种实现方式：基于 xml 配置文件的方式；另一个实在业务方法上进行@Transaction 注解，将事务规则应用到业务逻辑中</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring 事务底层原理</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 33pt;text-indent: -10pt;text-align: justify;">a、划分处理单元——IOC</p><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">&gt;由于 spring 解决的问题是对单个数据库进行局部事务处理的，具体的实现首相用 spring中的 IOC 划分了事务处理单元。并且将对事务的各种配置放到了 ioc 容器中（设置事务管理器，设置事务的传播特性及隔离机制）。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 33pt;text-indent: -10pt;line-height: 13pt;text-align: left;">b、AOP 拦截需要进行事务处理的类</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">Spring 事务处理模块是通过 AOP 功能来实现声明式事务处理的，具体操作（比如事务实行的配置和读取，事务对象的抽象），用 TransactionProxyFactoryBean 接口来使用 AOP功能，生成 proxy 代理对象，通过 TransactionInterceptor 完成对代理方法的拦截，将事务处理的功能编织到拦截的方法中。读取 ioc 容器事务配置属性，转化为 spring 事务处理</p><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">需要的内部数据结构（TransactionAttributeSourceAdvisor），转化为</p><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">TransactionAttribute 表示的数据对象。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">c、对事物处理实现（事务的生成、提交、回滚、挂起）</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">spring 委托给具体的事务处理器实现。实现了一个抽象和适配。适配的具体事务处理器：DataSource 数据源支持、hibernate 数据源事务处理支持、JDO 数据源事务处理支持，JPA、JTA 数据源事务处理支持。这些支持都是通过设计</p><p class="s154" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">PlatformTransactionManager、AbstractPlatforTransaction 一系列事务处理的支持。 为常用数据源支持提供了一系列的 TransactionManager。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 33pt;text-indent: -10pt;line-height: 13pt;text-align: left;">d、结合</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">PlatformTransactionManager 实现了 TransactionInterception 接口，让其与 TransactionProxyFactoryBean 结合起来，形成一个 Spring 声明式事务处理的设计体系。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">如何自定义注解实现功能</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">创建自定义注解和创建一个接口相似，但是注解的 interface 关键字需要以@符号开头。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">注解方法不能带有参数；</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">注解方法返回值类型限定为：基本类型、String、Enums、Annotation 或者是这些类型的数组；</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 33pt;text-indent: -10pt;line-height: 13pt;text-align: left;">注解方法可以有默认值；</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">注解本身能够包含元注解，元注解被用来注解其它注解。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring MVC 运行流程</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">1.spring mvc 将所有的请求都提交给 DispatcherServlet,它会委托应用系统的其他模块负责对请求 进行真正的处理工作。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 33pt;text-indent: -10pt;line-height: 13pt;text-align: left;">2.DispatcherServlet 查询一个或多个 HandlerMapping,找到处理请求的 Controller.</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">3.DispatcherServlet 请请求提交到目标 Controller</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">4.Controller 进行业务逻辑处理后，会返回一个 ModelAndView</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">5.Dispathcher 查询一个或多个 ViewResolver 视图解析器,找到 ModelAndView 对象指定的视图对象</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 33pt;text-indent: -10pt;line-height: 13pt;text-align: left;">6.视图对象负责渲染返回给客户端。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Spring MVC 启动流程</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 32pt;text-indent: -9pt;text-align: left;">在 web.xml 文件中给 Spring MVC 的 Servlet 配置了 load-on-startup,所以程序启动的</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">时候会初始化 Spring MVC，在 HttpServletBean 中将配置的 contextConfigLocation</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 32pt;text-indent: -9pt;text-align: left;">属性设置到 Servlet 中，然后在 FrameworkServlet 中创建了 WebApplicationContext,</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">DispatcherServlet 根据 contextConfigLocation 配置的 classpath 下的 xml 文件初始化了</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 33pt;text-indent: -10pt;line-height: 13pt;text-align: left;">Spring MVC 总的组件。</p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="936" alt="image" src="整合_files/Image_425.png"/></span></p><p class="s153" style="padding-top: 6pt;padding-left: 1pt;text-indent: 0pt;text-align: left;">Spring 的单例实现原理</p><ul id="l153"><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 9pt;text-indent: -8pt;text-align: left;">Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是</p><p class="s154" style="padding-top: 2pt;padding-left: 1pt;text-indent: 0pt;text-align: left;">ConcurrentHashMap 对象。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">Spring 框架中用到了哪些设计模式</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 11pt;text-indent: -10pt;text-align: left;">代理模式—在 AOP 和 remoting 中被用的比较多。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 11pt;text-indent: -10pt;text-align: left;">单例模式—在 spring 配置文件中定义的 bean 默认为单例模式。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 1pt;text-indent: 0pt;line-height: 115%;text-align: left;">模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 11pt;text-indent: -10pt;line-height: 13pt;text-align: left;">前端控制器—Spring 提供了 DispatcherServlet 来对请求进行分发。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 1pt;text-indent: 0pt;line-height: 115%;text-align: left;">视图帮助(View Helper )—Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 11pt;text-indent: -10pt;line-height: 13pt;text-align: left;">依赖注入—贯穿于 BeanFactory / ApplicationContext 接口的核心理念。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 11pt;text-indent: -10pt;text-align: left;">工厂模式—BeanFactory 用来创建对象的实例。</p></li></ul><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="499" alt="image" src="整合_files/Image_426.png"/></span></p><p class="s155" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Netty</p><p class="s153" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">为什么选择 Netty</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">1) API 使用简单，开发门槛低；</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">2) 功能强大，预置了多种编解码功能，支持多种主流协议；</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">3) 定制能力强，可以通过 ChannelHandler 对通信框架进行灵活的扩展；</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">4) 性能高，通过与其它业界主流的 NIO 框架对比，Netty 的综合性能最优；</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">5) 成熟、稳定，Netty 修复了已经发现的所有 JDK NIO BUG，业务开发人员不需要再为 NIO 的 BUG 而烦恼；</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">6) 社区活跃，版本迭代周期短，发现的 BUG 可以被及时修复，同时，更多的新功能会被加入；</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">7) 经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 33pt;text-indent: -10pt;line-height: 13pt;text-align: left;">正是因为这些优点，Netty 逐渐成为 Java NIO 编程的首选框架。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">说说业务中，Netty 的使用场景</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">构建高性能、低时延的各种 Java 中间件，例如 MQ、分布式服务框架、ESB 消息总线等， Netty 主要作为基础通信框架提供高性能、低时延的通信服务；</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">公有或者私有协议栈的基础通信框架，例如可以基于 Netty 构建异步、高性能的 WebSocket 协议栈；</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">各领域应用，例如大数据、游戏等，Netty 作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">原生的 NIO 在 JDK 1.7 版本存在 epoll bug</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">它会导致 Selector 空轮询，最终导致 CPU 100%。官方声称在 JDK 1.6 版本的 update18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 BUG 发生概率降低了一些而已，它并没有得到根本性解决。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 TCP 粘包/拆包</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">1、要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">2、待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">3、要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 33pt;text-indent: -10pt;line-height: 13pt;text-align: left;">4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">TCP 粘包/拆包的解决办法</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">2、发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Netty 线程模型</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">首先，Netty 使用 EventLoop 来处理连接上的读写事件，而一个连接上的所有请求都保证在一个 EventLoop 中被处理，一个 EventLoop 中只有一个 Thread，所以也就实现了一个连接上的所有事件只会在一个线程中被执行。一个 EventLoopGroup 包含多个 EventLoop，可以把一个 EventLoop 当做是 Reactor 线程模型中的一个线程，而一个 EventLoopGroup 类似于一个 ExecutorService</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s153" style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">说说 Netty 的零拷贝</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">“零拷贝”是指计算机操作的过程中，CPU 不需要为数据在内存之间的拷贝消耗资源。而它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间（User Space）而直接在内核空间（Kernel Space）中传输到网络的方式。</p><p class="s153" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Netty 内部执行流程</p></li><li data-list-text="&gt;"><p class="s154" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">1. Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p></li></ul></li></ul><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="915" alt="image" src="整合_files/Image_427.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="558" height="83" alt="image" src="整合_files/Image_428.png"/></span></p><ul id="l154"><li data-list-text="&gt;"><p class="s154" style="padding-top: 1pt;padding-left: 1pt;text-indent: 0pt;line-height: 115%;text-align: left;">2. Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</p></li><li data-list-text="&gt;"><p class="s154" style="padding-left: 11pt;text-indent: -10pt;line-height: 13pt;text-align: left;">3. Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到</p></li></ul><p style="text-indent: 0pt;text-align: left;"/><table style="border-collapse:collapse;margin-left:15.5pt" cellspacing="0"><tr style="height:63pt"><td style="width:430pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#BBBBBB" colspan="4" bgcolor="#F8FAFB"><p class="s156" style="padding-top: 2pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">前后端分离是如何做的</p></td></tr><tr style="height:117pt"><td style="width:178pt;border-top-style:solid;border-top-width:1pt;border-top-color:#BBBBBB;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD" bgcolor="#F6F6F6"><p class="s157" style="padding-top: 3pt;padding-left: 7pt;padding-right: 7pt;text-indent: 0pt;text-align: left;">在前后端分离架构中，后端只需要负责按照约定的数据格式向前端提供可调用的 API 服务即可。前后端之间通过 HTTP 请求进行交互，前端获取到数据后，进行页面的组装和渲染，最终返回给浏览器。</p></td><td style="width:112pt;border-top-style:solid;border-top-width:1pt;border-top-color:#BBBBBB;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD" bgcolor="#F6F6F6"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s157" style="padding-top: 9pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">后端</p></td><td style="width:113pt;border-top-style:solid;border-top-width:1pt;border-top-color:#BBBBBB;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD" bgcolor="#F6F6F6"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s157" style="padding-top: 9pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">前端</p></td><td style="width:27pt;border-top-style:solid;border-top-width:1pt;border-top-color:#BBBBBB;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD" bgcolor="#F6F6F6"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:24pt"><td style="width:178pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s157" style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">服务器</p></td><td style="width:112pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s157" style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">浏览器</p></td><td style="width:113pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:27pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD" rowspan="3"><p style="text-indent: 0pt;text-align: left;"><br/></p></td></tr><tr style="height:24pt"><td style="width:178pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s157" style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">JAVA</p></td><td style="width:112pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s157" style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">NodeJS</p></td><td style="width:113pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s157" style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;text-align: left;">JS + HTML + CSS</p></td></tr><tr style="height:102pt"><td style="width:178pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s157" style="padding-top: 7pt;padding-left: 7pt;padding-right: 13pt;text-indent: 0pt;text-align: left;">服务层提供数据接口维持数据稳定封装业务逻辑</p></td><td style="width:112pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p class="s157" style="padding-top: 3pt;padding-left: 7pt;padding-right: 7pt;text-indent: 0pt;text-align: left;">跑在服務器上的 JS 转发数据，串接服务路由设计，控制逻辑渲染页 面，体验优化更多的可能</p></td><td style="width:113pt;border-top-style:solid;border-top-width:1pt;border-top-color:#DDDDDD;border-left-style:solid;border-left-width:1pt;border-left-color:#DDDDDD;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#DDDDDD;border-right-style:solid;border-right-width:1pt;border-right-color:#DDDDDD"><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s157" style="padding-left: 7pt;padding-right: 8pt;text-indent: 0pt;text-align: left;">跑在浏览器上的 JSCSS、JS 加載與運行 DOM 操作任何的前端框架與工具共用模版、路由</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 1pt;text-indent: 0pt;text-align: left;">微服务哪些框架</h4><p class="s158" style="padding-top: 7pt;padding-left: 1pt;text-indent: 0pt;line-height: 161%;text-align: left;">Dubbo，是阿里巴巴服务化治理的核心框架，并被广泛应用于阿里巴巴集团的各成员站点。阿里巴巴近几年对开源社区的贡献不论在国内还是国外都是引人注目的，比如： JStorm 捐赠给 Apache 并加入 Apache 基金会等，为中国互联网人争足了面子，使得阿里巴巴在国人眼里已经从电商升级为一家科技公司了。</p><p class="s158" style="padding-left: 1pt;text-indent: 0pt;line-height: 161%;text-align: left;">Spring Cloud，从命名我们就可以知道，它是 Spring Source 的产物，Spring 社区的强大背书可以说是 Java 企业界最有影响力的组织了，除了 Spring Source 之外，还有 Pivotal 和 Netfix 是其强大的后盾与技术输出。其中 Netflix 开源的整套微服务架构套件是 Spring Cloud 的核心。</p><p class="s159" style="padding-top: 11pt;padding-left: 1pt;text-indent: 0pt;text-align: left;">说说 RPC 的实现原理</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s154" style="padding-left: 1pt;text-indent: 0pt;line-height: 115%;text-align: left;">首先需要有处理网络连接通讯的模块，负责连接建立、管理和消息的传输。其次需要有编解码的模块，因为网络通讯都是传输的字节码，需要将我们使用的对象序列化和反序列 化。剩下的就是客户端和服务器端的部分，服务器端暴露要开放的服务接口，客户调用服务接口的一个代理实现，这个代理实现负责收集数据、编码并传输给服务器然后等待结果返回。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s159" style="padding-left: 1pt;text-indent: 0pt;text-align: left;">说说 Dubbo 的实现原理</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s154" style="padding-left: 1pt;text-indent: 0pt;line-height: 115%;text-align: left;">dubbo 作为 rpc 框架，实现的效果就是调用远程的方法就像在本地调用一样。如何做到 呢？就是本地有对远程方法的描述，包括方法名、参数、返回值，在 dubbo 中是远程和本地使用同样的接口；然后呢，要有对网络通信的封装，要对调用方来说通信细节是完全不可见的，网络通信要做的就是将调用方法的属性通过一定的协议（简单来说就是消息格 式）传递到服务端；服务端按照协议解析出调用的信息；执行相应的方法；在将方法的返回值通过协议传递给客户端；客户端再解析；在调用方式上又可以分为同步调用和异步调用；简单来说基本就这个过程</p><p style="padding-left: 21pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l155"><li data-list-text=""><p style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://www.cnblogs.com/artech/p/3506553.html" class="s136" target="_blank">怎么理解 RESTful </a><a href="http://www.cnblogs.com/artech/p/3506553.html" target="_blank">http://www.cnblogs.com/artech/p/3506553.html</a></p></li><li data-list-text=""><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="https://juejin.im/entry/59b8d34c6fb9a00a4455dd04" class="s136" target="_blank">说说如何设计一个良好的 API </a><a href="https://juejin.im/entry/59b8d34c6fb9a00a4455dd04" target="_blank">https://juejin.im/entry/59b8d34c6fb9a00a4455dd04</a></p></li><li data-list-text=""><p class="s19" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">如何理解 RESTful API 的幂等性</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://blog.720ui.com/2016/restful_idempotent/">http://blog.720ui.com/2016/restful_idempotent/</a></p></li><li data-list-text=""><p class="s19" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">如何保证接口的幂等性</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://www.spring4all.com/article/914">http://www.spring4all.com/article/914</a></p></li><li data-list-text=""><p class="s19" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">说说 CAP 定理、 BASE 理论</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://my.oschina.net/foodon/blog/372703">http://my.oschina.net/foodon/blog/372703</a></p></li><li data-list-text=""><p class="s19" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">怎么考虑数据一致性问题</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="https://opentalk.upyun.com/310.html">https://opentalk.upyun.com/310.html</a></p></li><li data-list-text=""><p class="s19" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">说说最终一致性的实现方案</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://www.cnblogs.com/soundcode/p/5590710.html">http://www.cnblogs.com/soundcode/p/5590710.html</a></p></li><li data-list-text=""><p class="s19" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">你怎么看待微服务</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://dockone.io/article/394">http://dockone.io/article/394</a></p></li><li data-list-text=""><p class="s19" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">微服务与 SOA 的区别</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://dockone.io/article/2399">http://dockone.io/article/2399</a></p></li><li data-list-text=""><p class="s19" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">如何拆分服务</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://dockone.io/article/2516">http://dockone.io/article/2516</a></p></li><li data-list-text=""><p class="s19" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">微服务如何进行数据库管理</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://www.uml.org.cn/wfw/201705271.asp">http://www.uml.org.cn/wfw/201705271.asp</a></p></li><li data-list-text=""><p class="s19" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">如何应对微服务的链式调用异常</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span style=" color: #1B1F21; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 12pt;">http://blog.720ui.com/2017/msa_design/?utm_source=tuicool&amp;utm_medium=</span><a href="http://blog.720ui.com/2017/msa_design/?utm_source=tuicool&amp;utm_medium=referral" style=" color: #1B1F21; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt;" target="_blank"> </a><a href="http://blog.720ui.com/2017/msa_design/?utm_source=tuicool&amp;utm_medium=referral" target="_blank">referral</a></p></li><li data-list-text=""><p class="s19" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">对于快速追踪与定位问题依赖日志</p></li><li data-list-text=""><p class="s19" style="padding-left: 40pt;text-indent: -17pt;text-align: left;">微服务的安全</p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="http://dockone.io/article/1507">http://dockone.io/article/1507</a></p><p class="s161" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">请简洁描述 MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？</p><p class="s162" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 44pt;text-align: left;">SQL 标准定义的四个隔离级别为： <b>read uncommited ：</b>读到未提交数据 <b>read committed：</b>脏读，不可重复读 <b>repeatable read：</b>可重读 <b>serializable ：</b>串行事物</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">在 MySQL 中 ENUM 的用法是什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">SQL 语法如下：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s164" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Create table size<span class="s165">(</span>name <span class="s165">ENUM(</span><span class="s166">&#39;Smail,&#39;</span>Medium<span class="s166">&#39;,&#39;</span>Large<span class="s166">&#39;);</span></p><p class="s161" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">CHAR 和 VARCHAR 的区别？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">CHAR 和 VARCHAR 类型在存储和检索方面有所不同。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。</p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">列的字符串类型可以是什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">字符串类型是：</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 219%;text-align: left;">SET BLOB ENUM CHAR TEXT</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 20pt;text-align: left;">VARCHAR</p><p class="s161" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">MySQL 中使用什么存储引擎？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 219%;text-align: left;">存储引擎称为表类型，数据使用各种技术存储在文件中。技术涉及：</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 219%;text-align: left;">Storage mechanism Locking levels Indexing</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 20pt;text-align: left;">Capabilities and functions.</p><p class="s161" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">创建表时 TIMESTAMP 列用 Zero 更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间。</p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">主键和候选键有什么区别？</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">表格的每一行都由主键唯一标识, 一个表只有一个主键。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">MySQL 数据库服务器性能分析的方法命令有哪些?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 153%;text-align: left;">Show status 一些值得监控的变量值： Bytes<span class="s167">received 和 Bytes</span>sent 和服务器之间来往的流量。 Com <b>服务器正在执行的命令。 Created </b>在查询执行期限间创建的临时表和文件。 Handler <b>存储引擎操作。 Select </b>不同类型的联接执行计划。 Sort_* 几种排序信息。 Show session status like ‘Select’; Show profiles SET profiling=1; Show profiles\G Show profile;</p><p class="s161" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">LIKE 和 REGEXP 操作有什么区别？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">LIKE 和 REGEXP 运算符用于表示 ^ 和％。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s165" style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><b>SELECT </b>* <b>FROM </b>&lt;tablename&gt; <b>WHERE </b>* REGEXP <span style=" color: #800;">&quot;^b&quot;</span>;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s164" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">SELECT <span class="s165">* </span>FROM <span class="s165">&lt;tablename&gt; </span>WHERE <span class="s165">* </span>LIKE <span class="s166">&quot;%b&quot;</span><span class="s165">;</span></p><p class="s161" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">BLOB 和 TEXT 有什么区别？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-left: 23pt;text-indent: 0pt;text-align: left;">BLOB</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l156"><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">TINYBLOB</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">BLOB</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">MEDIUMBLOB 和</p></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">LONGBLOB</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">它们只能在所能容纳价值的最大长度上有所不同。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-left: 23pt;text-indent: 0pt;text-align: left;">TEXT</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">TEXT 是一个不区分大小写的 BLOB。四种 TEXT 类型</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">TINYTEXT</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">TEXT</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">MEDIUMTEXT 和</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">LONGTEXT</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">它们对应于四种 BLOB 类型，并具有相同的最大长度和存储要求。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT 值不区分大小写。</p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">数据库的三范式？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 219%;text-align: left;">第一范式：数据库表的每一个字段都是不可分割的。第二范式：数据库表中的非主属性只依赖于主键。</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">第三范式：不存在非主属性对关键字的传递函数依赖关系。</p><p class="s161" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">MySQL 表中允许有多少个 TRIGGERS？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">在 MySQL 表中允许有六个触发器，如下：</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 219%;text-align: left;">BEFORE INSERT AFTER INSERT BEFORE UPDATE AFTER UPDATE BEFORE DELETE and</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 20pt;text-align: left;">AFTER DELETE</p><p class="s161" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是通用 SQL 函数？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s168" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">数学函数</p></li><li data-list-text=""><p class="s162" style="padding-top: 27pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">Abs（num）求绝对值</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">floor（num）向下取整</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">ceil（num）向上取整</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s168" style="padding-left: 23pt;text-indent: 0pt;line-height: 50pt;text-align: left;">字符串函数</p></li><li data-list-text=""><p class="s162" style="padding-top: 27pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">insert (s1,index,length,s2) 替换函数</p><ul id="l157"><li data-list-text="o"><p class="s162" style="padding-top: 10pt;padding-left: 95pt;text-indent: -18pt;text-align: left;">S1 表示被替换的字符串</p></li><li data-list-text="o"><p class="s162" style="padding-left: 95pt;text-indent: -18pt;text-align: left;">s2 表示将要替换的字符串</p></li><li data-list-text="o"><p class="s162" style="padding-top: 10pt;padding-left: 95pt;text-indent: -18pt;text-align: left;">Index 表示被替换的位置, 从 1 开始</p></li><li data-list-text="o"><p class="s162" style="padding-top: 10pt;padding-left: 95pt;text-indent: -18pt;text-align: left;">Lebgth 表示被替换的长度</p></li></ul></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">upper（str），ucase（str）将字母改为大写</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">lower（str），lcase（str）将字母改为小写</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">left（str，length）返回 str 字符串的前 length 个字符</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">right（str，length）返回 str 字符串的后 length 个字符</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">substring（str，index，length）返回 str 字符串从 index 位开始长度为</p><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">length 个字符（index 从 1 开始）</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">reverse（str）将 str 字符串倒序输出</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s168" style="padding-left: 23pt;text-indent: 0pt;line-height: 50pt;text-align: left;">日期函数</p></li><li data-list-text=""><p class="s162" style="padding-top: 27pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">curdate（）、current_date( ) 获取当前日期</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">curtime（）、current_time( ) 获取当前日期</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">now（）获取当前日期和时间</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">datediff（d1、d2）d1 和 d2 之间的天数差</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">adddate（date，num）返回 date 日期开始，之后 num 天的日期</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">subdate（date，num）返回 date 日期开始，之前 num 天的日期</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s168" style="padding-left: 23pt;text-indent: 0pt;line-height: 50pt;text-align: left;">聚合函数</p></li><li data-list-text=""><p class="s162" style="padding-top: 27pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">Count（字段）根据某个字段统计总记录数（当前数据库保存到多少条数据）</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">sum（字段）计算某个字段的数值总和</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">avg（字段）计算某个字段的数值的平均值</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">Max（字段）、min（字段）求某个字段最大或最小值</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">MySQL 中有哪几种锁？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">MySQL 数据优化。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s163" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">优化数据类型</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l158"><li data-list-text="o"><p class="s162" style="padding-left: 95pt;text-indent: -18pt;line-height: 154%;text-align: left;">避免使用 NULL，NULL 需要特殊处理, 大多数时候应该使用 NOT NULL，或者使用一个特殊的值，如 0，-1 作为默认值。</p></li><li data-list-text="o"><p class="s162" style="padding-left: 95pt;text-indent: -18pt;line-height: 154%;text-align: justify;">仅可能使用更小的字段，MySQL 从磁盘读取数据后是存储到内存中的，然后使用 cpu 周期和磁盘 I/O 读取它，这意味着越小的数据类型占用的空间越小.</p></li></ul></li><li data-list-text=""><p class="s163" style="padding-left: 59pt;text-indent: -18pt;line-height: 20pt;text-align: justify;">小心字符集转换</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l159"><li data-list-text="o"><p class="s162" style="padding-left: 18pt;text-indent: -18pt;text-align: right;">客户端或应用程序使用的字符集可能和表本身的字符集不一样，这需要</p><p class="s162" style="padding-top: 10pt;text-indent: 0pt;text-align: right;">MySQL 在运行过程中隐含地进行转换，此外，要确定字符集如 UTF-</p><p class="s162" style="padding-top: 10pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">8 是否支持多字节字符，因此它们需要更多的存储空间。</p></li></ul></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: justify;">_<span class="s167">优化 count(my</span>col) 和 count(<span class="s167">)</span>*</p></li><li data-list-text=""><p class="s163" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: justify;">优化子查询</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l160"><li data-list-text="o"><p class="s162" style="padding-left: 95pt;text-indent: -18pt;line-height: 154%;text-align: left;">遇到子查询时，MySQL 查询优化引擎并不是总是最有效的，这就是为什么经常将子查询转换为连接查询的原因了，优化器已经能够正确处理连接查询了，当然要注意的一点是，确保连接表 (第二个表) 的连接列是有索引的，在第一个表上 MySQL 通常会相对于第二个表的查询子集进行一次全表扫描，这是嵌套循环算法的一部分。</p></li></ul></li><li data-list-text=""><p class="s163" style="padding-left: 59pt;text-indent: -18pt;line-height: 20pt;text-align: justify;">优化 UNION</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l161"><li data-list-text="o"><p class="s162" style="padding-left: 95pt;text-indent: -18pt;line-height: 154%;text-align: left;">在跨多个不同的数据库时使用 UNION 是一个有趣的优化方法， UNION 从两个互不关联的表中返回数据，这就意味着不会出现重复的行，同时也必须对数据进行排序，我们知道排序是非常耗费资源的，特别是对大表的排序。</p></li><li data-list-text="o"><p class="s162" style="padding-left: 95pt;text-indent: -18pt;line-height: 154%;text-align: left;">UNION ALL 可以大大加快速度，如果你已经知道你的数据不会包括重复行，或者你不在乎是否会出现重复的行，在这两种情况下使用</p><p class="s162" style="padding-left: 95pt;text-indent: 0pt;line-height: 154%;text-align: justify;">UNION ALL 更适合。此外，还可以在应用程序逻辑中采用某些方法避免出现重复的行，这样 UNION ALL 和 UNION 返回的结果都是一样的，但 UNION ALL 不会进行排序。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">MySQL 的关键字。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">添加索引：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s164" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">alter table <span class="s165">tableName </span>add <span class="s169">索引（索引字段）</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">主键：primary key</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 219%;text-align: justify;">唯一：unique全局：fulltext普通：index</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 20pt;text-align: left;">多列： index index_name</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">页级: 引擎 BDB。次锁定相邻的一组记录。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">表级: 引擎 MyISAM ， 理解为锁住整个表，可以同时读，写不行。 行级: 引擎 INNODB ， 单独的一行记录加锁，对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。 表级锁速度快，但冲突多，行级冲突少，但速度慢。</p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">存储引擎。</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">MyISAM：这种引擎是 mysql 最早提供的。这种引擎又可以分为静态</p><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">MyISAM、动态 MyISAM 和压缩 MyISAM 三种：</p><ul id="l162"><li data-list-text="o"><p class="s162" style="padding-top: 10pt;padding-left: 95pt;text-indent: -18pt;line-height: 154%;text-align: justify;">静态 MyISAM：如果数据表中的各数据列的长度都是预先固定好的，服务器将自动选择这种表类型。因为数据表中每一条记录所占用的空间都是一样的，所以这种表存取和更新的效率非常高。当数据受损时，恢复工作也比较容易做。</p></li><li data-list-text="o"><p class="s162" style="padding-left: 95pt;text-indent: -18pt;line-height: 154%;text-align: justify;">动态 MyISAM：如果数据表中出现 varchar、text 或 BLOB 字段 时，服务器将自动选择这种表类型。相对于静态 MyISAM，这种表存</p><p class="s162" style="padding-left: 95pt;text-indent: 0pt;line-height: 154%;text-align: left;">储空间比较小，但由于每条记录的长度不一，所以多次修改数据后，数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。因此，这种类型的表要经常用 optimize table 命令或优化工具来进行碎片整理。</p></li><li data-list-text="o"><p class="s162" style="padding-left: 95pt;text-indent: -18pt;line-height: 154%;text-align: justify;">压缩 MyISAM：以上说到的两种类型的表都可以用 myisamchk 工具压缩。这种类型的表进一步减小了占用的存储，但是这种表压缩之后不能再被修改。另外，因为是压缩数据，所以这种表在读取的时候要先时行解压缩。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">但是，不管是何种 MyISAM 表，目前它都不支持事务，行级锁和外键约束的功能。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ul></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;line-height: 154%;text-align: left;">MyISAM Merge 引擎：这种类型是 MyISAM 类型的一种变种。合并表是将几个相同的 MyISAM 表合并为一个虚表。常应用于日志和数据仓库。</p></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;line-height: 154%;text-align: justify;">InnoDB：InnoDB 表类型可以看作是对 MyISAM 的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能。</p></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;line-height: 154%;text-align: justify;">memory(heap)：这种类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中。</p></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;line-height: 20pt;text-align: justify;">archive：这种类型只支持 select 和 insert 语句，而且不支持索引。</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">Desc[ribe] tablename：查看数据表的结构。</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">show engines：命令可以显示当前数据库支持的存储引擎情况。</p><p class="s161" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">数据库备份。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">必须要在未登录状态下</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">导出整个数据库</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s165" style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><b>mysqldump </b>-u <span class="s169">用户名 </span>-p <span class="s169">数据库名 </span>&gt; <span class="s169">导出的文件名</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">导出一个表</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s165" style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><b>mysqldump </b>-u <span class="s169">用户名 </span>-p <span class="s169">数据库名 表名</span>&gt; <span class="s169">导出的文件名</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">导出一个数据库结构</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s164" style="padding-left: 23pt;text-indent: 0pt;line-height: 114%;text-align: left;">mysqldump <span class="s165">-u dbuser -p -d --add-drop-table dbname &gt;d:/dbname_db.sql</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">-d 没有数据 --add-drop-table 在每个 create 语句之前增加一个 drop table</p><p class="s161" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">truncate delete drop 的区别。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s163" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">drop(DDL 语句)：<span class="s162">是不可逆操作，会将表所占用空间全部释放掉；</span></p><p class="s163" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">truncate(DDL 语句)：<span class="s162">只针对于删除表的操作，在删除过程中不会激活与表有关的删除触发器并且不会把删除记录放在日志中；当表被 truncate 后，这个表和索引会恢复到初始大小；</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s163" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">delete(DML 语句)：<span class="s162">可以删除表也可以删除行，但是删除记录会被计入日志保存，而且表空间大小不会恢复到原来；</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">执行速度：drop&gt;truncate&gt;delete。</p><p class="s161" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Redis 是什么？两句话做一下概括。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">是一个完全开源免费的 key-value 内存数据库 2. 通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">Redis 使用最佳方式是全部数据 in-memory。</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">Redis 更多场景是作为 Memcached 的替代者来使用。</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">当需要除 key/value 之外的更多数据类型支持时，使用 Redis 更合适。</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">当存储的数据不能被剔除时，使用 Redis 更合适。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Redis（管道，哈希）。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;line-height: 154%;text-align: left;">Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset， hash 等数据结构的存储。</p></li><li data-list-text=""><p class="s162" style="padding-left: 59pt;text-indent: -18pt;line-height: 20pt;text-align: left;">Redis 支持数据的备份，即 master-slave 模式的数据备份。</p></li><li data-list-text=""><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;line-height: 154%;text-align: left;">Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p></li></ul></li></ul><p class="s161" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Redis 实现原理或机制。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">Redis 是一个 key-value 存储系统。和 Memcached 类似，但是解决了断电后数据完全丢失的情况，而且她支持更多无化的 value 类型，除了和 string 外，还支持 lists（链表）、sets（集合）和 zsets（有序集合）几种数据类型。这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">Redis 是一种基于客户端 - 服务端模型以及请求 / 响应协议的 TCP 服务。这意味着通常情况下一个请求会遵循以下步骤：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">客户端向服务端发送一个查询请求，并监听 Socket 返回，通常是以阻塞模式，等待服务端响应。服务端处理命令，并将结果返回给客户端。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Redis 管道技术最显著的优势是提高了 Redis 服务的性能。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">分区是分割数据到多个 Redis 实例的处理过程，因此每个实例只保存 key 的一个子集。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">通过利用多台计算机内存的和值，允许我们构造更大的数据库。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Redis 的一些特性在分区方面表现的不是很好：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">涉及多个 key 的操作通常是不被支持的。举例来说，当两个 set 映射到不同的</p><p class="s162" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;line-height: 219%;text-align: left;">Redis 实例上时，你就不能对这两个 set 执行交集操作。涉及多个 key 的 Redis 事务不能使用。</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">当使用分区时，数据处理较为复杂，比如你需要处理多个 rdb/aof 文件，并且从多个实例和主机备份持久化文件。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">增加或删除容量也比较复杂。Redis 集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然 而，一种叫做 presharding 的技术对此是有帮助的。</p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Redis 有两种类型分区。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的 Redis 实例。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">比如，ID 从 0 到 10000 的用户会保存到实例 R0，ID 从 10001 到 20000 的用户会保存到 R1，以此类推。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射 表。这个表要被管理，同时还需要各 种对象的映射表，通常对 Redis 来说并非是好的方法。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">哈希分区：另外一种分区方法是 hash 分区。这对任何 key 都适用，也无需是</p><p class="s162" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">object_name: 这种形式，像下面描述的一样简单：</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">用一个 hash 函数将 key 转换为一个数字，比如使用 crc32 hash 函数。对 key foobar 执行 crc32(foobar) 会输出类似 93024922 的整数。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">对这个整数取模，将其转化为 0-3 之间的数字，就可以将这个整数映射到 4 个 Redis 实例中的一个了。93024922 % 4 = 2，就是说 key foobar 应该被存到 R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用 % 操作符实现。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">实际上，上面的集群模式还存在两个问题：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l163"><li data-list-text="1."><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">扩容问题：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;line-height: 154%;text-align: left;">因为使用了一致性哈稀进行分片，那么不同的 key 分布到不同的 Redis- Server 上，当我们需要扩容时，需要增加机器到分片列表中，这时候会使得同样的 key 算出来落到跟原来不同的机器上，这样如果要取某一个值，会出现取不到的情况，对于这种情况，Redis 的作者提出了一种名为 Pre- Sharding 的方式：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;line-height: 154%;text-align: left;">Pre-Sharding 方法是将每一个台物理机上，运行多个不同断口的 Redis 实例，假如有三个物理机，每个物理机运行三个 Redis 实际，那么我们的分片列表中实际有 9 个 Redis 实例，当我们需要扩容时，增加一台物理机，步骤如下：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l164"><li data-list-text="1."><p class="s162" style="padding-left: 95pt;text-indent: -18pt;text-align: left;">在新的物理机上运行 Redis-Server；</p></li><li data-list-text="2."><p class="s162" style="padding-top: 10pt;padding-left: 95pt;text-indent: -18pt;text-align: left;">该 Redis-Server 从属于 (slaveof) 分片列表中的某一 Redis-Server</p><p class="s162" style="padding-top: 10pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">（假设叫 RedisA）；</p></li><li data-list-text="3."><p class="s162" style="padding-left: 95pt;text-indent: -18pt;text-align: left;">等主从复制 (Replication) 完成后，将客户端分片列表中 RedisA 的</p><p class="s162" style="padding-top: 10pt;padding-left: 95pt;text-indent: 0pt;text-align: left;">IP 和端口改为新物理机上 Redis-Server 的 IP 和端口；</p></li><li data-list-text="4."><p class="s162" style="padding-top: 10pt;padding-left: 95pt;text-indent: -18pt;text-align: left;">停止 RedisA。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;line-height: 154%;text-align: justify;">这样相当于将某一 Redis-Server 转移到了一台新机器上。Prd-Sharding 实际上是一种在线扩容的办法，但还是很依赖 Redis 本身的复制功能的，如果主库快照数据文件过大，这个复制的过程也会很久，同时会给主库带来压力。所以做这个拆分的过程最好选择为业务访问低峰时段进行。</p></li></ol></li><li data-list-text="2."><p class="s162" style="padding-left: 59pt;text-indent: -18pt;line-height: 20pt;text-align: justify;">单点故障问题：</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;line-height: 154%;text-align: left;">还是用到 Redis 主从复制的功能，两台物理主机上分别都运行有 Redis- Server，其中一个 Redis-Server 是另一个的从库，采用双机热备技术，客户端通过虚拟 IP 访问主库的物理 IP，当主库宕机时，切换到从库的物理 IP。只是事后修复主库时，应该将之前的从库改为主库（使用命令 slaveof no one），主库变为其从库（使命令 slaveof IP PORT），这样才能保证修复期间新增数据的一致性。</p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">什么是 MongoDB。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">非关系型数据库 (NoSql),Mongo DB 很好的实现了面向对象的思想 (OO 思想), 在 Mongo DB 中 每一条记录都是一个 Document 对象。Mongo DB 最大的优势在于所有的数据持久操作都无需开发人员手动编写 SQL 语句, 直接调用方法就可以轻松的实现 CRUD 操作.</p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">MongoDB 特点。</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 219%;text-align: left;">高性能、易部署、易使用，存储数据非常方便。主要功能特性有：面向集合存储，易存储对象类型的数据。</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">模式自由。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">支持动态查询。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 219%;text-align: left;">支持完全索引，包含内部对象。支持查询。</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">支持复制和故障恢复。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 219%;text-align: left;">使用高效的二进制数据存储，包括大型对象（如视频等）。自动处理碎片，以支持云计算层次的扩展性</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++ 语言的驱动程序，社区中也提供了对 Erlang 及. NET 等平台的驱动程序。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">文件存储格式为 BSON（一种 JSON 的扩展）。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">可通过网络访问。</p><p class="s161" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">MongoDB 的功能。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">面向集合的存储：适合存储对象及 JSON 形式的数据。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">动态查询：Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记，可轻易查询文档中内嵌的对象及数组。</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">完整的索引支持：包括文档内嵌对象及数组。Mongo 的查询优化器会分析查询表达式，并生成一个高效的查询计划。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">查询监视：Mongo 包含一个监视工具用于分析数据库操作的性能。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">复制及自动故障转移：Mongo 数据库支持服务器之间的数据复制，支持主 - 从模式及服务器之间的相互复制。复制的主要目标是提供冗余及自动故障转移。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">高效的传统存储方式：支持二进制数据及大型对象（如照片或图片）</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">自动分片以支持云级别的伸缩性：自动分片功能支持水平的数据库集群，可动态添加额外的机器。</p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">MongoDB 的适用场景。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">网站数据：Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">缓存：由于性能很高，Mongo 也适合作为信息基础设施的缓存层。在系统重启之后，由 Mongo 搭建的持久化缓存层可以避免下层的数据源 过载。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">高伸缩性的场景：Mongo 非常适合由数十或数百台服务器组成的数据库。Mongo的路线图中已经包含对 MapReduce 引擎的内置支持。</p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">用于对象及 JSON 数据的存储：Mongo 的 BSON 数据格式非常适合文档化格式的存储及查询。</p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Redis、memcache、MongoDB 对比。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">mongodb 和 memcached 不是一个范畴内的东西。mongodb 是文档型的非关系型数据库，其优势在于查询功能比较强大，能存储海量数据。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">和 memcached 更为接近的是 Redis。它们都是内存型数据库，数据保存在内存</p><p class="s162" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;line-height: 154%;text-align: left;">中，通过 tcp 直接存取，优势是速度快，并发高，缺点是数据类型有限，查询功能不强，一般用作缓存。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l165"><li data-list-text="1."><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">性能</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">Redis 和 memcache 差不多，要大于 mongodb。</p></li><li data-list-text="2."><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">操作的便利性</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">memcache 数据结构单一。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">Redis 丰富一些，数据操作方面，Redis 更好一些，较少的网络 IO 次数。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;line-height: 154%;text-align: left;">mongodb 支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。</p></li><li data-list-text="3."><p class="s162" style="padding-left: 59pt;text-indent: -18pt;line-height: 20pt;text-align: left;">内存空间的大小和数据量的大小</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">Redis 在 2.0 版本后增加了自己的 VM 特性，突破物理内存的限制；可以对</p><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">key value 设置过期时间（类似 memcache）。</p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">memcache 可以修改最大可用内存, 采用 LRU 算法。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;line-height: 154%;text-align: justify;">mongoDB 适合大数据量的存储，依赖操作系统 VM 做内存管理，吃内存也比较厉害，服务不要和别的服务在一起。</p></li><li data-list-text="4."><p class="s162" style="padding-left: 59pt;text-indent: -18pt;line-height: 20pt;text-align: left;">可用性（单点问题）</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;line-height: 154%;text-align: justify;">Redis 对于单点问题，依赖客户端来实现分布式读写；主从复制时，每次从节点重新连接主节点都要依赖整个快照, 无增量复制，因性能和效率问题，所以单点问题比较复杂；不支持自动 sharding, 需要依赖程序设定一致 hash 机制。一种替代方案是，不用 Redis 本身的复制机制，采用自己做主动复制</p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;line-height: 154%;text-align: left;">（多份存储），或者改成增量复制的方式（需要自己实现），一致性问题和性能的权衡。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;line-height: 154%;text-align: left;">Memcache 本身没有数据冗余机制，也没必要；对于故障预防，采用依赖成熟的 hash 或者环状的算法，解决单点故障引起的抖动问题。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;line-height: 154%;text-align: left;">mongoDB 支持 master-slave,replicaset（内部采用 paxos 选举算法，自动故障恢复）,auto sharding 机制，对客户端屏蔽了故障转移和切分机制。</p></li><li data-list-text="5."><p class="s162" style="padding-left: 59pt;text-indent: -18pt;line-height: 20pt;text-align: left;">可靠性（持久化）</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;line-height: 154%;text-align: left;">对于数据持久化和数据恢复，Redis 支持（快照、AOF）：依赖快照进行持久化，aof 增强了可靠性的同时，对性能有所影响。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">memcache 不支持，通常用在做缓存, 提升性能；</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">MongoDB 从 1.8 版本开始采用 binlog 方式支持持久化的可靠性。</p></li><li data-list-text="6."><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">数据一致性（事务支持）</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">Memcache 在并发场景下，用 cas 保证一致性。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">Redis 事务支持比较弱，只能保证事务中的每个操作连续执行。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">mongoDB 不支持事务。</p></li><li data-list-text="7."><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">数据分析</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">mongoDB 内置了数据分析的功能 (mapreduce), 其他不支持。</p></li><li data-list-text="8."><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">应用场景</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">Redis：数据量较小的更性能操作和运算上。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;line-height: 154%;text-align: left;">memcache：用于在动态系统中减少数据库负载，提升性能; 做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用 sharding）。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s162" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">MongoDB: 主要解决海量数据的访问效率问题。</p><p class="s161" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Redis 有什么用？只有了解了它有哪些特性，我们在用的时候才能扬长避短，为我们所用。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l166"><li data-list-text="1."><p class="s163" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">速度快：<span class="s162">使用标准 C 写，所有数据都在内存中完成，读写速度分别达到 10</span></p><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">万 / 20 万。</p></li><li data-list-text="2."><p class="s163" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;line-height: 154%;text-align: left;">持久化：<span class="s162">对数据的更新采用 Copy-on-write 技术，可以异步地保存到磁盘 上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式 (Append-only file，aof) 。</span></p></li><li data-list-text="3."><p class="s163" style="padding-left: 59pt;text-indent: -18pt;line-height: 20pt;text-align: left;">自动操作：<span class="s162">对不同数据类型的操作都是自动的，很安全。</span></p></li><li data-list-text="4."><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">快速的主 -- 从复制，官方提供了一个数据，Slave 在 21 秒即完成了对</p><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">Amazon 网站 10G key set 的复制。</p></li><li data-list-text="5."><p class="s163" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;line-height: 154%;text-align: left;">Sharding 技术： <span class="s162">很容易将数据分布到多个 Redis 实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着 web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配 置、数据库复制形式的，Sharding 这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s161" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">这里对 Redis 数据库做下小结。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l167"><li data-list-text="1."><p class="s162" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">提高了 DB 的可扩展性，只需要将新加的数据放到新加的服务器上就可以了</p></li><li data-list-text="2."><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">提高了 DB 的可用性，只影响到需要访问的 shard 服务器上的数据的用户</p></li><li data-list-text="3."><p class="s162" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;line-height: 154%;text-align: left;">提高了 DB 的可维护性，对系统的升级和配置可以按 shard 一个个来搞，对服务产生的影响较小</p></li><li data-list-text="4."><p class="s162" style="padding-left: 59pt;text-indent: -18pt;line-height: 20pt;text-align: left;">小的数据库存的查询压力小，查询更快，性能更好</p></li></ol><ol id="l168"><li data-list-text="1."><p class="s170" style="padding-top: 1pt;padding-left: 53pt;text-indent: -18pt;text-align: justify;">activemq 的几种通信方式</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s171" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">publish(发布)-subscribe(订阅)(发布-订阅方式)</p><p class="s172" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: justify;">发布/订阅方式用于多接收客户端的方式.作为发布订阅的方式，可能存在多个接收客户端，并且接收端客户端与发送客户端存在时间上的依赖。一个接收端只能接收他创建以后发送客户端发送的信息。作为 subscriber ,在接收消息时有两种方法，destination 的 receive 方法，和实现 message listener 接口的 onMessage 方法。</p><p class="s171" style="padding-top: 12pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">p2p(point-to-point)(点对点)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: justify;">p2p 的过程则理解起来比较简单。它好比是两个人打电话，这两个人是独享这一条通信链路的。一方发送消息，另外一方接收，就这么简单。在实际应用中因为有多个用户对使用 p2p 的链路。</p><p class="s172" style="padding-top: 12pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: justify;">在 p2p 的场景里，相互通信的双方是通过一个类似于队列的方式来进行交流。和前面 pub-sub 的区别在于一个 topic 有一个发送者和多个接收者，而在 p2p里一个 queue 只有一个发送者和一个接收者。</p></li><li data-list-text="2."><p class="s170" style="padding-top: 12pt;padding-left: 32pt;text-indent: -10pt;text-align: justify;">activemq 如果数据提交不成功怎么办(消息丢失)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l169"><li data-list-text="1."><p class="s170" style="padding-left: 53pt;text-indent: -18pt;text-align: justify;">publish(发布)-subscribe(订阅)方式的处理</p></li></ol></li></ol><p class="s172" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: justify;">发布订阅模式的通信方式， 默认情况下只通知一次， 如果接收不到此消息就没有了。 这种场景只适用于对消息送达率要求不高的情况。 如果要求消息必须送达不可以丢失的话， 需要配置持久订阅。 每个订阅端定义一个 id，</p><p class="s171" style="padding-left: 30pt;text-indent: 0pt;text-align: justify;">&lt;property <span class="s172">name=&quot;clientId&quot; 在订阅是向 activemq 注册。 发布消息</span></p><p class="s172" style="padding-top: 1pt;padding-left: 23pt;text-indent: 3pt;line-height: 140%;text-align: left;"><b>&lt;property </b>name=&quot;subscriptionDurable&quot; value=&quot;true&quot;<b>/&gt;</b>和接收消息时需要配置发送模式为持久化 template.setDeliveryMode(DeliveryMode.<span class="s173">PERSISTENT</span>);。 此时如果客户端接收不到消息， 消息会持久化到服务端(就是硬盘上)， 直到客户端正常接收后为止。</p><ol id="l170"><li data-list-text="1."><p class="s170" style="padding-top: 13pt;padding-left: 53pt;text-indent: -18pt;text-align: left;">4.2p - p(点对点)方式的处理</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 53pt;text-indent: 0pt;line-height: 141%;text-align: left;">点对点模式的话， 如果消息发送不成功此消息默认会保到 activemq 服务端直到有消费者将其消费， 所以此时消息是不会丢失的。</p><ol id="l171"><li data-list-text="3."><p class="s170" style="padding-top: 7pt;padding-left: 50pt;text-indent: -9pt;text-align: left;">如何解决消息重复问题</p><p class="s172" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">所谓消息重复,就是消费者接收到了重复的消息,一般来说我们对于这个问题的处理要把握下面几点,</p><p class="s172" style="padding-top: 12pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">①.消息不丢失(上面已经处理了)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">②.消息不重复执行</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">一般来说我们可以在业务段加一张表,用来存放消息是否执行成功,每次业务事物</p><p class="s172" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;line-height: 195%;text-align: justify;">commit 之后,告知服务端,已经处理过该消息,这样即使你消息重发了,也不会导致重复处理大致流程如下:</p><p class="s172" style="padding-top: 1pt;padding-left: 23pt;text-indent: 28pt;line-height: 141%;text-align: justify;">业务端的表记录已经处理消息的 id,每次一个消息进来之前先判断该消息是否执行过,如果执行过就放弃,如果没有执行就开始执行消息,消息执行完成之后存入这个消息的 id</p></li><li data-list-text="4."><p class="s171" style="padding-top: 12pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">大量的消息每页被消费，能否发生 oom 异常？</p><p class="s172" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">可以控制每个消息队列中数据的大小，不允许无线填充数据，避免该队列多大，导致过度消耗系统资源问题； 可以控制队列的内存大小；</p></li><li data-list-text="5."><p class="s171" style="padding-top: 12pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">activeMQ 发送消息的方式有哪些？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">消息通信的基本方式有两种：</p><p class="s172" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1、同步方式</p><p class="s172" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">两个通信应用服务之间必须要进行同步，两个服务之间必须都是正常运行的。发送程序和接收程序都必须一直处于运行状态，并且随时做好相互通信的准 备。</p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: justify;">发送程序首先向接收程序发起一个请求，称之为发送消息，发送程序紧接着就会堵塞当前自身的进程，不与其他应用进行任何的通信以及交互，等待接收程序的响应，待发送消息得到接收程序的返回消息之后会继续向下运行，进行下一步的业务处理。</p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">2、异步方式</p><p class="s172" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">两个通信应用之间可以不用同时在线等待，任何一方只需各自处理自己的业 务，比如发送方发送消息以后不用登录接收方的响应，可以接着处理其他的任务。也就是说发送方和接收方都是相互独立存在的，发送方只管方，接收方只能接收，无须去等待对方的响应。</p><p class="s172" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">Java 中 JMS 就是典型的异步消息处理机制，JMS 消息有两种类型：点对点、发布/订阅。</p></li><li data-list-text="6."><p class="s171" style="padding-top: 12pt;padding-left: 37pt;text-indent: -14pt;text-align: left;">activeMQ 如何调优</p></li></ol></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l172"><li data-list-text="1."><p class="s172" style="padding-left: 38pt;text-indent: -15pt;text-align: left;">使用非持久化消息;</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s172" style="padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">需要确保消息发送成功时使用事务来将消息分批组合. public void sendTransacted() throws JMSException {</p></li></ol><p class="s172" style="padding-left: 23pt;text-indent: 28pt;line-height: 141%;text-align: left;">ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory();</p><p class="s172" style="padding-left: 51pt;text-indent: 0pt;line-height: 141%;text-align: left;">Connection connection = cf.createConnection(); connection.start();</p><p class="s172" style="padding-left: 23pt;text-indent: 28pt;line-height: 141%;text-align: left;">Session session = connection.createSession(true, Session.SESSION_TRANSACTED);</p><p class="s172" style="padding-left: 51pt;text-indent: 0pt;line-height: 141%;text-align: left;">Topic topic = session.createTopic(&quot;Test.Transactions&quot;); MessageProducer producer = session.createProducer(topic); int count = 0;</p><p class="s172" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">for (int i = 0; i &lt; 1000; i++) {</p><p class="s172" style="padding-top: 9pt;padding-left: 65pt;text-indent: 0pt;text-align: left;">Message message = session.createTextMessage(&quot;message &quot; +</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">i);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">producer.send(message); if (i != 0 &amp;&amp; i % 10 == 0) {</p><p class="s172" style="padding-top: 1pt;padding-left: 79pt;text-indent: 0pt;text-align: left;">session.commit();</p><p class="s172" style="padding-top: 9pt;padding-left: 65pt;text-indent: 0pt;text-align: left;">}</p><p class="s172" style="padding-top: 9pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-top: 1pt;padding-left: 37pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 51pt;text-indent: -14pt;line-height: 141%;text-align: left;">public void sendNonTransacted() throws JMSException { ActiveMQConnectionFactory cf = new</p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">ActiveMQConnectionFactory();</p><p class="s172" style="padding-top: 9pt;padding-left: 51pt;text-indent: 0pt;line-height: 141%;text-align: left;">Connection connection = cf.createConnection(); connection.start();</p><p class="s172" style="padding-left: 51pt;text-indent: 0pt;line-height: 141%;text-align: left;">// create a default session (no transactions) Session session = connection.createSession(false,</p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">Session.AUTO_ACKNOWELDGE);</p><p class="s172" style="padding-top: 9pt;padding-left: 51pt;text-indent: 0pt;line-height: 141%;text-align: left;">Topic topic = session.createTopic(&quot;Test.Transactions&quot;); MessageProducer producer = session.createProducer(topic); int count = 0;</p><p class="s172" style="padding-left: 51pt;text-indent: 0pt;text-align: left;">for (int i = 0; i &lt; 1000; i++) {</p><p class="s172" style="padding-top: 9pt;padding-left: 65pt;text-indent: 0pt;text-align: left;">Message message = session.createTextMessage(&quot;message &quot; +</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">i);</p><p class="s172" style="padding-top: 9pt;padding-left: 65pt;text-indent: 0pt;text-align: left;">producer.send(message);</p><p class="s172" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">}</p><p class="s172" style="padding-top: 9pt;padding-left: 30pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l173"><li data-list-text="7."><p class="s171" style="padding-top: 1pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">什么是死信队列？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">如果你想在消息处理失败后，不被服务器删除，还能被其他消费者处理或重</p><p class="s172" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: justify;">试，可以关闭 AUTO_ACKNOWLEDGE，将 ack 交由程序自己处理。那如果使用了 AUTO_ACKNOWLEDGE，消息是什么时候被确认的，还有没有阻止消息确认的方法？有！</p><p class="s172" style="padding-top: 12pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">消费消息有 2 种方法，一种是调用 consumer.receive()方法，该方法将阻塞直到获得并返回一条消息。这种情况下，消息返回给方法调用者之后就自动被确认了。另一种方法是采用 listener 回调函数，在有消息到达时，会调用 listener 接口的 onMessage 方法。在这种情况下，在 onMessage 方法执行完毕后，消息才会被确认，此时只要在方法中抛出异常，该消息就不会被确</p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">认。那么问题来了，如果一条消息不能被处理，会被退回服务器重新分配，如果只有一个消费者，该消息又会重新被获取，重新抛异常。就算有多个消费 者，往往在一个服务器上不能处理的消息，在另外的服务器上依然不能被处 理。难道就这么退回--获取--报错死循环了吗？</p><p class="s172" style="padding-top: 12pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">在重试 6 次后，ActiveMQ 认为这条消息是“有毒”的，将会把消息丢到死信队列里。如果你的消息不见了，去 ActiveMQ.DLQ 里找找，说不定就躺在那里。</p></li><li data-list-text="8."><p class="s171" style="padding-top: 14pt;padding-left: 33pt;text-indent: -10pt;text-align: left;">Basic.Reject 的用法是什么？</p><p class="s172" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">答：该信令可用于 consumer 对收到的 message 进行 reject 。若在该信令中设置 requeue=true，则当 RabbitMQ server 收到该拒绝信令后，会将该 message 重新发送到下一个处于 consume 状态的 consumer 处（理论上仍可能将该消息发送给当前 consumer）。若设置 requeue=false ，则 RabbitMQ server 在收到拒绝信令后，将直接将该 message 从 queue 中移除。</p><p class="s172" style="padding-top: 14pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">另外一种移除 queue 中 message 的小技巧是，consumer 回复 Basic.Ack</p><p class="s172" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">但不对获取到的 message 做任何处理。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">而 Basic.Nack 是对 Basic.Reject 的扩展，以支持一次拒绝多条 message</p><p class="s172" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">的能力。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="9."><p class="s171" style="padding-left: 33pt;text-indent: -10pt;text-align: left;">为什么不应该对所有的 message 都使用持久化机制？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">答：首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多，message的吞吐量可能有 10 倍的差距。其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现“坑爹”问题。矛盾点在于，若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed ；若 message 设置了 persistent 属性，同时 queue 也设置了 durable 属性，那么当 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在这段时间</p><p class="s172" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">内发送给该 queue 的 message 将被 blackholed 。所以，是否要对 message 进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条/秒以上的消息吞吐量（单 RabbitMQ 服务器），则要么使用其他的方式来确保 message 的可靠 delivery ，要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。另外一种处理原则是：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。</p></li><li data-list-text="10."><p class="s171" style="padding-top: 14pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">为什么 heavy RPC 的使用场景下不建议采用 disk node ？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: justify;">答：heavy RPC 是指在业务逻辑中高频调用 RabbitMQ 提供的 RPC 机制，导致不断创建、销毁 reply queue ，进而造成 disk node 的性能问题（因为会针对元数据不断写盘）。所以在使用 RPC 机制时需要考虑自身的业务场</p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">景。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="11."><p class="s171" style="padding-left: 41pt;text-indent: -18pt;text-align: left;">向不存在的 exchange 发 publish 消息会发生什么？向不存在的</p><p class="s171" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">queue 执行 consume 动作会发生什么？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">答：都会收到 Channel.Close 信令告之不存在（内含原因 404 NOT_FOUND）。</p></li><li data-list-text="12."><p class="s171" style="padding-top: 14pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">什么情况下 producer 不主动创建 queue 是安全的？</p><p class="s172" style="padding-top: 1pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">答：1.message 是允许丢失的；2.实现了针对未处理消息的 republish 功能</p><p class="s172" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">（例如采用 Publisher Confirm 机制）。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="13."><p class="s171" style="padding-left: 47pt;text-indent: -24pt;text-align: left;">“dead letter”queue 的用途？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">答：当消息被 RabbitMQ server 投递到 consumer 后，但 consumer 却通过 Basic.Reject 进行了拒绝时（同时设置 requeue=false），那么该消息会被放入“dead letter”queue 中。该 queue 可用于排查 message 被 reject 或 undeliver 的原因。</p></li><li data-list-text="14."><p class="s171" style="padding-top: 14pt;padding-left: 41pt;text-indent: -18pt;text-align: left;">为什么说保证 message 被可靠持久化的条件是 queue 和 exchange</p></li></ol><p class="s171" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">具有 durable 属性，同时 message 具有 persistent 属性才行？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s172" style="padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">答：binding 关系可以表示为 exchange – binding – queue 。从文档中我们知道，若要求投递的 message 能够不丢失，要求 message 本身设置 persistent 属性，要求 exchange 和 queue 都设置 durable 属性。其实这问题可以这么想，若 exchange 或 queue 未设置 durable 属性，则在其 crash 之后就会无法恢复，那么即使 message 设置了 persistent 属性，仍然存在 message 虽然能恢复但却无处容身的问题；同理，若 message 本身未设置 persistent 属性，则 message 的持久化更无从谈起。</p><ol id="l174"><li data-list-text="1."><p class="s97" style="padding-left: 31pt;text-indent: -8pt;line-height: 18pt;text-align: left;">请列举出在 <span class="s91">JDK </span>中几个常用的设计模式？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">单例模式（<span class="s84">Singleton    pattern</span>）用于 <span class="s84">Runtime</span>，<span class="s84">Calendar </span>和其他的一些类中。工厂模式</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">（<span class="s84">Factory pattern</span>）被用于各种不可变的类如 <span class="s84">Boolean</span>，像 <span class="s84">Boolean.valueOf</span>，观察者模式</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">（<span class="s84">Observer pattern</span>）被用于 <span class="s84">Swing </span>和很多的事件监听中。装饰器设计模式（<span class="s84">Decorator design pattern</span>）被用于多个 <span class="s84">Java IO </span>类中。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s97" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">什么是设计模式？你是否在你的代码里面使用过<span class="p">任</span>何设计模式？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法。设计模式是代码可用性的延伸</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s91" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">Java <span class="s97">中什么叫单例设计模式？请用 </span>Java <span class="s97">写出线程安全的单例模式</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">单例模式重点在于在整个系统上共享一些创建时较耗资源的对象。整个应用中只维护一个特定类实例，它被所有组件共同使用。<span class="s84">Java.lang.Runtime </span>是单例模式的经典例子。从 <span class="s84">Java</span></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">5 <span class="p">开始你可以使用枚举（</span>enum<span class="p">）来实现线程安全的单例。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s97" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">在 <span class="s91">Java </span>中，什么叫观察者设计模式（<span class="s91">observer design pattern</span>）？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">观察者模式是基于对象的状态变化和观察者的通讯，以便他们作出相应的操作。简单的例子就是一个天气系统，当天气变化时必须在展示给公众的视图中进行反映。这个视图对象是一个主体，而不同的视图是观察者。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="5."><p class="s97" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">使用工厂模式最主要的好处是什么？在哪里使用？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">工厂模式的最大好处是增加了创建对象时的封装层次。如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="6."><p class="s97" style="padding-left: 23pt;text-indent: 0pt;line-height: 81%;text-align: left;">举一个用 <span class="s91">Java </span>实现的装饰模式<span class="s91">(decorator design pattern)</span>？它是作用于对象层次还是类层次？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">装饰模式增加强了单个对象的能力。<span class="s84">Java   IO </span>到处都使用了装饰模式，典型例子就是 <span class="s84">Buffered </span>系列类如 <span class="s84">BufferedReader </span>和 <span class="s84">BufferedWriter</span>，它们增强了 <span class="s84">Reader </span>和 <span class="s84">Writer </span>对象，以实现提升性能的 <span class="s84">Buffer </span>层次的读取和写入。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="7."><p class="s97" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">在 <span class="s91">Java </span>中，为什么不允许从静态方法中访问非静态变量？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s84" style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Java <span class="p">中不能从静态上下文访问非静态数据只是因为非静态变量是跟具体的对象实例关联的，而静态的却没有和任何实例关联。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="8."><p class="s97" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">设计一个 <span class="s91">ATM </span>机，请说出你的设计思路？</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">比如设计金融系统来说，必须知道它们应该在任何情况下都能够正常工作。不管是断电还是其他情况，<span class="s84">ATM </span>应该保持正确的状态（事务） <span class="s84">,    </span>想想加锁（<span class="s84">locking</span>）、事务</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">（<span class="s84">transaction</span>）、错误条件（<span class="s84">error condition</span>）、边界条件（<span class="s84">boundary condition</span>） 等等。尽管你不能想到具体的设计，但如果你可以指出非功能性需求，提出一些问题，想到关于边界条件，这些都会是很好的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="9."><p class="s97" style="padding-left: 31pt;text-indent: -8pt;text-align: left;">在 <span class="s91">Java </span>中，什么时候用重载，什么时候用重写？</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;">如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">（<span class="s84">overriding</span>），而重载（<span class="s84">overloading</span>）是用不同的输入做同一件事。在 <span class="s84">Java </span>中，重载的方法签名不同，而重写并不是。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="10."><p class="s97" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">举例说明什么情况下会更倾向于使用抽象类而不是接口？</p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: left;">接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">在 <span class="s84">Java </span>中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">接口通常被用来表示附属描述或行为如：<span class="s84">Runnable</span>、<span class="s84">Clonable</span>、<span class="s84">Serializable </span>等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 <span class="s84">Runnable </span>和 <span class="s84">Clonable(</span>注：这里的意思是指如果把 <span class="s84">Runnable </span>等实现为抽象类的情况<span class="s84">)</span>，因为在 <span class="s84">Java </span>中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</p><p style="padding-left: 23pt;text-indent: 0pt;line-height: 13pt;text-align: left;">在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。</p><p style="padding-top: 2pt;padding-left: 23pt;text-indent: 0pt;line-height: 115%;text-align: justify;">如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</p><p class="s64" style="padding-left: 23pt;text-indent: 0pt;line-height: 25pt;text-align: left;">何谓悲观锁与乐观锁</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s71" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">悲观锁</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 75%;text-align: justify;">总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<span class="s65">共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线</span></p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;line-height: 17pt;text-align: left;">程<span class="s66">）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁</span></p><p class="s66" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 147%;text-align: left;">等，读锁，写锁等，都是在做操作之前先上锁。<span class="s67">Java </span>中 <span class="s75">synchronized </span>和 <span class="s75">ReentrantLock </span>等独占锁就是悲观锁思想的实现。</p><p class="s65" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">乐观锁</p><p class="s66" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以</p><p class="s66" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 148%;text-align: left;">使用版本号机制和 <span class="s67">CAS </span>算法实现。<span class="s65">乐观锁适用于多读的应用类型，这样可以提高吞吐量</span>，像数据库提供的类似于 <span class="s70">write_condition </span><span class="s65">机制</span>，其实都是提供的乐观锁。在 <span class="s67">Java </span>中 <span class="s75">java.util.concurrent.atomic </span>包下面的原子变量类就是使用了</p><p class="s66" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">乐观锁的一种实现方式 <span class="s70">CAS </span>实现的。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">两种锁的使用场景</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 83%;text-align: justify;">从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<span class="s65">乐观锁适用于写比较少的情况下（多读场景）</span>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的</p><p class="s66" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 123%;text-align: justify;">情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 <span class="s67">retry</span>，这样反倒是降低了性能，所以<span class="s65">一般多写的场景下用悲观锁就比较合适。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s64" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">乐观锁常见的两种实现方式</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s174" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">乐观锁一般会使用版本号机制或 <span class="s175">CAS </span>算法实现。</p><ol id="l175"><li data-list-text="1."><p class="s65" style="padding-left: 39pt;text-indent: -16pt;text-align: left;">版本号机制</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: justify;">一般是在数据表中加上一个数据版本号 <span class="s67">version </span>字段，表示数据被修改的次</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: justify;">数，当数据被修改时，<span class="s67">version </span>值会加一。当线程 <span class="s67">A </span>要更新数据值时，在读取数据的同时也会读取 <span class="s67">version </span>值，在提交更新时，若刚才读取到的 <span class="s67">version </span>值为当前数据库中的 <span class="s67">version </span>值相等时才更新，否则重试更新操作，直到更新成功。</p><p class="s66" style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;line-height: 155%;text-align: justify;"><span class="s65">举一个简单的例子： </span>假设数据库中帐户信息表中有一个 <span class="s67">version </span>字段，当前值为 <span class="s67">1 </span>；而当前帐户余额字段（ <span class="s67">balance </span>）为 <span class="s67">$100 </span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l176"><li data-list-text="1."><p class="s66" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">操作员 <span class="s67">A </span>此时将其读出（ <span class="s67">version=1 </span>），并从其帐户余额中扣除 <span class="s67">$50</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">（ <span class="s67">$100-$50 </span>）。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2."><p class="s66" style="padding-left: 58pt;text-indent: -18pt;text-align: left;">在操作员 <span class="s67">A </span>操作的过程中，操作员 <span class="s67">B </span>也读入此用户信息（</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">version=1 <span class="s66">），并从其帐户余额中扣除 </span>$20 <span class="s66">（ </span>$100-$20 <span class="s66">）。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3."><p class="s66" style="padding-left: 59pt;text-indent: -18pt;text-align: justify;">操作员 <span class="s67">A </span>完成了修改工作，将数据版本号加一（ <span class="s67">version=2 </span>），连同</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 59pt;text-indent: 0pt;line-height: 148%;text-align: left;">帐户扣除后余额（ <span class="s67">balance=$50 </span>），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 <span class="s67">version </span>更新为 <span class="s67">2 </span>。</p></li><li data-list-text="4."><p class="s66" style="padding-top: 10pt;padding-left: 59pt;text-indent: -18pt;line-height: 191%;text-align: justify;">操作员 <span class="s67">B </span>完成了操作，也将版本号加一（ <span class="s67">version=2 </span>）试图向数据库提交数据（ <span class="s67">balance=$80 </span>），但此时比对数据库记录版本时发现，操作员 <span class="s67">B </span>提交的数据版本号为 <span class="s67">2 </span>，数据库记录当前版本也为 <span class="s67">2 </span>，不满足 <span class="s67">“ </span>提交版本必须大于记录当前版本才能执行更新 <span class="s67">“ </span>的乐观锁策略，因此，操作员 <span class="s67">B </span>的提交被驳回。</p><p class="s66" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">这样，就避免了操作员 <span class="s67">B </span>用基于 <span class="s67">version=1 </span>的旧数据修改的结果覆盖操作员</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">A <span class="s66">的操作结果的可能。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="2."><p class="s70" style="padding-left: 36pt;text-indent: -13pt;text-align: left;">CAS <span class="s65">算法</span></p></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 122%;text-align: left;">即 <span class="s70">compare and swap</span><span class="s65">（比较与交换）</span>，是一种有名的<span class="s65">无锁算法</span>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的</p><p class="s66" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;line-height: 174%;text-align: left;">情况下实现变量的同步，所以也叫非阻塞同步（<span class="s67">Non-blocking Synchronization</span>）。<span class="s70">CAS </span><span class="s65">算法</span>涉及到三个操作数</p><ul id="l177"><li data-list-text=""><p class="s66" style="padding-top: 9pt;padding-left: 59pt;text-indent: -18pt;text-align: left;">需要读写的内存值 <span class="s67">V</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s66" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">进行比较的值 <span class="s67">A</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text=""><p class="s66" style="padding-left: 59pt;text-indent: -18pt;text-align: left;">拟写入的新值 <span class="s67">B</span></p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">当且仅当 <span class="s67">V </span>的值等于 <span class="s67">A </span>时，<span class="s67">CAS </span>通过原子方式用新值 <span class="s67">B </span>来更新 <span class="s67">V </span>的值，否则</p><p class="s66" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;line-height: 71%;text-align: left;">不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<span class="s65">自旋操作</span>，即<span class="s65">不断的重试</span>。</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 23pt;text-indent: 0pt;text-align: left;"><a href="https://blog.csdn.net/qq_34337272/article/details/81252853" style=" color: #24292E; font-family:宋体; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt;" target="_blank">关于自旋锁，大家可以看一下这篇文章，非常不错：</a><a href="https://blog.csdn.net/qq_34337272/article/details/81252853" class="s82" target="_blank">《 面试必备之深入理解自旋锁》</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s64" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">乐观锁的缺点</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s72" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">ABA <span class="s71">问题是乐观锁一个常见的问题</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l178"><li data-list-text="1"><p class="s70" style="padding-left: 33pt;text-indent: -10pt;text-align: left;">ABA <span class="s65">问题</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 191%;text-align: left;">如果一个变量 <span class="s67">V </span>初次读取的时候是 <span class="s67">A </span>值，并且在准备赋值的时候检查到它仍然是 <span class="s67">A </span>值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能</p><p class="s66" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;line-height: 173%;text-align: justify;">的，因为在这段时间它的值可能被改为其他值，然后又改回 <span class="s67">A</span>，那 <span class="s67">CAS </span>操作就会误认为它从来没有被修改过。这个问题被称为 <span class="s67">CAS </span>操作的 <span class="s70">&quot;ABA&quot;</span><span class="s65">问题。</span></p><p class="s67" style="padding-top: 8pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">JDK 1.5 <span class="s66">以后的 </span><span class="s75">AtomicStampedReference </span><span class="s176">类</span><span class="s177">就提供了此种能力，其中的</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s75" style="padding-left: 23pt;text-indent: 3pt;text-align: left;">compareAndSet <span class="s176">方法</span><span class="s177">就是首先检查当前引用是否等于预期引用，并且当前标志是</span></p><p class="s66" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2"><p class="s65" style="padding-left: 35pt;text-indent: -12pt;text-align: left;">循环时间长开销大</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 148%;text-align: justify;"><span class="s65">自旋 </span><span class="s70">CAS</span><span class="s65">（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给 </span><span class="s70">CPU </span><span class="s65">带来非常大的执行开销。 </span>如果 <span class="s67">JVM </span>能支持处理器提供的 <span class="s67">pause </span>指令那么效率会有一定的提升，<span class="s67">pause </span>指令有两个作用，第一它可以延迟流水线执行指</p><p class="s66" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;line-height: 148%;text-align: left;">令（<span class="s67">de-pipeline</span>）<span class="s67">,</span>使 <span class="s67">CPU </span>不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（<span class="s67">memory order violation</span>）而引起 <span class="s67">CPU </span>流水线被清空</p><p class="s66" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">（<span class="s67">CPU pipeline flush</span>），从而提高 <span class="s67">CPU </span>的执行效率。</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="3"><p class="s65" style="padding-left: 35pt;text-indent: -12pt;text-align: left;">只能保证一个共享变量的原子操作</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s67" style="padding-left: 23pt;text-indent: 0pt;line-height: 190%;text-align: left;">CAS <span class="s66">只对单个共享变量有效，当操作涉及跨多个共享变量时 </span>CAS <span class="s66">无效。但是从 </span>JDK 1.5 <span class="s66">开始，提供了 </span><span class="s75">AtomicReference </span><span class="s176">类</span><span class="s177">来保证引用对象之间的原子性，你</span></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 147%;text-align: left;">可以把多个变量放在一个对象里来进行 <span class="s67">CAS </span>操作<span class="s67">.</span>所以我们可以使用锁或者利用 <span class="s75">AtomicReference </span><span class="s176">类</span><span class="s177">把多个共享变量合并成一个共享变量来操作。</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s69" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">CAS <span class="s64">与 </span>synchronized <span class="s64">的使用情景</span></p><p class="s174" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">简单的来说 <span class="s175">CAS </span>适用于写比较少的情况下（多读场景，冲突一般较少），</p><p class="s175" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">synchronized <span class="s174">适用于写比较多的情况下（多写场景，冲突一般较多）</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l179"><li data-list-text="1."><p class="s66" style="padding-left: 59pt;text-indent: -18pt;line-height: 147%;text-align: justify;">对于资源竞争较少（线程冲突较轻）的情况，使用 <span class="s67">synchronized </span>同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗 <span class="s67">cpu </span>资源；而 <span class="s67">CAS </span>基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</p></li><li data-list-text="2."><p class="s66" style="padding-top: 3pt;padding-left: 59pt;text-indent: -18pt;line-height: 191%;text-align: justify;">对于资源竞争严重（线程冲突严重）的情况，<span class="s67">CAS </span>自旋的概率会比较大，从而浪费更多的 <span class="s67">CPU </span>资源，效率低于 <span class="s67">synchronized</span>。</p></li></ol></li></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">补充： <span class="s67">Java </span>并发编程这个领域中 <span class="s67">synchronized </span>关键字一直都是元老级的角</p><p class="s66" style="padding-top: 11pt;padding-left: 23pt;text-indent: 0pt;line-height: 141%;text-align: left;">色，很久之前很多人都会称它为 <span class="s70">“</span><span class="s65">重量级锁</span><span class="s70">” </span>。但是，在 <span class="s67">JavaSE 1.6 </span>之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <span class="s65">偏向锁 </span>和 <span class="s65">轻量级锁 </span>以及其它<span class="s65">各种优化</span>之后变得在某些情况下并不是那么重了。<span class="s67">synchronized </span>的</p><p class="s66" style="padding-left: 23pt;text-indent: 0pt;line-height: 112%;text-align: left;">底层实现主要依靠 <span class="s70">Lock-Free </span>的队列，基本思路是 <span class="s65">自旋后阻塞</span>，<span class="s65">竞争切换后继续竞争锁</span>，<span class="s65">稍微牺牲了公平性，但获得了高吞吐量</span>。在线程冲突较少的情况 下，可以获得和 <span class="s67">CAS </span>类似的性能；而线程冲突严重的情况下，性能远高于</p><p class="s67" style="padding-top: 12pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">CAS<span class="s66">。</span></p></body></html>
